
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="X-UA-Compatible" content="IE=Edge" />
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>graph_tool.inference - Statistical inference of generative network models &#8212; graph-tool 2.27 documentation</title>
    <link rel="stylesheet" href="_static/gt_style.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    <script type="text/javascript" id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <script type="text/javascript" src="_static/MathJax/MathJax.js?config=default"></script>
    <link rel="search" type="application/opensearchdescription+xml"
          title="Search within graph-tool 2.27 documentation"
          href="_static/opensearch.xml"/>
    <link rel="shortcut icon" href="_static/graph-icon.ico"/>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="graph_tool.search - Search algorithms" href="http://graph-tool.skewed.de/static/doc/search_module.html" />
    <link rel="prev" title="graph_tool.generation - Random graph generation" href="http://graph-tool.skewed.de/static/doc/generation.html" />
    <script type="text/javascript">
      var _gaq = _gaq || [];
      var pluginUrl =
        '//www.google-analytics.com/plugins/ga/inpage_linkid.js';
      _gaq.push(['_require', 'inpage_linkid', pluginUrl]);
      _gaq.push(['_setAccount', 'UA-248813-2']);
      _gaq.push(['_setDomainName', '.skewed.de']);
      _gaq.push(['_trackPageview']);
      (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
      })();
    </script>
     

  </head><body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="http://graph-tool.skewed.de/static/doc/search_module.html" title="graph_tool.search - Search algorithms"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="http://graph-tool.skewed.de/static/doc/generation.html" title="graph_tool.generation - Random graph generation"
             accesskey="P">previous</a> |</li>
    <li><img src="../../img/graph-icon.png" alt="logo" style="margin-right: 5px; margin-bottom:-2px;" /><a href="../../index.html">Project Homepage</a> &raquo;</li>
    
        <li class="nav-item nav-item-0"><a href="index.html">graph-tool 2.27 documentation</a> &#187;</li>

          <li class="nav-item nav-item-1"><a href="http://graph-tool.skewed.de/static/doc/modules.html" >Module documentation</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="graph_tool.html" accesskey="U">graph_tool - efficient graph analysis and manipulation</a> &#187;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <span class="target" id="module-graph_tool.inference"></span><div class="section" id="graph-tool-inference-statistical-inference-of-generative-network-models">
<h1><code class="docutils literal notranslate"><span class="pre">graph_tool.inference</span></code> - Statistical inference of generative network models<a class="headerlink" href="inference.html#graph-tool-inference-statistical-inference-of-generative-network-models" title="Permalink to this headline">¶</a></h1>
<p>This module contains algorithms for the identification of large-scale network
structure via the statistical inference of generative models.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">An introduction to the concepts used here, as well as a basic HOWTO is
included in the cookbook section: <a class="reference internal" href="demos/inference/inference.html#inference-howto"><span class="std std-ref">Inferring modular network structure</span></a>.</p>
</div>
<div class="section" id="nonparametric-stochastic-block-model-inference">
<h2>Nonparametric stochastic block model inference<a class="headerlink" href="inference.html#nonparametric-stochastic-block-model-inference" title="Permalink to this headline">¶</a></h2>
<div class="section" id="high-level-functions">
<h3>High-level functions<a class="headerlink" href="inference.html#high-level-functions" title="Permalink to this headline">¶</a></h3>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="inference.html#graph_tool.inference.minimize.minimize_blockmodel_dl" title="graph_tool.inference.minimize.minimize_blockmodel_dl"><code class="xref py py-obj docutils literal notranslate"><span class="pre">minimize_blockmodel_dl</span></code></a></td>
<td>Fit the stochastic block model, by minimizing its description length using an agglomerative heuristic.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="inference.html#graph_tool.inference.minimize.minimize_nested_blockmodel_dl" title="graph_tool.inference.minimize.minimize_nested_blockmodel_dl"><code class="xref py py-obj docutils literal notranslate"><span class="pre">minimize_nested_blockmodel_dl</span></code></a></td>
<td>Fit the nested stochastic block model, by minimizing its description length using an agglomerative heuristic.</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="state-classes">
<h3>State classes<a class="headerlink" href="inference.html#state-classes" title="Permalink to this headline">¶</a></h3>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="inference.html#graph_tool.inference.blockmodel.BlockState" title="graph_tool.inference.blockmodel.BlockState"><code class="xref py py-obj docutils literal notranslate"><span class="pre">BlockState</span></code></a></td>
<td>The stochastic block model state of a given graph.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="inference.html#graph_tool.inference.overlap_blockmodel.OverlapBlockState" title="graph_tool.inference.overlap_blockmodel.OverlapBlockState"><code class="xref py py-obj docutils literal notranslate"><span class="pre">OverlapBlockState</span></code></a></td>
<td>The overlapping stochastic block model state of a given graph.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="inference.html#graph_tool.inference.layered_blockmodel.LayeredBlockState" title="graph_tool.inference.layered_blockmodel.LayeredBlockState"><code class="xref py py-obj docutils literal notranslate"><span class="pre">LayeredBlockState</span></code></a></td>
<td>The (possibly overlapping) block state of a given graph, where the edges are divided into discrete layers.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="inference.html#graph_tool.inference.nested_blockmodel.NestedBlockState" title="graph_tool.inference.nested_blockmodel.NestedBlockState"><code class="xref py py-obj docutils literal notranslate"><span class="pre">NestedBlockState</span></code></a></td>
<td>The nested stochastic block model state of a given graph.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="inference.html#graph_tool.inference.mcmc.TemperingState" title="graph_tool.inference.mcmc.TemperingState"><code class="xref py py-obj docutils literal notranslate"><span class="pre">TemperingState</span></code></a></td>
<td>This class aggregates several state classes and corresponding inverse-temperature values to implement <a class="reference external" href="https://en.wikipedia.org/wiki/Parallel_tempering">parallel tempering MCMC</a>.</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="sampling-and-minimization">
<h3>Sampling and minimization<a class="headerlink" href="inference.html#sampling-and-minimization" title="Permalink to this headline">¶</a></h3>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="inference.html#graph_tool.inference.mcmc.mcmc_equilibrate" title="graph_tool.inference.mcmc.mcmc_equilibrate"><code class="xref py py-obj docutils literal notranslate"><span class="pre">mcmc_equilibrate</span></code></a></td>
<td>Equilibrate a MCMC with a given starting state.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="inference.html#graph_tool.inference.mcmc.mcmc_anneal" title="graph_tool.inference.mcmc.mcmc_anneal"><code class="xref py py-obj docutils literal notranslate"><span class="pre">mcmc_anneal</span></code></a></td>
<td>Equilibrate a MCMC at a specified target temperature by performing simulated annealing.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="inference.html#graph_tool.inference.mcmc.mcmc_multilevel" title="graph_tool.inference.mcmc.mcmc_multilevel"><code class="xref py py-obj docutils literal notranslate"><span class="pre">mcmc_multilevel</span></code></a></td>
<td>Equilibrate a MCMC from a starting state with a higher order, by performing successive agglomerative initializations and equilibrations until the desired order is reached, such that metastable states are avoided.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="inference.html#graph_tool.inference.mcmc.multicanonical_equilibrate" title="graph_tool.inference.mcmc.multicanonical_equilibrate"><code class="xref py py-obj docutils literal notranslate"><span class="pre">multicanonical_equilibrate</span></code></a></td>
<td>Equilibrate a multicanonical Monte Carlo sampling using the Wang-Landau algorithm.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="inference.html#graph_tool.inference.mcmc.MulticanonicalState" title="graph_tool.inference.mcmc.MulticanonicalState"><code class="xref py py-obj docutils literal notranslate"><span class="pre">MulticanonicalState</span></code></a></td>
<td>The density of states of a multicanonical Monte Carlo algorithm.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="inference.html#graph_tool.inference.bisection.bisection_minimize" title="graph_tool.inference.bisection.bisection_minimize"><code class="xref py py-obj docutils literal notranslate"><span class="pre">bisection_minimize</span></code></a></td>
<td>Find the best order (number of groups) given an initial set of states by performing a one-dimension minimization, using a Fibonacci (or golden section) search.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="inference.html#graph_tool.inference.nested_blockmodel.hierarchy_minimize" title="graph_tool.inference.nested_blockmodel.hierarchy_minimize"><code class="xref py py-obj docutils literal notranslate"><span class="pre">hierarchy_minimize</span></code></a></td>
<td>Attempt to find a fit of the nested stochastic block model that minimizes the description length.</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="auxiliary-functions">
<h3>Auxiliary functions<a class="headerlink" href="inference.html#auxiliary-functions" title="Permalink to this headline">¶</a></h3>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="inference.html#graph_tool.inference.blockmodel.model_entropy" title="graph_tool.inference.blockmodel.model_entropy"><code class="xref py py-obj docutils literal notranslate"><span class="pre">model_entropy</span></code></a></td>
<td>Computes the amount of information necessary for the parameters of the traditional blockmodel ensemble, for <code class="docutils literal notranslate"><span class="pre">B</span></code> blocks, <code class="docutils literal notranslate"><span class="pre">N</span></code> vertices, <code class="docutils literal notranslate"><span class="pre">E</span></code> edges, and either a directed or undirected graph.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="inference.html#graph_tool.inference.blockmodel.mf_entropy" title="graph_tool.inference.blockmodel.mf_entropy"><code class="xref py py-obj docutils literal notranslate"><span class="pre">mf_entropy</span></code></a></td>
<td>Compute the “mean field” entropy given the vertex block membership marginals.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="inference.html#graph_tool.inference.blockmodel.bethe_entropy" title="graph_tool.inference.blockmodel.bethe_entropy"><code class="xref py py-obj docutils literal notranslate"><span class="pre">bethe_entropy</span></code></a></td>
<td>Compute the Bethe entropy given the edge block membership marginals.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="inference.html#graph_tool.inference.blockmodel.microstate_entropy" title="graph_tool.inference.blockmodel.microstate_entropy"><code class="xref py py-obj docutils literal notranslate"><span class="pre">microstate_entropy</span></code></a></td>
<td>Compute microstate entropy given a histogram of partitions.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="inference.html#graph_tool.inference.overlap_blockmodel.half_edge_graph" title="graph_tool.inference.overlap_blockmodel.half_edge_graph"><code class="xref py py-obj docutils literal notranslate"><span class="pre">half_edge_graph</span></code></a></td>
<td>Generate a half-edge graph, where each half-edge is represented by a node, and an edge connects the half-edges like in the original graph.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="inference.html#graph_tool.inference.overlap_blockmodel.get_block_edge_gradient" title="graph_tool.inference.overlap_blockmodel.get_block_edge_gradient"><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_block_edge_gradient</span></code></a></td>
<td>Get edge gradients corresponding to the block membership at the endpoints of the edges given by the <code class="docutils literal notranslate"><span class="pre">be</span></code> edge property map.</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="auxiliary-classes">
<h3>Auxiliary classes<a class="headerlink" href="inference.html#auxiliary-classes" title="Permalink to this headline">¶</a></h3>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="inference.html#graph_tool.inference.blockmodel.PartitionHist" title="graph_tool.inference.blockmodel.PartitionHist"><code class="xref py py-obj docutils literal notranslate"><span class="pre">PartitionHist</span></code></a></td>
<td>Histogram of partitions, implemented in C++.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="inference.html#graph_tool.inference.blockmodel.BlockPairHist" title="graph_tool.inference.blockmodel.BlockPairHist"><code class="xref py py-obj docutils literal notranslate"><span class="pre">BlockPairHist</span></code></a></td>
<td>Histogram of block pairs, implemented in C++.</td>
</tr>
</tbody>
</table>
</div>
</div>
<div class="section" id="nonparametric-network-reconstruction">
<h2>Nonparametric network reconstruction<a class="headerlink" href="inference.html#nonparametric-network-reconstruction" title="Permalink to this headline">¶</a></h2>
<div class="section" id="id1">
<h3>State classes<a class="headerlink" href="inference.html#id1" title="Permalink to this headline">¶</a></h3>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="inference.html#graph_tool.inference.uncertain_blockmodel.MeasuredBlockState" title="graph_tool.inference.uncertain_blockmodel.MeasuredBlockState"><code class="xref py py-obj docutils literal notranslate"><span class="pre">MeasuredBlockState</span></code></a></td>
<td>The inference state of a measured graph, using the stochastic block model as a prior.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="inference.html#graph_tool.inference.uncertain_blockmodel.MixedMeasuredBlockState" title="graph_tool.inference.uncertain_blockmodel.MixedMeasuredBlockState"><code class="xref py py-obj docutils literal notranslate"><span class="pre">MixedMeasuredBlockState</span></code></a></td>
<td>The inference state of a measured graph with heterogeneous errors, using the stochastic block model as a prior.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="inference.html#graph_tool.inference.uncertain_blockmodel.UncertainBlockState" title="graph_tool.inference.uncertain_blockmodel.UncertainBlockState"><code class="xref py py-obj docutils literal notranslate"><span class="pre">UncertainBlockState</span></code></a></td>
<td>The inference state of an uncertain graph, using the stochastic block model as a prior.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="inference.html#graph_tool.inference.uncertain_blockmodel.UncertainBaseState" title="graph_tool.inference.uncertain_blockmodel.UncertainBaseState"><code class="xref py py-obj docutils literal notranslate"><span class="pre">UncertainBaseState</span></code></a></td>
<td>Base state for uncertain network inference.</td>
</tr>
</tbody>
</table>
</div>
</div>
<div class="section" id="semiparametric-stochastic-block-model-inference">
<h2>Semiparametric stochastic block model inference<a class="headerlink" href="inference.html#semiparametric-stochastic-block-model-inference" title="Permalink to this headline">¶</a></h2>
<div class="section" id="id2">
<h3>State classes<a class="headerlink" href="inference.html#id2" title="Permalink to this headline">¶</a></h3>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="inference.html#graph_tool.inference.blockmodel_em.EMBlockState" title="graph_tool.inference.blockmodel_em.EMBlockState"><code class="xref py py-obj docutils literal notranslate"><span class="pre">EMBlockState</span></code></a></td>
<td>The parametric, undirected stochastic block model state of a given graph.</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="expectation-maximization-inference">
<h3>Expectation-maximization Inference<a class="headerlink" href="inference.html#expectation-maximization-inference" title="Permalink to this headline">¶</a></h3>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="inference.html#graph_tool.inference.blockmodel_em.em_infer" title="graph_tool.inference.blockmodel_em.em_infer"><code class="xref py py-obj docutils literal notranslate"><span class="pre">em_infer</span></code></a></td>
<td>Infer the model parameters and latent variables using the expectation-maximization (EM) algorithm with initial state given by <code class="docutils literal notranslate"><span class="pre">state</span></code>.</td>
</tr>
</tbody>
</table>
</div>
</div>
<div class="section" id="large-scale-descriptors">
<h2>Large-scale descriptors<a class="headerlink" href="inference.html#large-scale-descriptors" title="Permalink to this headline">¶</a></h2>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="inference.html#graph_tool.inference.modularity.modularity" title="graph_tool.inference.modularity.modularity"><code class="xref py py-obj docutils literal notranslate"><span class="pre">modularity</span></code></a></td>
<td>Calculate Newman’s modularity of a network partition.</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="contents">
<h2>Contents<a class="headerlink" href="inference.html#contents" title="Permalink to this headline">¶</a></h2>
</div>
</div>
<span class="target" id="module-graph_tool.inference.blockmodel"></span><dl class="class">
<dt id="graph_tool.inference.blockmodel.PartitionHist">
<em class="property">class </em><code class="descclassname">graph_tool.inference.blockmodel.</code><code class="descname">PartitionHist</code><a class="headerlink" href="inference.html#graph_tool.inference.blockmodel.PartitionHist" title="Permalink to this definition">¶</a></dt>
<dd><p>Histogram of partitions, implemented in C++.
Interface supports querying and setting using Vector_int32_t as keys, and ints as values.</p>
<dl class="method">
<dt id="graph_tool.inference.blockmodel.PartitionHist.asdict">
<code class="descname">asdict</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="inference.html#graph_tool.inference.blockmodel.PartitionHist.asdict" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the histogram’s contents as a dict.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="graph_tool.inference.blockmodel.BlockPairHist">
<em class="property">class </em><code class="descclassname">graph_tool.inference.blockmodel.</code><code class="descname">BlockPairHist</code><a class="headerlink" href="inference.html#graph_tool.inference.blockmodel.BlockPairHist" title="Permalink to this definition">¶</a></dt>
<dd><p>Histogram of block pairs, implemented in C++.
Interface supports querying and setting using pairs of ints as keys, and ints as values.</p>
<dl class="method">
<dt id="graph_tool.inference.blockmodel.BlockPairHist.asdict">
<code class="descname">asdict</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="inference.html#graph_tool.inference.blockmodel.BlockPairHist.asdict" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the histogram’s contents as a dict.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="graph_tool.inference.blockmodel.BlockState">
<em class="property">class </em><code class="descclassname">graph_tool.inference.blockmodel.</code><code class="descname">BlockState</code><span class="sig-paren">(</span><em>g</em>, <em>b=None</em>, <em>B=None</em>, <em>eweight=None</em>, <em>vweight=None</em>, <em>recs=[]</em>, <em>rec_types=[]</em>, <em>rec_params=[]</em>, <em>clabel=None</em>, <em>pclabel=None</em>, <em>bfield=None</em>, <em>deg_corr=True</em>, <em>allow_empty=False</em>, <em>max_BE=1000</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="http://graph-tool.skewed.de/static/doc/_modules/graph_tool/inference/blockmodel.html#BlockState"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="inference.html#graph_tool.inference.blockmodel.BlockState" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference external" href="https://docs.python.org/3/library/functions.html#object" title="(in Python v3.7)"><code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></a></p>
<p>The stochastic block model state of a given graph.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>g</strong> : <a class="reference internal" href="graph_tool.html#graph_tool.Graph" title="graph_tool.Graph"><code class="xref py py-class docutils literal notranslate"><span class="pre">Graph</span></code></a></p>
<blockquote>
<div><p>Graph to be modelled.</p>
</div></blockquote>
<p><strong>b</strong> : <a class="reference internal" href="graph_tool.html#graph_tool.PropertyMap" title="graph_tool.PropertyMap"><code class="xref py py-class docutils literal notranslate"><span class="pre">PropertyMap</span></code></a> (optional, default: <code class="docutils literal notranslate"><span class="pre">None</span></code>)</p>
<blockquote>
<div><p>Initial block labels on the vertices. If not supplied, it will be
randomly sampled.</p>
</div></blockquote>
<p><strong>B</strong> : <code class="docutils literal notranslate"><span class="pre">int</span></code> (optional, default: <code class="docutils literal notranslate"><span class="pre">None</span></code>)</p>
<blockquote>
<div><p>Number of blocks (or vertex groups). If not supplied it will be obtained
from the parameter <code class="docutils literal notranslate"><span class="pre">b</span></code>.</p>
</div></blockquote>
<p><strong>eweight</strong> : <a class="reference internal" href="graph_tool.html#graph_tool.PropertyMap" title="graph_tool.PropertyMap"><code class="xref py py-class docutils literal notranslate"><span class="pre">PropertyMap</span></code></a> (optional, default: <code class="docutils literal notranslate"><span class="pre">None</span></code>)</p>
<blockquote>
<div><p>Edge multiplicities (for multigraphs or block graphs).</p>
</div></blockquote>
<p><strong>vweight</strong> : <a class="reference internal" href="graph_tool.html#graph_tool.PropertyMap" title="graph_tool.PropertyMap"><code class="xref py py-class docutils literal notranslate"><span class="pre">PropertyMap</span></code></a> (optional, default: <code class="docutils literal notranslate"><span class="pre">None</span></code>)</p>
<blockquote>
<div><p>Vertex multiplicities (for block graphs).</p>
</div></blockquote>
<p><strong>recs</strong> : list of <a class="reference internal" href="graph_tool.html#graph_tool.PropertyMap" title="graph_tool.PropertyMap"><code class="xref py py-class docutils literal notranslate"><span class="pre">PropertyMap</span></code></a> instances (optional, default: <code class="docutils literal notranslate"><span class="pre">[]</span></code>)</p>
<blockquote>
<div><p>List of real or discrete-valued edge covariates.</p>
</div></blockquote>
<p><strong>rec_types</strong> : list of edge covariate types (optional, default: <code class="docutils literal notranslate"><span class="pre">[]</span></code>)</p>
<blockquote>
<div><p>List of types of edge covariates. The possible types are:
<code class="docutils literal notranslate"><span class="pre">&quot;real-exponential&quot;</span></code>, <code class="docutils literal notranslate"><span class="pre">&quot;real-normal&quot;</span></code>, <code class="docutils literal notranslate"><span class="pre">&quot;discrete-geometric&quot;</span></code>,
<code class="docutils literal notranslate"><span class="pre">&quot;discrete-poisson&quot;</span></code> or <code class="docutils literal notranslate"><span class="pre">&quot;discrete-binomial&quot;</span></code>.</p>
</div></blockquote>
<p><strong>rec_params</strong> : list of <code class="docutils literal notranslate"><span class="pre">dict</span></code> (optional, default: <code class="docutils literal notranslate"><span class="pre">[]</span></code>)</p>
<blockquote>
<div><p>Model hyperparameters for edge covariates. This should be a list of
<code class="docutils literal notranslate"><span class="pre">dict</span></code> instances, or the string <cite>“microcanonical”</cite> (the default if
nothing is specified). The keys depend on the type of edge covariate:</p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">&quot;real-exponential&quot;</span></code> or <code class="docutils literal notranslate"><span class="pre">&quot;discrete-poisson&quot;</span></code></dt>
<dd><p class="first last">The parameter list is <code class="docutils literal notranslate"><span class="pre">[&quot;r&quot;,</span> <span class="pre">&quot;theta&quot;]</span></code>, corresponding to the
parameters of the <a class="reference external" href="https://en.wikipedia.org/wiki/Gamma_distribution">Gamma</a> prior
distribution.  If unspecified, the default is the “empirical Bayes”
choice: <code class="docutils literal notranslate"><span class="pre">r</span> <span class="pre">=</span> <span class="pre">1.0</span></code> and <code class="docutils literal notranslate"><span class="pre">theta</span></code> is the global average of the edge
covariate.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">&quot;discrete-geometric&quot;</span></code></dt>
<dd><p class="first last">The parameter list is <code class="docutils literal notranslate"><span class="pre">[&quot;alpha&quot;,</span> <span class="pre">&quot;beta&quot;]</span></code>, corresponding to the
parameters of the <a class="reference external" href="https://en.wikipedia.org/wiki/Beta_distribution">Beta</a> prior
distribution. If unspecified, the default is the noninformative
choice: <code class="docutils literal notranslate"><span class="pre">alpha</span> <span class="pre">=</span> <span class="pre">beta</span> <span class="pre">=</span> <span class="pre">1.0</span></code></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">&quot;discrete-binomial&quot;</span></code></dt>
<dd><p class="first last">The parameter list is <code class="docutils literal notranslate"><span class="pre">[&quot;N&quot;,</span> <span class="pre">&quot;alpha&quot;,</span> <span class="pre">&quot;beta&quot;]</span></code>, corresponding to
the number of trials <code class="docutils literal notranslate"><span class="pre">N</span></code> and the parameters of the <a class="reference external" href="https://en.wikipedia.org/wiki/Beta_distribution">Beta</a> prior
distribution. If unspecified, the default is the noninformative
choice, <code class="docutils literal notranslate"><span class="pre">alpha</span> <span class="pre">=</span> <span class="pre">beta</span> <span class="pre">=</span> <span class="pre">1.0</span></code>, and <code class="docutils literal notranslate"><span class="pre">N</span></code> is taken to be the maximum
edge covarite value.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">&quot;real-normal&quot;</span></code></dt>
<dd><p class="first last">The parameter list is <code class="docutils literal notranslate"><span class="pre">[&quot;m0&quot;,</span> <span class="pre">&quot;k0&quot;,</span> <span class="pre">&quot;v0&quot;,</span> <span class="pre">&quot;nu0&quot;]</span></code> corresponding to
the <a class="reference external" href="https://en.wikipedia.org/wiki/Normal_distribution">normal</a>-<a class="reference external" href="https://en.wikipedia.org/wiki/Inverse-chi-squared_distribution">inverse-chi-squared</a>
prior. If unspecified, the defaults are: <code class="docutils literal notranslate"><span class="pre">m0</span> <span class="pre">=</span> <span class="pre">rec.fa.mean()</span></code>,
<code class="docutils literal notranslate"><span class="pre">k0</span> <span class="pre">=</span> <span class="pre">1</span></code>, <code class="docutils literal notranslate"><span class="pre">v0</span> <span class="pre">=</span> <span class="pre">rec.fa.std()</span> <span class="pre">**</span> <span class="pre">2</span></code>, and <code class="docutils literal notranslate"><span class="pre">nu0</span> <span class="pre">=</span> <span class="pre">3</span></code>, where
<code class="docutils literal notranslate"><span class="pre">rec</span></code> is the corresponding edge covariate property map.</p>
</dd>
</dl>
</div></blockquote>
<p><strong>clabel</strong> : <a class="reference internal" href="graph_tool.html#graph_tool.PropertyMap" title="graph_tool.PropertyMap"><code class="xref py py-class docutils literal notranslate"><span class="pre">PropertyMap</span></code></a> (optional, default: <code class="docutils literal notranslate"><span class="pre">None</span></code>)</p>
<blockquote>
<div><p>Constraint labels on the vertices. If supplied, vertices with different
label values will not be clustered in the same group.</p>
</div></blockquote>
<p><strong>pclabel</strong> : <a class="reference internal" href="graph_tool.html#graph_tool.PropertyMap" title="graph_tool.PropertyMap"><code class="xref py py-class docutils literal notranslate"><span class="pre">PropertyMap</span></code></a> (optional, default: <code class="docutils literal notranslate"><span class="pre">None</span></code>)</p>
<blockquote>
<div><p>Partition constraint labels on the vertices. This has the same
interpretation as <code class="docutils literal notranslate"><span class="pre">clabel</span></code>, but will be used to compute the partition
description length.</p>
</div></blockquote>
<p><strong>bfield</strong> : <a class="reference internal" href="graph_tool.html#graph_tool.PropertyMap" title="graph_tool.PropertyMap"><code class="xref py py-class docutils literal notranslate"><span class="pre">PropertyMap</span></code></a> (optional, default: <code class="docutils literal notranslate"><span class="pre">None</span></code>)</p>
<blockquote>
<div><p>Local field acting as a prior for the node partition. This should be a
vector property map of type <code class="docutils literal notranslate"><span class="pre">vector&lt;double&gt;</span></code>, and contain the
log-probability for each node to be placed in each group.</p>
</div></blockquote>
<p><strong>deg_corr</strong> : <code class="docutils literal notranslate"><span class="pre">bool</span></code> (optional, default: <code class="docutils literal notranslate"><span class="pre">True</span></code>)</p>
<blockquote>
<div><p>If <code class="docutils literal notranslate"><span class="pre">True</span></code>, the degree-corrected version of the blockmodel ensemble will
be assumed, otherwise the traditional variant will be used.</p>
</div></blockquote>
<p><strong>allow_empty</strong> : <code class="docutils literal notranslate"><span class="pre">bool</span></code> (optional, default: <code class="docutils literal notranslate"><span class="pre">False</span></code>)</p>
<blockquote>
<div><p>If <code class="docutils literal notranslate"><span class="pre">True</span></code>, partition description length computed will allow for empty
groups.</p>
</div></blockquote>
<p><strong>max_BE</strong> : <code class="docutils literal notranslate"><span class="pre">int</span></code> (optional, default: <code class="docutils literal notranslate"><span class="pre">1000</span></code>)</p>
<blockquote class="last">
<div><p>If the number of blocks exceeds this value, a sparse matrix is used for
the block graph. Otherwise a dense matrix will be used.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="graph_tool.inference.blockmodel.BlockState.get_rec_params">
<code class="descname">get_rec_params</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="http://graph-tool.skewed.de/static/doc/_modules/graph_tool/inference/blockmodel.html#BlockState.get_rec_params"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="inference.html#graph_tool.inference.blockmodel.BlockState.get_rec_params" title="Permalink to this definition">¶</a></dt>
<dd><p>Get model hyperparameters for edge covariates.</p>
</dd></dl>

<dl class="method">
<dt id="graph_tool.inference.blockmodel.BlockState.set_rec_params">
<code class="descname">set_rec_params</code><span class="sig-paren">(</span><em>params</em><span class="sig-paren">)</span><a class="reference internal" href="http://graph-tool.skewed.de/static/doc/_modules/graph_tool/inference/blockmodel.html#BlockState.set_rec_params"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="inference.html#graph_tool.inference.blockmodel.BlockState.set_rec_params" title="Permalink to this definition">¶</a></dt>
<dd><p>Update model hyperparameters for edge covariates.</p>
</dd></dl>

<dl class="method">
<dt id="graph_tool.inference.blockmodel.BlockState.copy">
<code class="descname">copy</code><span class="sig-paren">(</span><em>g=None</em>, <em>eweight=None</em>, <em>vweight=None</em>, <em>b=None</em>, <em>B=None</em>, <em>deg_corr=None</em>, <em>clabel=None</em>, <em>overlap=False</em>, <em>pclabel=None</em>, <em>bfield=None</em>, <em>max_BE=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="http://graph-tool.skewed.de/static/doc/_modules/graph_tool/inference/blockmodel.html#BlockState.copy"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="inference.html#graph_tool.inference.blockmodel.BlockState.copy" title="Permalink to this definition">¶</a></dt>
<dd><p>Copies the block state. The parameters override the state properties, and
have the same meaning as in the constructor.</p>
</dd></dl>

<dl class="method">
<dt id="graph_tool.inference.blockmodel.BlockState.get_block_state">
<code class="descname">get_block_state</code><span class="sig-paren">(</span><em>b=None</em>, <em>vweight=False</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="http://graph-tool.skewed.de/static/doc/_modules/graph_tool/inference/blockmodel.html#BlockState.get_block_state"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="inference.html#graph_tool.inference.blockmodel.BlockState.get_block_state" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a <a class="reference internal" href="inference.html#graph_tool.inference.blockmodel.BlockState" title="graph_tool.inference.blockmodel.BlockState"><code class="xref py py-class docutils literal notranslate"><span class="pre">BlockState</span></code></a> corresponding
to the block graph (i.e. the blocks of the current state become the
nodes). The parameters have the same meaning as the in the
constructor. If <code class="docutils literal notranslate"><span class="pre">vweight</span> <span class="pre">==</span> <span class="pre">True</span></code> the nodes of the block state are
weighted with the node counts.</p>
</dd></dl>

<dl class="method">
<dt id="graph_tool.inference.blockmodel.BlockState.get_E">
<code class="descname">get_E</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="http://graph-tool.skewed.de/static/doc/_modules/graph_tool/inference/blockmodel.html#BlockState.get_E"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="inference.html#graph_tool.inference.blockmodel.BlockState.get_E" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the total number of edges.</p>
</dd></dl>

<dl class="method">
<dt id="graph_tool.inference.blockmodel.BlockState.get_N">
<code class="descname">get_N</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="http://graph-tool.skewed.de/static/doc/_modules/graph_tool/inference/blockmodel.html#BlockState.get_N"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="inference.html#graph_tool.inference.blockmodel.BlockState.get_N" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the total number of nodes.</p>
</dd></dl>

<dl class="method">
<dt id="graph_tool.inference.blockmodel.BlockState.get_B">
<code class="descname">get_B</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="http://graph-tool.skewed.de/static/doc/_modules/graph_tool/inference/blockmodel.html#BlockState.get_B"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="inference.html#graph_tool.inference.blockmodel.BlockState.get_B" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the total number of blocks.</p>
</dd></dl>

<dl class="method">
<dt id="graph_tool.inference.blockmodel.BlockState.get_nonempty_B">
<code class="descname">get_nonempty_B</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="http://graph-tool.skewed.de/static/doc/_modules/graph_tool/inference/blockmodel.html#BlockState.get_nonempty_B"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="inference.html#graph_tool.inference.blockmodel.BlockState.get_nonempty_B" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the total number of nonempty blocks.</p>
</dd></dl>

<dl class="method">
<dt id="graph_tool.inference.blockmodel.BlockState.get_bclabel">
<code class="descname">get_bclabel</code><span class="sig-paren">(</span><em>clabel=None</em><span class="sig-paren">)</span><a class="reference internal" href="http://graph-tool.skewed.de/static/doc/_modules/graph_tool/inference/blockmodel.html#BlockState.get_bclabel"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="inference.html#graph_tool.inference.blockmodel.BlockState.get_bclabel" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a <a class="reference internal" href="graph_tool.html#graph_tool.PropertyMap" title="graph_tool.PropertyMap"><code class="xref py py-class docutils literal notranslate"><span class="pre">PropertyMap</span></code></a> corresponding to constraint
labels for the block graph.</p>
</dd></dl>

<dl class="method">
<dt id="graph_tool.inference.blockmodel.BlockState.get_bpclabel">
<code class="descname">get_bpclabel</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="http://graph-tool.skewed.de/static/doc/_modules/graph_tool/inference/blockmodel.html#BlockState.get_bpclabel"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="inference.html#graph_tool.inference.blockmodel.BlockState.get_bpclabel" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a <a class="reference internal" href="graph_tool.html#graph_tool.PropertyMap" title="graph_tool.PropertyMap"><code class="xref py py-class docutils literal notranslate"><span class="pre">PropertyMap</span></code></a> corresponding to partition
constraint labels for the block graph.</p>
</dd></dl>

<dl class="method">
<dt id="graph_tool.inference.blockmodel.BlockState.get_blocks">
<code class="descname">get_blocks</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="http://graph-tool.skewed.de/static/doc/_modules/graph_tool/inference/blockmodel.html#BlockState.get_blocks"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="inference.html#graph_tool.inference.blockmodel.BlockState.get_blocks" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the property map which contains the block labels for each vertex.</p>
</dd></dl>

<dl class="method">
<dt id="graph_tool.inference.blockmodel.BlockState.set_blocks">
<code class="descname">set_blocks</code><span class="sig-paren">(</span><em>b</em><span class="sig-paren">)</span><a class="reference internal" href="http://graph-tool.skewed.de/static/doc/_modules/graph_tool/inference/blockmodel.html#BlockState.set_blocks"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="inference.html#graph_tool.inference.blockmodel.BlockState.set_blocks" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets the internal partition of the state.</p>
</dd></dl>

<dl class="method">
<dt id="graph_tool.inference.blockmodel.BlockState.get_bg">
<code class="descname">get_bg</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="http://graph-tool.skewed.de/static/doc/_modules/graph_tool/inference/blockmodel.html#BlockState.get_bg"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="inference.html#graph_tool.inference.blockmodel.BlockState.get_bg" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the block graph.</p>
</dd></dl>

<dl class="method">
<dt id="graph_tool.inference.blockmodel.BlockState.get_ers">
<code class="descname">get_ers</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="http://graph-tool.skewed.de/static/doc/_modules/graph_tool/inference/blockmodel.html#BlockState.get_ers"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="inference.html#graph_tool.inference.blockmodel.BlockState.get_ers" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the edge property map of the block graph which contains the
<span class="math">\(e_{rs}\)</span> matrix entries.  For undirected graphs, the diagonal
values (self-loops) contain <span class="math">\(e_{rr}/2\)</span>.</p>
</dd></dl>

<dl class="method">
<dt id="graph_tool.inference.blockmodel.BlockState.get_er">
<code class="descname">get_er</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="http://graph-tool.skewed.de/static/doc/_modules/graph_tool/inference/blockmodel.html#BlockState.get_er"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="inference.html#graph_tool.inference.blockmodel.BlockState.get_er" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the vertex property map of the block graph which contains the number
<span class="math">\(e_r\)</span> of half-edges incident on block <span class="math">\(r\)</span>. If the graph is
directed, a pair of property maps is returned, with the number of
out-edges <span class="math">\(e^+_r\)</span> and in-edges <span class="math">\(e^-_r\)</span>, respectively.</p>
</dd></dl>

<dl class="method">
<dt id="graph_tool.inference.blockmodel.BlockState.get_nr">
<code class="descname">get_nr</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="http://graph-tool.skewed.de/static/doc/_modules/graph_tool/inference/blockmodel.html#BlockState.get_nr"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="inference.html#graph_tool.inference.blockmodel.BlockState.get_nr" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the vertex property map of the block graph which contains the block
sizes <span class="math">\(n_r\)</span>.</p>
</dd></dl>

<dl class="method">
<dt id="graph_tool.inference.blockmodel.BlockState.entropy">
<code class="descname">entropy</code><span class="sig-paren">(</span><em>adjacency=True</em>, <em>dl=True</em>, <em>partition_dl=True</em>, <em>degree_dl=True</em>, <em>degree_dl_kind='distributed'</em>, <em>edges_dl=True</em>, <em>dense=False</em>, <em>multigraph=True</em>, <em>deg_entropy=True</em>, <em>recs=True</em>, <em>recs_dl=True</em>, <em>beta_dl=1.0</em>, <em>exact=True</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="http://graph-tool.skewed.de/static/doc/_modules/graph_tool/inference/blockmodel.html#BlockState.entropy"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="inference.html#graph_tool.inference.blockmodel.BlockState.entropy" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the entropy (a.k.a. negative log-likelihood) associated
with the current block partition.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>adjacency</strong> : <code class="docutils literal notranslate"><span class="pre">bool</span></code> (optional, default: <code class="docutils literal notranslate"><span class="pre">True</span></code>)</p>
<blockquote>
<div><p>If <code class="docutils literal notranslate"><span class="pre">True</span></code>, the adjacency term of the description length will be
included.</p>
</div></blockquote>
<p><strong>dl</strong> : <code class="docutils literal notranslate"><span class="pre">bool</span></code> (optional, default: <code class="docutils literal notranslate"><span class="pre">True</span></code>)</p>
<blockquote>
<div><p>If <code class="docutils literal notranslate"><span class="pre">True</span></code>, the description length for the parameters will be
included.</p>
</div></blockquote>
<p><strong>partition_dl</strong> : <code class="docutils literal notranslate"><span class="pre">bool</span></code> (optional, default: <code class="docutils literal notranslate"><span class="pre">True</span></code>)</p>
<blockquote>
<div><p>If <code class="docutils literal notranslate"><span class="pre">True</span></code>, and <code class="docutils literal notranslate"><span class="pre">dl</span> <span class="pre">==</span> <span class="pre">True</span></code> the partition description length
will be included.</p>
</div></blockquote>
<p><strong>degree_dl</strong> : <code class="docutils literal notranslate"><span class="pre">bool</span></code> (optional, default: <code class="docutils literal notranslate"><span class="pre">True</span></code>)</p>
<blockquote>
<div><p>If <code class="docutils literal notranslate"><span class="pre">True</span></code>, and <code class="docutils literal notranslate"><span class="pre">dl</span> <span class="pre">==</span> <span class="pre">True</span></code> the degree sequence description
length will be included (for degree-corrected models).</p>
</div></blockquote>
<p><strong>degree_dl_kind</strong> : <code class="docutils literal notranslate"><span class="pre">str</span></code> (optional, default: <code class="docutils literal notranslate"><span class="pre">&quot;distributed&quot;</span></code>)</p>
<blockquote>
<div><p>This specifies the prior used for the degree sequence. It must be
one of: <code class="docutils literal notranslate"><span class="pre">&quot;uniform&quot;</span></code>, <code class="docutils literal notranslate"><span class="pre">&quot;distributed&quot;</span></code> (default) or <code class="docutils literal notranslate"><span class="pre">&quot;entropy&quot;</span></code>.</p>
</div></blockquote>
<p><strong>edges_dl</strong> : <code class="docutils literal notranslate"><span class="pre">bool</span></code> (optional, default: <code class="docutils literal notranslate"><span class="pre">True</span></code>)</p>
<blockquote>
<div><p>If <code class="docutils literal notranslate"><span class="pre">True</span></code>, and <code class="docutils literal notranslate"><span class="pre">dl</span> <span class="pre">==</span> <span class="pre">True</span></code> the edge matrix description length
will be included.</p>
</div></blockquote>
<p><strong>dense</strong> : <code class="docutils literal notranslate"><span class="pre">bool</span></code> (optional, default: <code class="docutils literal notranslate"><span class="pre">False</span></code>)</p>
<blockquote>
<div><p>If <code class="docutils literal notranslate"><span class="pre">True</span></code>, the “dense” variant of the entropy will be computed.</p>
</div></blockquote>
<p><strong>multigraph</strong> : <code class="docutils literal notranslate"><span class="pre">bool</span></code> (optional, default: <code class="docutils literal notranslate"><span class="pre">True</span></code>)</p>
<blockquote>
<div><p>If <code class="docutils literal notranslate"><span class="pre">True</span></code>, the multigraph entropy will be used.</p>
</div></blockquote>
<p><strong>deg_entropy</strong> : <code class="docutils literal notranslate"><span class="pre">bool</span></code> (optional, default: <code class="docutils literal notranslate"><span class="pre">True</span></code>)</p>
<blockquote>
<div><p>If <code class="docutils literal notranslate"><span class="pre">True</span></code>, the degree entropy term that is independent of the
network partition will be included (for degree-corrected models).</p>
</div></blockquote>
<p><strong>recs</strong> : <code class="docutils literal notranslate"><span class="pre">bool</span></code> (optional, default: <code class="docutils literal notranslate"><span class="pre">True</span></code>)</p>
<blockquote>
<div><p>If <code class="docutils literal notranslate"><span class="pre">True</span></code>, the likelihood for real or discrete-valued edge
covariates is computed.</p>
</div></blockquote>
<p><strong>recs_dl</strong> : <code class="docutils literal notranslate"><span class="pre">bool</span></code> (optional, default: <code class="docutils literal notranslate"><span class="pre">True</span></code>)</p>
<blockquote>
<div><p>If <code class="docutils literal notranslate"><span class="pre">True</span></code>, and <code class="docutils literal notranslate"><span class="pre">dl</span> <span class="pre">==</span> <span class="pre">True</span></code> the edge covariate description
length will be included.</p>
</div></blockquote>
<p><strong>beta_dl</strong> : <code class="docutils literal notranslate"><span class="pre">double</span></code> (optional, default: <code class="docutils literal notranslate"><span class="pre">1.</span></code>)</p>
<blockquote>
<div><p>Prior inverse temperature.</p>
</div></blockquote>
<p><strong>exact</strong> : <code class="docutils literal notranslate"><span class="pre">bool</span></code> (optional, default: <code class="docutils literal notranslate"><span class="pre">True</span></code>)</p>
<blockquote class="last">
<div><p>If <code class="docutils literal notranslate"><span class="pre">True</span></code>, the exact expressions will be used. Otherwise,
Stirling’s factorial approximation will be used for some terms.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>The “entropy” of the state is the negative log-likelihood of the
microcanonical SBM, that includes the generated graph
<span class="math">\(\boldsymbol{A}\)</span> and the model parameters
<span class="math">\(\boldsymbol{\theta}\)</span>,</p>
<div class="math">
\[\begin{split}\Sigma &amp;= - \ln P(\boldsymbol{A},\boldsymbol{\theta}) \\
       &amp;= - \ln P(\boldsymbol{A}|\boldsymbol{\theta}) - \ln P(\boldsymbol{\theta}).\end{split}\]</div>
<p>This value is also called the <a class="reference external" href="https://en.wikipedia.org/wiki/Minimum_description_length">description length</a> of the data,
and it corresponds to the amount of information required to describe it
(in <a class="reference external" href="https://en.wikipedia.org/wiki/Nat_(unit)">nats</a>).</p>
<p>For the traditional blockmodel (<code class="docutils literal notranslate"><span class="pre">deg_corr</span> <span class="pre">==</span> <span class="pre">False</span></code>), the model
parameters are <span class="math">\(\boldsymbol{\theta} = \{\boldsymbol{e},
\boldsymbol{b}\}\)</span>, where <span class="math">\(\boldsymbol{e}\)</span> is the matrix of edge
counts between blocks, and <span class="math">\(\boldsymbol{b}\)</span> is the partition of the
nodes into blocks. For the degree-corrected blockmodel (<code class="docutils literal notranslate"><span class="pre">deg_corr</span> <span class="pre">==</span>
<span class="pre">True</span></code>), we have an additional set of parameters, namely the degree
sequence <span class="math">\(\boldsymbol{k}\)</span>.</p>
<p>For the traditional blockmodel, the model likelihood is</p>
<div class="math">
\[\begin{split}P(\boldsymbol{A}|\boldsymbol{e},\boldsymbol{b}) &amp;= \frac{\prod_{r&lt;s}e_{rs}!\prod_re_{rr}!!}{\prod_rn_r^{e_r}}\times \frac{1}{\prod_{i&lt;j}A_{ij}!\prod_iA_{ii}!!},\\
P(\boldsymbol{A}|\boldsymbol{e},\boldsymbol{b}) &amp;= \frac{\prod_{rs}e_{rs}!}{\prod_rn_r^{e_r}}\times \frac{1}{\prod_{ij}A_{ij}!},\end{split}\]</div>
<p>for undirected and directed graphs, respectively, where <span class="math">\(e_{rs}\)</span>
is the number of edges from block <span class="math">\(r\)</span> to <span class="math">\(s\)</span> (or the number
of half-edges for the undirected case when <span class="math">\(r=s\)</span>), and <span class="math">\(n_r\)</span>
is the number of vertices in block <span class="math">\(r\)</span> .</p>
<p>For the degree-corrected variant the equivalent expressions are</p>
<div class="math">
\[\begin{split}P(\boldsymbol{A}|\boldsymbol{e},\boldsymbol{b},\boldsymbol{k}) &amp;= \frac{\prod_{r&lt;s}e_{rs}!\prod_re_{rr}!!}{\prod_re_r!}\times \frac{\prod_ik_i!}{\prod_{i&lt;j}A_{ij}!\prod_iA_{ii}!!},\\
P(\boldsymbol{A}|\boldsymbol{e},\boldsymbol{b},\boldsymbol{k}) &amp;= \frac{\prod_{rs}e_{rs}!}{\prod_re_r^+!\prod_re_r^-!}\times \frac{\prod_ik_i^+!\prod_ik_i^-!}{\prod_{ij}A_{ij}!},\end{split}\]</div>
<p>where <span class="math">\(e_r = \sum_se_{rs}\)</span> is the number of half-edges incident on
block <span class="math">\(r\)</span>, and <span class="math">\(e^+_r = \sum_se_{rs}\)</span> and <span class="math">\(e^-_r =
\sum_se_{sr}\)</span> are the numbers of out- and in-edges adjacent to block
<span class="math">\(r\)</span>, respectively.</p>
<p>If <code class="docutils literal notranslate"><span class="pre">exact</span> <span class="pre">==</span> <span class="pre">False</span></code>, <a class="reference external" href="https://en.wikipedia.org/wiki/Stirling%27s_approximation">Stirling’s approximation</a> is used in
the above expression.</p>
<p>If <code class="docutils literal notranslate"><span class="pre">dense</span> <span class="pre">==</span> <span class="pre">True</span></code>, the likelihood for the non-degree-corrected model
becomes instead</p>
<div class="math">
\[\begin{split}P(\boldsymbol{A}|\boldsymbol{e},\boldsymbol{b})^{-1} &amp;= \prod_{r&lt;s}{n_rn_s\choose e_{rs}}\prod_r{{n_r\choose 2}\choose e_{rr}/2},\\
P(\boldsymbol{A}|\boldsymbol{e},\boldsymbol{b})^{-1} &amp;= \prod_{rs}{n_rn_s\choose e_{rs}}\end{split}\]</div>
<p>if <code class="docutils literal notranslate"><span class="pre">multigraph</span> <span class="pre">==</span> <span class="pre">False</span></code>, otherwise we replace <span class="math">\({n\choose
m}\to\left(\!\!{n\choose m}\!\!\right)\)</span> above, where
<span class="math">\(\left(\!\!{n\choose m}\!\!\right) = {n+m-1\choose m}\)</span>.  A “dense”
entropy for the degree-corrected model is not available, and if
requested will raise a <a class="reference external" href="https://docs.python.org/3/library/exceptions.html#NotImplementedError" title="(in Python v3.7)"><code class="xref py py-exc docutils literal notranslate"><span class="pre">NotImplementedError</span></code></a>.</p>
<p>If <code class="docutils literal notranslate"><span class="pre">dl</span> <span class="pre">==</span> <span class="pre">True</span></code>, the description length <span class="math">\(\mathcal{L} = -\ln
P(\boldsymbol{\theta})\)</span> of the model will be returned as well. The terms
<span class="math">\(P(\boldsymbol{e})\)</span> and <span class="math">\(P(\boldsymbol{b})\)</span> are described in
described in <a class="reference internal" href="inference.html#graph_tool.inference.blockmodel.model_entropy" title="graph_tool.inference.blockmodel.model_entropy"><code class="xref py py-func docutils literal notranslate"><span class="pre">model_entropy()</span></code></a>.</p>
<p>For the degree-corrected model we need to specify the prior
<span class="math">\(P(\boldsymbol{k})\)</span> for the degree sequence as well. Here there
are three options:</p>
<ol class="arabic">
<li><p class="first"><code class="docutils literal notranslate"><span class="pre">degree_dl_kind</span> <span class="pre">==</span> <span class="pre">&quot;uniform&quot;</span></code></p>
<blockquote>
<div><div class="math">
\[P(\boldsymbol{k}|\boldsymbol{e},\boldsymbol{b}) = \prod_r\left(\!\!{n_r\choose e_r}\!\!\right)^{-1}.\]</div>
<p>This corresponds to a noninformative prior, where the degrees are
sampled from a uniform distribution.</p>
</div></blockquote>
</li>
<li><p class="first"><code class="docutils literal notranslate"><span class="pre">degree_dl_kind</span> <span class="pre">==</span> <span class="pre">&quot;distributed&quot;</span></code> (default)</p>
<blockquote>
<div><div class="math">
\[P(\boldsymbol{k}|\boldsymbol{e},\boldsymbol{b}) = \prod_r\frac{\prod_k\eta_k^r!}{n_r!} \prod_r q(e_r, n_r)^{-1}\]</div>
<p>with <span class="math">\(\eta_k^r\)</span> being the number of nodes with degree
<span class="math">\(k\)</span> in group <span class="math">\(r\)</span>, and <span class="math">\(q(n,m)\)</span> being the number of
<a class="reference external" href="https://en.wikipedia.org/wiki/Partition_(number_theory)">partitions</a> of
integer <span class="math">\(n\)</span> into at most <span class="math">\(m\)</span> parts.</p>
<p>This corresponds to a prior for the degree sequence conditioned on
the degree frequencies, which are themselves sampled from a uniform
hyperprior. This option should be preferred in most cases.</p>
</div></blockquote>
</li>
<li><p class="first"><code class="docutils literal notranslate"><span class="pre">degree_dl_kind</span> <span class="pre">==</span> <span class="pre">&quot;entropy&quot;</span></code></p>
<blockquote>
<div><div class="math">
\[P(\boldsymbol{k}|\boldsymbol{e},\boldsymbol{b}) \approx \prod_r\exp\left(-n_rH(\boldsymbol{k}_r)\right)\]</div>
<p>where <span class="math">\(H(\boldsymbol{k}_r) = -\sum_kp_r(k)\ln p_r(k)\)</span> is the
entropy of the degree distribution inside block <span class="math">\(r\)</span>.</p>
<p>Note that, differently from the other two choices, this represents
only an approximation of the description length. It is meant to be
used only for comparison purposes, and should be avoided in practice.</p>
</div></blockquote>
</li>
</ol>
<p>For the directed case, the above expressions are duplicated for the in-
and out-degrees.</p>
<p class="rubric">References</p>
<table class="docutils citation" frame="void" id="peixoto-nonparametric-2017175" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="inference.html#id4">[peixoto-nonparametric-2017175]</a></td><td>Tiago P. Peixoto, “Nonparametric
Bayesian inference of the microcanonical stochastic block model”,
Phys. Rev. E 95 012317 (2017), <a class="reference external" href="https://dx.doi.org/10.1103/PhysRevE.95.012317">DOI: 10.1103/PhysRevE.95.012317</a> [<a class="reference external" href="https://sci-hub.tw/10.1103/PhysRevE.95.012317">sci-hub</a>, <a class="reference external" href="https://scihub22266oqcxt.onion.link/10.1103/PhysRevE.95.012317">&#64;tor</a>],
<a class="reference external" href="https://arxiv.org/abs/1610.02703">arXiv: 1610.02703</a></td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="peixoto-hierarchical-2014175" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="inference.html#id5">[peixoto-hierarchical-2014175]</a></td><td>Tiago P. Peixoto, “Hierarchical block
structures and high-resolution model selection in large networks “,
Phys. Rev. X 4, 011047 (2014), <a class="reference external" href="https://dx.doi.org/10.1103/PhysRevX.4.011047">DOI: 10.1103/PhysRevX.4.011047</a> [<a class="reference external" href="https://sci-hub.tw/10.1103/PhysRevX.4.011047">sci-hub</a>, <a class="reference external" href="https://scihub22266oqcxt.onion.link/10.1103/PhysRevX.4.011047">&#64;tor</a>],
<a class="reference external" href="https://arxiv.org/abs/1310.4377">arXiv: 1310.4377</a>.</td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="peixoto-weighted-2017175" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="inference.html#id6">[peixoto-weighted-2017175]</a></td><td>Tiago P. Peixoto, “Nonparametric weighted
stochastic block models”, <a class="reference external" href="https://arxiv.org/abs/1708.01432">arXiv: 1708.01432</a></td></tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="graph_tool.inference.blockmodel.BlockState.get_matrix">
<code class="descname">get_matrix</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="http://graph-tool.skewed.de/static/doc/_modules/graph_tool/inference/blockmodel.html#BlockState.get_matrix"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="inference.html#graph_tool.inference.blockmodel.BlockState.get_matrix" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the block matrix (as a sparse <a class="reference external" href="https://docs.scipy.org/doc/scipy/reference/generated/scipy.sparse.csr_matrix.html#scipy.sparse.csr_matrix" title="(in SciPy v1.1.0)"><code class="xref py py-class docutils literal notranslate"><span class="pre">csr_matrix</span></code></a>),
which contains the number of edges between each block pair.</p>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">This corresponds to the adjacency matrix of the block graph, which by
convention includes twice the amount of edges in the diagonal entries
if the graph is undirected.</p>
</div>
<p class="rubric">Examples</p>
<div class="highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">g</span> <span class="o">=</span> <span class="n">gt</span><span class="o">.</span><span class="n">collection</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;polbooks&quot;</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">state</span> <span class="o">=</span> <span class="n">gt</span><span class="o">.</span><span class="n">BlockState</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">B</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">deg_corr</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">state</span><span class="o">.</span><span class="n">mcmc_sweep</span><span class="p">(</span><span class="n">niter</span><span class="o">=</span><span class="mi">1000</span><span class="p">)</span>
<span class="go">(...)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span> <span class="o">=</span> <span class="n">state</span><span class="o">.</span><span class="n">get_matrix</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">figure</span><span class="p">()</span>
<span class="go">&lt;...&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">matshow</span><span class="p">(</span><span class="n">m</span><span class="o">.</span><span class="n">todense</span><span class="p">())</span>
<span class="go">&lt;...&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">savefig</span><span class="p">(</span><span class="s2">&quot;bloc_mat.pdf&quot;</span><span class="p">)</span>
</pre></div>
</div>
<div class="figure align-center" id="id51">
<img alt="_images/bloc_mat.png" src="_images/bloc_mat.png" />
<p class="caption"><span class="caption-text">A  5x5 block matrix.</span></p>
</div>
</dd></dl>

<dl class="method">
<dt id="graph_tool.inference.blockmodel.BlockState.virtual_vertex_move">
<code class="descname">virtual_vertex_move</code><span class="sig-paren">(</span><em>v</em>, <em>s</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="http://graph-tool.skewed.de/static/doc/_modules/graph_tool/inference/blockmodel.html#BlockState.virtual_vertex_move"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="inference.html#graph_tool.inference.blockmodel.BlockState.virtual_vertex_move" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes the entropy difference if vertex <code class="docutils literal notranslate"><span class="pre">v</span></code> is moved to block <code class="docutils literal notranslate"><span class="pre">s</span></code>. The
remaining parameters are the same as in
<a class="reference internal" href="inference.html#graph_tool.inference.blockmodel.BlockState.entropy" title="graph_tool.inference.blockmodel.BlockState.entropy"><code class="xref py py-meth docutils literal notranslate"><span class="pre">graph_tool.inference.blockmodel.BlockState.entropy()</span></code></a>.</p>
</dd></dl>

<dl class="method">
<dt id="graph_tool.inference.blockmodel.BlockState.move_vertex">
<code class="descname">move_vertex</code><span class="sig-paren">(</span><em>v</em>, <em>s</em><span class="sig-paren">)</span><a class="reference internal" href="http://graph-tool.skewed.de/static/doc/_modules/graph_tool/inference/blockmodel.html#BlockState.move_vertex"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="inference.html#graph_tool.inference.blockmodel.BlockState.move_vertex" title="Permalink to this definition">¶</a></dt>
<dd><p>Move vertex <code class="docutils literal notranslate"><span class="pre">v</span></code> to block <code class="docutils literal notranslate"><span class="pre">s</span></code>.</p>
<p>This optionally accepts a list of vertices and blocks to move
simultaneously.</p>
</dd></dl>

<dl class="method">
<dt id="graph_tool.inference.blockmodel.BlockState.remove_vertex">
<code class="descname">remove_vertex</code><span class="sig-paren">(</span><em>v</em><span class="sig-paren">)</span><a class="reference internal" href="http://graph-tool.skewed.de/static/doc/_modules/graph_tool/inference/blockmodel.html#BlockState.remove_vertex"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="inference.html#graph_tool.inference.blockmodel.BlockState.remove_vertex" title="Permalink to this definition">¶</a></dt>
<dd><p>Remove vertex <code class="docutils literal notranslate"><span class="pre">v</span></code> from its current group.</p>
<p>This optionally accepts a list of vertices to remove.</p>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">This will leave the state in an inconsistent state before the vertex
is returned to some other group, or if the same vertex is removed
twice.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="graph_tool.inference.blockmodel.BlockState.add_vertex">
<code class="descname">add_vertex</code><span class="sig-paren">(</span><em>v</em>, <em>r</em><span class="sig-paren">)</span><a class="reference internal" href="http://graph-tool.skewed.de/static/doc/_modules/graph_tool/inference/blockmodel.html#BlockState.add_vertex"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="inference.html#graph_tool.inference.blockmodel.BlockState.add_vertex" title="Permalink to this definition">¶</a></dt>
<dd><p>Add vertex <code class="docutils literal notranslate"><span class="pre">v</span></code> to block <code class="docutils literal notranslate"><span class="pre">r</span></code>.</p>
<p>This optionally accepts a list of vertices and blocks to add.</p>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">This can leave the state in an inconsistent state if a vertex is
added twice to the same group.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="graph_tool.inference.blockmodel.BlockState.merge_vertices">
<code class="descname">merge_vertices</code><span class="sig-paren">(</span><em>u</em>, <em>v</em><span class="sig-paren">)</span><a class="reference internal" href="http://graph-tool.skewed.de/static/doc/_modules/graph_tool/inference/blockmodel.html#BlockState.merge_vertices"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="inference.html#graph_tool.inference.blockmodel.BlockState.merge_vertices" title="Permalink to this definition">¶</a></dt>
<dd><p>Merge vertex <code class="docutils literal notranslate"><span class="pre">u</span></code> into <code class="docutils literal notranslate"><span class="pre">v</span></code>.</p>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">This modifies the underlying graph.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="graph_tool.inference.blockmodel.BlockState.sample_vertex_move">
<code class="descname">sample_vertex_move</code><span class="sig-paren">(</span><em>v</em>, <em>c=1.0</em>, <em>d=0.1</em><span class="sig-paren">)</span><a class="reference internal" href="http://graph-tool.skewed.de/static/doc/_modules/graph_tool/inference/blockmodel.html#BlockState.sample_vertex_move"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="inference.html#graph_tool.inference.blockmodel.BlockState.sample_vertex_move" title="Permalink to this definition">¶</a></dt>
<dd><p>Sample block membership proposal of vertex <code class="docutils literal notranslate"><span class="pre">v</span></code> according to real-valued
sampling parameters <code class="docutils literal notranslate"><span class="pre">c</span></code> and <code class="docutils literal notranslate"><span class="pre">d</span></code>: For <span class="math">\(c\to 0\)</span> the blocks are sampled
according to the local neighborhood and their connections; for
<span class="math">\(c\to\infty\)</span> the blocks are sampled randomly. With a probability
<code class="docutils literal notranslate"><span class="pre">d</span></code>, a new (empty) group is sampled.</p>
</dd></dl>

<dl class="method">
<dt id="graph_tool.inference.blockmodel.BlockState.get_move_prob">
<code class="descname">get_move_prob</code><span class="sig-paren">(</span><em>v</em>, <em>s</em>, <em>c=1.0</em>, <em>d=0.1</em>, <em>reverse=False</em><span class="sig-paren">)</span><a class="reference internal" href="http://graph-tool.skewed.de/static/doc/_modules/graph_tool/inference/blockmodel.html#BlockState.get_move_prob"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="inference.html#graph_tool.inference.blockmodel.BlockState.get_move_prob" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the probability of a move proposal for vertex <code class="docutils literal notranslate"><span class="pre">v</span></code> to block <code class="docutils literal notranslate"><span class="pre">s</span></code>
according to sampling parameters <code class="docutils literal notranslate"><span class="pre">c</span></code> and <code class="docutils literal notranslate"><span class="pre">d</span></code>, as obtained with
<a class="reference internal" href="inference.html#graph_tool.inference.blockmodel.BlockState.sample_vertex_move" title="graph_tool.inference.blockmodel.BlockState.sample_vertex_move"><code class="xref py py-meth docutils literal notranslate"><span class="pre">graph_tool.inference.blockmodel.BlockState.sample_vertex_move()</span></code></a>. If <code class="docutils literal notranslate"><span class="pre">reverse</span>
<span class="pre">==</span> <span class="pre">True</span></code>, the reverse probability of moving the node back from block
<code class="docutils literal notranslate"><span class="pre">s</span></code> to its current one is obtained.</p>
</dd></dl>

<dl class="method">
<dt id="graph_tool.inference.blockmodel.BlockState.get_edges_prob">
<code class="descname">get_edges_prob</code><span class="sig-paren">(</span><em>missing</em>, <em>spurious=[]</em>, <em>entropy_args={}</em><span class="sig-paren">)</span><a class="reference internal" href="http://graph-tool.skewed.de/static/doc/_modules/graph_tool/inference/blockmodel.html#BlockState.get_edges_prob"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="inference.html#graph_tool.inference.blockmodel.BlockState.get_edges_prob" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the joint log-probability of the missing and spurious edges given by
<code class="docutils literal notranslate"><span class="pre">missing</span></code> and <code class="docutils literal notranslate"><span class="pre">spurious</span></code> (a list of <code class="docutils literal notranslate"><span class="pre">(source,</span> <span class="pre">target)</span></code>
tuples, or <a class="reference internal" href="graph_tool.html#graph_tool.Edge" title="graph_tool.Edge"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Edge()</span></code></a> instances), together with the
observed edges.</p>
<p>More precisely, the log-likelihood returned is</p>
<div class="math">
\[\ln \frac{P(\boldsymbol G + \delta \boldsymbol G | \boldsymbol b)}{P(\boldsymbol G| \boldsymbol b)}\]</div>
<p>where <span class="math">\(\boldsymbol G + \delta \boldsymbol G\)</span> is the modified graph
(with missing edges added and spurious edges deleted).</p>
<p>The values in <code class="docutils literal notranslate"><span class="pre">entropy_args</span></code> are passed to
<a class="reference internal" href="inference.html#graph_tool.inference.blockmodel.BlockState.entropy" title="graph_tool.inference.blockmodel.BlockState.entropy"><code class="xref py py-meth docutils literal notranslate"><span class="pre">entropy()</span></code></a> to
calculate the log-probability.</p>
</dd></dl>

<dl class="method">
<dt id="graph_tool.inference.blockmodel.BlockState.mcmc_sweep">
<code class="descname">mcmc_sweep</code><span class="sig-paren">(</span><em>beta=1.0</em>, <em>c=1.0</em>, <em>d=0.01</em>, <em>niter=1</em>, <em>entropy_args={}</em>, <em>allow_vacate=True</em>, <em>sequential=True</em>, <em>deterministic=False</em>, <em>parallel=False</em>, <em>vertices=None</em>, <em>verbose=False</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="http://graph-tool.skewed.de/static/doc/_modules/graph_tool/inference/blockmodel.html#BlockState.mcmc_sweep"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="inference.html#graph_tool.inference.blockmodel.BlockState.mcmc_sweep" title="Permalink to this definition">¶</a></dt>
<dd><p>Perform <code class="docutils literal notranslate"><span class="pre">niter</span></code> sweeps of a Metropolis-Hastings acceptance-rejection
sampling MCMC to sample network partitions.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>beta</strong> : <code class="docutils literal notranslate"><span class="pre">float</span></code> (optional, default: <code class="docutils literal notranslate"><span class="pre">1.</span></code>)</p>
<blockquote>
<div><p>Inverse temperature.</p>
</div></blockquote>
<p><strong>c</strong> : <code class="docutils literal notranslate"><span class="pre">float</span></code> (optional, default: <code class="docutils literal notranslate"><span class="pre">1.</span></code>)</p>
<blockquote>
<div><p>Sampling parameter <code class="docutils literal notranslate"><span class="pre">c</span></code> for move proposals: For <span class="math">\(c\to 0\)</span> the
blocks are sampled according to the local neighborhood of a given
node and their block connections; for <span class="math">\(c\to\infty\)</span> the blocks
are sampled randomly. Note that only for <span class="math">\(c &gt; 0\)</span> the MCMC is
guaranteed to be ergodic.</p>
</div></blockquote>
<p><strong>d</strong> : <code class="docutils literal notranslate"><span class="pre">float</span></code> (optional, default: <code class="docutils literal notranslate"><span class="pre">.01</span></code>)</p>
<blockquote>
<div><p>Probability of selecting a new (i.e. empty) group for a given move.</p>
</div></blockquote>
<p><strong>niter</strong> : <code class="docutils literal notranslate"><span class="pre">int</span></code> (optional, default: <code class="docutils literal notranslate"><span class="pre">1</span></code>)</p>
<blockquote>
<div><p>Number of sweeps to perform. During each sweep, a move attempt is
made for each node.</p>
</div></blockquote>
<p><strong>entropy_args</strong> : <code class="docutils literal notranslate"><span class="pre">dict</span></code> (optional, default: <code class="docutils literal notranslate"><span class="pre">{}</span></code>)</p>
<blockquote>
<div><p>Entropy arguments, with the same meaning and defaults as in
<a class="reference internal" href="inference.html#graph_tool.inference.blockmodel.BlockState.entropy" title="graph_tool.inference.blockmodel.BlockState.entropy"><code class="xref py py-meth docutils literal notranslate"><span class="pre">graph_tool.inference.blockmodel.BlockState.entropy()</span></code></a>.</p>
</div></blockquote>
<p><strong>allow_vacate</strong> : <code class="docutils literal notranslate"><span class="pre">bool</span></code> (optional, default: <code class="docutils literal notranslate"><span class="pre">True</span></code>)</p>
<blockquote>
<div><p>Allow groups to be vacated.</p>
</div></blockquote>
<p><strong>sequential</strong> : <code class="docutils literal notranslate"><span class="pre">bool</span></code> (optional, default: <code class="docutils literal notranslate"><span class="pre">True</span></code>)</p>
<blockquote>
<div><p>If <code class="docutils literal notranslate"><span class="pre">sequential</span> <span class="pre">==</span> <span class="pre">True</span></code> each vertex move attempt is made
sequentially, where vertices are visited in random order. Otherwise
the moves are attempted by sampling vertices randomly, so that the
same vertex can be moved more than once, before other vertices had
the chance to move.</p>
</div></blockquote>
<p><strong>deterministic</strong> : <code class="docutils literal notranslate"><span class="pre">bool</span></code> (optional, default: <code class="docutils literal notranslate"><span class="pre">False</span></code>)</p>
<blockquote>
<div><p>If <code class="docutils literal notranslate"><span class="pre">sequential</span> <span class="pre">==</span> <span class="pre">True</span></code> and <code class="docutils literal notranslate"><span class="pre">deterministic</span> <span class="pre">==</span> <span class="pre">True</span></code> the
vertices will be visited in deterministic order.</p>
</div></blockquote>
<p><strong>parallel</strong> : <code class="docutils literal notranslate"><span class="pre">bool</span></code> (optional, default: <code class="docutils literal notranslate"><span class="pre">False</span></code>)</p>
<blockquote>
<div><p>If <code class="docutils literal notranslate"><span class="pre">parallel</span> <span class="pre">==</span> <span class="pre">True</span></code>, vertex movements are attempted in parallel.</p>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">If <code class="docutils literal notranslate"><span class="pre">parallel</span> <span class="pre">==</span> <span class="pre">True</span></code>, the asymptotic exactness of the MCMC
sampling is not guaranteed.</p>
</div>
</div></blockquote>
<p><strong>vertices</strong> : <code class="docutils literal notranslate"><span class="pre">list</span></code> of ints (optional, default: <code class="docutils literal notranslate"><span class="pre">None</span></code>)</p>
<blockquote>
<div><p>If provided, this should be a list of vertices which will be
moved. Otherwise, all vertices will.</p>
</div></blockquote>
<p><strong>verbose</strong> : <code class="docutils literal notranslate"><span class="pre">bool</span></code> (optional, default: <code class="docutils literal notranslate"><span class="pre">False</span></code>)</p>
<blockquote>
<div><p>If <code class="docutils literal notranslate"><span class="pre">verbose</span> <span class="pre">==</span> <span class="pre">True</span></code>, detailed information will be displayed.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>dS</strong> : <code class="docutils literal notranslate"><span class="pre">float</span></code></p>
<blockquote>
<div><p>Entropy difference after the sweeps.</p>
</div></blockquote>
<p><strong>nattempts</strong> : <code class="docutils literal notranslate"><span class="pre">int</span></code></p>
<blockquote>
<div><p>Number of vertex moves attempted.</p>
</div></blockquote>
<p><strong>nmoves</strong> : <code class="docutils literal notranslate"><span class="pre">int</span></code></p>
<blockquote class="last">
<div><p>Number of vertices moved.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>This algorithm has an <span class="math">\(O(E)\)</span> complexity, where <span class="math">\(E\)</span> is the
number of edges (independent of the number of blocks).</p>
<p class="rubric">References</p>
<table class="docutils citation" frame="void" id="peixoto-efficient-2014178" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="inference.html#id7">[peixoto-efficient-2014178]</a></td><td>Tiago P. Peixoto, “Efficient Monte Carlo and
greedy heuristic for the inference of stochastic block models”, Phys.
Rev. E 89, 012804 (2014), <a class="reference external" href="https://dx.doi.org/10.1103/PhysRevE.89.012804">DOI: 10.1103/PhysRevE.89.012804</a> [<a class="reference external" href="https://sci-hub.tw/10.1103/PhysRevE.89.012804">sci-hub</a>, <a class="reference external" href="https://scihub22266oqcxt.onion.link/10.1103/PhysRevE.89.012804">&#64;tor</a>],
<a class="reference external" href="https://arxiv.org/abs/1310.4378">arXiv: 1310.4378</a></td></tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="graph_tool.inference.blockmodel.BlockState.multiflip_mcmc_sweep">
<code class="descname">multiflip_mcmc_sweep</code><span class="sig-paren">(</span><em>a1=0.99</em>, <em>an=0.9</em>, <em>beta=1.0</em>, <em>c=1.0</em>, <em>d=0.01</em>, <em>niter=1</em>, <em>entropy_args={}</em>, <em>allow_vacate=True</em>, <em>sequential=True</em>, <em>verbose=False</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="http://graph-tool.skewed.de/static/doc/_modules/graph_tool/inference/blockmodel.html#BlockState.multiflip_mcmc_sweep"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="inference.html#graph_tool.inference.blockmodel.BlockState.multiflip_mcmc_sweep" title="Permalink to this definition">¶</a></dt>
<dd><p>Perform <code class="docutils literal notranslate"><span class="pre">niter</span></code> sweeps of a Metropolis-Hastings acceptance-rejection
sampling MCMC with multiple simultaneous moves to sample network
partitions.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>a1</strong> : <code class="docutils literal notranslate"><span class="pre">float</span></code> (optional, default: <code class="docutils literal notranslate"><span class="pre">.9</span></code>)</p>
<blockquote>
<div><p>Probability of single moves.</p>
</div></blockquote>
<p><strong>an</strong> : <code class="docutils literal notranslate"><span class="pre">float</span></code> (optional, default: <code class="docutils literal notranslate"><span class="pre">.9</span></code>)</p>
<blockquote>
<div><p>Relative probability of group merges. The complementary probability
will correspond to multiple moves within a group.</p>
</div></blockquote>
<p><strong>beta</strong> : <code class="docutils literal notranslate"><span class="pre">float</span></code> (optional, default: <code class="docutils literal notranslate"><span class="pre">1.</span></code>)</p>
<blockquote>
<div><p>Inverse temperature.</p>
</div></blockquote>
<p><strong>c</strong> : <code class="docutils literal notranslate"><span class="pre">float</span></code> (optional, default: <code class="docutils literal notranslate"><span class="pre">1.</span></code>)</p>
<blockquote>
<div><p>Sampling parameter <code class="docutils literal notranslate"><span class="pre">c</span></code> for move proposals: For <span class="math">\(c\to 0\)</span> the
blocks are sampled according to the local neighborhood of a given
node and their block connections; for <span class="math">\(c\to\infty\)</span> the blocks
are sampled randomly. Note that only for <span class="math">\(c &gt; 0\)</span> the MCMC is
guaranteed to be ergodic.</p>
</div></blockquote>
<p><strong>d</strong> : <code class="docutils literal notranslate"><span class="pre">float</span></code> (optional, default: <code class="docutils literal notranslate"><span class="pre">.01</span></code>)</p>
<blockquote>
<div><p>Probability of selecting a new (i.e. empty) group for a given move.</p>
</div></blockquote>
<p><strong>niter</strong> : <code class="docutils literal notranslate"><span class="pre">int</span></code> (optional, default: <code class="docutils literal notranslate"><span class="pre">1</span></code>)</p>
<blockquote>
<div><p>Number of sweeps to perform. During each sweep, a move attempt is
made for each node.</p>
</div></blockquote>
<p><strong>entropy_args</strong> : <code class="docutils literal notranslate"><span class="pre">dict</span></code> (optional, default: <code class="docutils literal notranslate"><span class="pre">{}</span></code>)</p>
<blockquote>
<div><p>Entropy arguments, with the same meaning and defaults as in
<a class="reference internal" href="inference.html#graph_tool.inference.blockmodel.BlockState.entropy" title="graph_tool.inference.blockmodel.BlockState.entropy"><code class="xref py py-meth docutils literal notranslate"><span class="pre">graph_tool.inference.blockmodel.BlockState.entropy()</span></code></a>.</p>
</div></blockquote>
<p><strong>allow_vacate</strong> : <code class="docutils literal notranslate"><span class="pre">bool</span></code> (optional, default: <code class="docutils literal notranslate"><span class="pre">True</span></code>)</p>
<blockquote>
<div><p>Allow groups to be vacated.</p>
</div></blockquote>
<p><strong>verbose</strong> : <code class="docutils literal notranslate"><span class="pre">bool</span></code> (optional, default: <code class="docutils literal notranslate"><span class="pre">False</span></code>)</p>
<blockquote>
<div><p>If <code class="docutils literal notranslate"><span class="pre">verbose</span> <span class="pre">==</span> <span class="pre">True</span></code>, detailed information will be displayed.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>dS</strong> : <code class="docutils literal notranslate"><span class="pre">float</span></code></p>
<blockquote>
<div><p>Entropy difference after the sweeps.</p>
</div></blockquote>
<p><strong>nattempts</strong> : <code class="docutils literal notranslate"><span class="pre">int</span></code></p>
<blockquote>
<div><p>Number of vertex moves attempted.</p>
</div></blockquote>
<p><strong>nmoves</strong> : <code class="docutils literal notranslate"><span class="pre">int</span></code></p>
<blockquote class="last">
<div><p>Number of vertices moved.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>This algorithm has an <span class="math">\(O(E)\)</span> complexity, where <span class="math">\(E\)</span> is the
number of edges (independent of the number of blocks).</p>
</dd></dl>

<dl class="method">
<dt id="graph_tool.inference.blockmodel.BlockState.gibbs_sweep">
<code class="descname">gibbs_sweep</code><span class="sig-paren">(</span><em>beta=1.0</em>, <em>niter=1</em>, <em>entropy_args={}</em>, <em>allow_vacate=True</em>, <em>allow_new_group=True</em>, <em>sequential=True</em>, <em>deterministic=False</em>, <em>parallel=False</em>, <em>vertices=None</em>, <em>verbose=False</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="http://graph-tool.skewed.de/static/doc/_modules/graph_tool/inference/blockmodel.html#BlockState.gibbs_sweep"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="inference.html#graph_tool.inference.blockmodel.BlockState.gibbs_sweep" title="Permalink to this definition">¶</a></dt>
<dd><p>Perform <code class="docutils literal notranslate"><span class="pre">niter</span></code> sweeps of a rejection-free Gibbs sampling MCMC
to sample network partitions.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>beta</strong> : <code class="docutils literal notranslate"><span class="pre">float</span></code> (optional, default: <code class="docutils literal notranslate"><span class="pre">1.</span></code>)</p>
<blockquote>
<div><p>Inverse temperature.</p>
</div></blockquote>
<p><strong>niter</strong> : <code class="docutils literal notranslate"><span class="pre">int</span></code> (optional, default: <code class="docutils literal notranslate"><span class="pre">1</span></code>)</p>
<blockquote>
<div><p>Number of sweeps to perform. During each sweep, a move attempt is
made for each node.</p>
</div></blockquote>
<p><strong>entropy_args</strong> : <code class="docutils literal notranslate"><span class="pre">dict</span></code> (optional, default: <code class="docutils literal notranslate"><span class="pre">{}</span></code>)</p>
<blockquote>
<div><p>Entropy arguments, with the same meaning and defaults as in
<a class="reference internal" href="inference.html#graph_tool.inference.blockmodel.BlockState.entropy" title="graph_tool.inference.blockmodel.BlockState.entropy"><code class="xref py py-meth docutils literal notranslate"><span class="pre">graph_tool.inference.blockmodel.BlockState.entropy()</span></code></a>.</p>
</div></blockquote>
<p><strong>allow_vacate</strong> : <code class="docutils literal notranslate"><span class="pre">bool</span></code> (optional, default: <code class="docutils literal notranslate"><span class="pre">True</span></code>)</p>
<blockquote>
<div><p>Allow groups to be vacated.</p>
</div></blockquote>
<p><strong>allow_new_group</strong> : <code class="docutils literal notranslate"><span class="pre">bool</span></code> (optional, default: <code class="docutils literal notranslate"><span class="pre">True</span></code>)</p>
<blockquote>
<div><p>Allow the number of groups to increase.</p>
</div></blockquote>
<p><strong>sequential</strong> : <code class="docutils literal notranslate"><span class="pre">bool</span></code> (optional, default: <code class="docutils literal notranslate"><span class="pre">True</span></code>)</p>
<blockquote>
<div><p>If <code class="docutils literal notranslate"><span class="pre">sequential</span> <span class="pre">==</span> <span class="pre">True</span></code> each vertex move attempt is made
sequentially, where vertices are visited in random order. Otherwise
the moves are attempted by sampling vertices randomly, so that the
same vertex can be moved more than once, before other vertices had
the chance to move.</p>
</div></blockquote>
<p><strong>deterministic</strong> : <code class="docutils literal notranslate"><span class="pre">bool</span></code> (optional, default: <code class="docutils literal notranslate"><span class="pre">False</span></code>)</p>
<blockquote>
<div><p>If <code class="docutils literal notranslate"><span class="pre">sequential</span> <span class="pre">==</span> <span class="pre">True</span></code> and <code class="docutils literal notranslate"><span class="pre">deterministic</span> <span class="pre">==</span> <span class="pre">True</span></code> the
vertices will be visited in deterministic order.</p>
</div></blockquote>
<p><strong>parallel</strong> : <code class="docutils literal notranslate"><span class="pre">bool</span></code> (optional, default: <code class="docutils literal notranslate"><span class="pre">False</span></code>)</p>
<blockquote>
<div><p>If <code class="docutils literal notranslate"><span class="pre">parallel</span> <span class="pre">==</span> <span class="pre">True</span></code>, vertex movements are attempted in parallel.</p>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">If <code class="docutils literal notranslate"><span class="pre">parallel</span> <span class="pre">==</span> <span class="pre">True</span></code>, the asymptotic exactness of the MCMC
sampling is not guaranteed.</p>
</div>
</div></blockquote>
<p><strong>vertices</strong> : <code class="docutils literal notranslate"><span class="pre">list</span></code> of ints (optional, default: <code class="docutils literal notranslate"><span class="pre">None</span></code>)</p>
<blockquote>
<div><p>If provided, this should be a list of vertices which will be
moved. Otherwise, all vertices will.</p>
</div></blockquote>
<p><strong>verbose</strong> : <code class="docutils literal notranslate"><span class="pre">bool</span></code> (optional, default: <code class="docutils literal notranslate"><span class="pre">False</span></code>)</p>
<blockquote>
<div><p>If <code class="docutils literal notranslate"><span class="pre">verbose</span> <span class="pre">==</span> <span class="pre">True</span></code>, detailed information will be displayed.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>dS</strong> : <code class="docutils literal notranslate"><span class="pre">float</span></code></p>
<blockquote>
<div><p>Entropy difference after the sweeps.</p>
</div></blockquote>
<p><strong>nattempts</strong> : <code class="docutils literal notranslate"><span class="pre">int</span></code></p>
<blockquote>
<div><p>Number of vertex moves attempted.</p>
</div></blockquote>
<p><strong>nmoves</strong> : <code class="docutils literal notranslate"><span class="pre">int</span></code></p>
<blockquote class="last">
<div><p>Number of vertices moved.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>This algorithm has an <span class="math">\(O(E\times B)\)</span> complexity, where <span class="math">\(B\)</span>
is the number of blocks, and <span class="math">\(E\)</span> is the number of edges.</p>
</dd></dl>

<dl class="method">
<dt id="graph_tool.inference.blockmodel.BlockState.multicanonical_sweep">
<code class="descname">multicanonical_sweep</code><span class="sig-paren">(</span><em>m_state</em>, <em>multiflip=False</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="http://graph-tool.skewed.de/static/doc/_modules/graph_tool/inference/blockmodel.html#BlockState.multicanonical_sweep"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="inference.html#graph_tool.inference.blockmodel.BlockState.multicanonical_sweep" title="Permalink to this definition">¶</a></dt>
<dd><p>Perform <code class="docutils literal notranslate"><span class="pre">niter</span></code> sweeps of a non-Markovian multicanonical sampling using the
Wang-Landau algorithm.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>m_state</strong> : <a class="reference internal" href="inference.html#graph_tool.inference.mcmc.MulticanonicalState" title="graph_tool.inference.mcmc.MulticanonicalState"><code class="xref py py-class docutils literal notranslate"><span class="pre">MulticanonicalState</span></code></a></p>
<blockquote>
<div><p><a class="reference internal" href="inference.html#graph_tool.inference.mcmc.MulticanonicalState" title="graph_tool.inference.mcmc.MulticanonicalState"><code class="xref py py-class docutils literal notranslate"><span class="pre">MulticanonicalState</span></code></a> instance
containing the current state of the Wang-Landau run.</p>
</div></blockquote>
<p><strong>multiflip</strong> : <code class="docutils literal notranslate"><span class="pre">bool</span></code> (optional, default: <code class="docutils literal notranslate"><span class="pre">False</span></code>)</p>
<blockquote>
<div><p>If <code class="docutils literal notranslate"><span class="pre">True</span></code>, <code class="docutils literal notranslate"><span class="pre">multiflip_mcmc_sweep()</span></code> will be used, otherwise
<code class="docutils literal notranslate"><span class="pre">mcmc_sweep()</span></code>.</p>
</div></blockquote>
<p><strong>**kwargs</strong> : Keyword parameter list</p>
<blockquote>
<div><p>The remaining parameters will be passed to
<code class="docutils literal notranslate"><span class="pre">multiflip_mcmc_sweep()</span></code> or <code class="docutils literal notranslate"><span class="pre">mcmc_sweep()</span></code>.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>dS</strong> : <code class="docutils literal notranslate"><span class="pre">float</span></code></p>
<blockquote>
<div><p>Entropy difference after the sweeps.</p>
</div></blockquote>
<p><strong>nattempts</strong> : <code class="docutils literal notranslate"><span class="pre">int</span></code></p>
<blockquote>
<div><p>Number of vertex moves attempted.</p>
</div></blockquote>
<p><strong>nmoves</strong> : <code class="docutils literal notranslate"><span class="pre">int</span></code></p>
<blockquote class="last">
<div><p>Number of vertices moved.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>This algorithm has an <span class="math">\(O(E)\)</span> complexity, where <span class="math">\(E\)</span> is the
number of edges (independent of the number of blocks).</p>
<p class="rubric">References</p>
<table class="docutils citation" frame="void" id="wang-efficient-2001179" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="inference.html#id8">[wang-efficient-2001179]</a></td><td>Fugao Wang, D. P. Landau, “An efficient, multiple
range random walk algorithm to calculate the density of states”, Phys.
Rev. Lett. 86, 2050 (2001), <a class="reference external" href="https://dx.doi.org/10.1103/PhysRevLett.86.2050">DOI: 10.1103/PhysRevLett.86.2050</a> [<a class="reference external" href="https://sci-hub.tw/10.1103/PhysRevLett.86.2050">sci-hub</a>, <a class="reference external" href="https://scihub22266oqcxt.onion.link/10.1103/PhysRevLett.86.2050">&#64;tor</a>],
<a class="reference external" href="https://arxiv.org/abs/cond-mat/0011174">arXiv: cond-mat/0011174</a></td></tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="graph_tool.inference.blockmodel.BlockState.exhaustive_sweep">
<code class="descname">exhaustive_sweep</code><span class="sig-paren">(</span><em>entropy_args={}</em>, <em>callback=None</em>, <em>density=None</em>, <em>vertices=None</em>, <em>initial_partition=None</em>, <em>max_iter=None</em><span class="sig-paren">)</span><a class="reference internal" href="http://graph-tool.skewed.de/static/doc/_modules/graph_tool/inference/blockmodel.html#BlockState.exhaustive_sweep"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="inference.html#graph_tool.inference.blockmodel.BlockState.exhaustive_sweep" title="Permalink to this definition">¶</a></dt>
<dd><p>Perform an exhaustive loop over all possible network partitions.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>entropy_args</strong> : <code class="docutils literal notranslate"><span class="pre">dict</span></code> (optional, default: <code class="docutils literal notranslate"><span class="pre">{}</span></code>)</p>
<blockquote>
<div><p>Entropy arguments, with the same meaning and defaults as in
<a class="reference internal" href="inference.html#graph_tool.inference.blockmodel.BlockState.entropy" title="graph_tool.inference.blockmodel.BlockState.entropy"><code class="xref py py-meth docutils literal notranslate"><span class="pre">graph_tool.inference.blockmodel.BlockState.entropy()</span></code></a>.</p>
</div></blockquote>
<p><strong>callback</strong> : callable object (optional, default: <code class="docutils literal notranslate"><span class="pre">None</span></code>)</p>
<blockquote>
<div><p>Function to be called for each partition, with three arguments <code class="docutils literal notranslate"><span class="pre">(S,</span>
<span class="pre">S_min,</span> <span class="pre">b_min)</span></code> corresponding to the the current entropy value, the
minimum entropy value so far, and the corresponding partition,
respectively. If not provided, and <code class="docutils literal notranslate"><span class="pre">hist</span> <span class="pre">is</span> <span class="pre">None</span></code> an iterator over
the same values will be returned instead.</p>
</div></blockquote>
<p><strong>density</strong> : <code class="docutils literal notranslate"><span class="pre">tuple</span></code> (optional, default: <code class="docutils literal notranslate"><span class="pre">None</span></code>)</p>
<blockquote>
<div><p>If provided, it should contain a tuple with values <code class="docutils literal notranslate"><span class="pre">(S_min,</span> <span class="pre">S_max,</span>
<span class="pre">n_bins)</span></code>, which will be used to obtain the density of states via a
histogram of size <code class="docutils literal notranslate"><span class="pre">n_bins</span></code>. This parameter is ignored unless
<code class="docutils literal notranslate"><span class="pre">callback</span> <span class="pre">is</span> <span class="pre">None</span></code>.</p>
</div></blockquote>
<p><strong>vertices</strong> : iterable of ints (optional, default: <code class="docutils literal notranslate"><span class="pre">None</span></code>)</p>
<blockquote>
<div><p>If provided, this should be a list of vertices which will be
moved. Otherwise, all vertices will.</p>
</div></blockquote>
<p><strong>initial_partition</strong> : iterable  of ints (optional, default: <code class="docutils literal notranslate"><span class="pre">None</span></code>)</p>
<blockquote>
<div><p>If provided, this will provide the initial partition for the
iteration.</p>
</div></blockquote>
<p><strong>max_iter</strong> : <code class="docutils literal notranslate"><span class="pre">int</span></code> (optional, default: <code class="docutils literal notranslate"><span class="pre">None</span></code>)</p>
<blockquote>
<div><p>If provided, this will limit the total number of iterations.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>states</strong> : iterator over (S, S_min, b_min)</p>
<blockquote>
<div><p>If <code class="docutils literal notranslate"><span class="pre">callback</span></code> is <code class="docutils literal notranslate"><span class="pre">None</span></code> and <code class="docutils literal notranslate"><span class="pre">hist</span></code> is <code class="docutils literal notranslate"><span class="pre">None</span></code>, the function
will return an iterator over <code class="docutils literal notranslate"><span class="pre">(S,</span> <span class="pre">S_min,</span> <span class="pre">b_min)</span></code> corresponding to
the the current entropy value, the minimum entropy value so far, and
the corresponding partition, respectively.</p>
</div></blockquote>
<p><strong>Ss, counts</strong> : pair of <a class="reference external" href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v1.14)"><code class="xref py py-class docutils literal notranslate"><span class="pre">numpy.ndarray</span></code></a></p>
<blockquote>
<div><p>If <code class="docutils literal notranslate"><span class="pre">callback</span> <span class="pre">is</span> <span class="pre">None</span></code> and <code class="docutils literal notranslate"><span class="pre">hist</span> <span class="pre">is</span> <span class="pre">not</span> <span class="pre">None</span></code>, the function will
return the values of each bin (<code class="docutils literal notranslate"><span class="pre">Ss</span></code>) and the state count of each
bin (<code class="docutils literal notranslate"><span class="pre">counts</span></code>).</p>
</div></blockquote>
<p><strong>b_min</strong> : <a class="reference internal" href="graph_tool.html#graph_tool.PropertyMap" title="graph_tool.PropertyMap"><code class="xref py py-class docutils literal notranslate"><span class="pre">PropertyMap</span></code></a></p>
<blockquote class="last">
<div><p>If <code class="docutils literal notranslate"><span class="pre">callback</span> <span class="pre">is</span> <span class="pre">not</span> <span class="pre">None</span></code> or <code class="docutils literal notranslate"><span class="pre">hist</span> <span class="pre">is</span> <span class="pre">not</span> <span class="pre">None</span></code>, the function
will also return partition with smallest entropy.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>This algorithm has an <span class="math">\(O(B^N)\)</span> complexity, where <span class="math">\(B\)</span> is the
number of blocks, and <span class="math">\(N\)</span> is the number of vertices.</p>
</dd></dl>

<dl class="method">
<dt id="graph_tool.inference.blockmodel.BlockState.merge_sweep">
<code class="descname">merge_sweep</code><span class="sig-paren">(</span><em>nmerges=1</em>, <em>niter=10</em>, <em>entropy_args={}</em>, <em>parallel=True</em>, <em>verbose=False</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="http://graph-tool.skewed.de/static/doc/_modules/graph_tool/inference/blockmodel.html#BlockState.merge_sweep"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="inference.html#graph_tool.inference.blockmodel.BlockState.merge_sweep" title="Permalink to this definition">¶</a></dt>
<dd><p>Perform <code class="docutils literal notranslate"><span class="pre">niter</span></code> merge sweeps, where block nodes are progressively
merged together in a manner that least increases the entropy.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>nmerges</strong> : <code class="docutils literal notranslate"><span class="pre">int</span></code> (optional, default: <code class="docutils literal notranslate"><span class="pre">1</span></code>)</p>
<blockquote>
<div><p>Number block nodes to merge.</p>
</div></blockquote>
<p><strong>niter</strong> : <code class="docutils literal notranslate"><span class="pre">int</span></code> (optional, default: <code class="docutils literal notranslate"><span class="pre">1</span></code>)</p>
<blockquote>
<div><p>Number of merge attempts to perform for each block node, before the
best one is selected.</p>
</div></blockquote>
<p><strong>entropy_args</strong> : <code class="docutils literal notranslate"><span class="pre">dict</span></code> (optional, default: <code class="docutils literal notranslate"><span class="pre">{}</span></code>)</p>
<blockquote>
<div><p>Entropy arguments, with the same meaning and defaults as in
<a class="reference internal" href="inference.html#graph_tool.inference.blockmodel.BlockState.entropy" title="graph_tool.inference.blockmodel.BlockState.entropy"><code class="xref py py-meth docutils literal notranslate"><span class="pre">graph_tool.inference.blockmodel.BlockState.entropy()</span></code></a>.</p>
</div></blockquote>
<p><strong>parallel</strong> : <code class="docutils literal notranslate"><span class="pre">bool</span></code> (optional, default: <code class="docutils literal notranslate"><span class="pre">True</span></code>)</p>
<blockquote>
<div><p>If <code class="docutils literal notranslate"><span class="pre">parallel</span> <span class="pre">==</span> <span class="pre">True</span></code>, the merge candidates are obtained in
parallel.</p>
</div></blockquote>
<p><strong>verbose</strong> : <code class="docutils literal notranslate"><span class="pre">bool</span></code> (optional, default: <code class="docutils literal notranslate"><span class="pre">False</span></code>)</p>
<blockquote>
<div><p>If <code class="docutils literal notranslate"><span class="pre">verbose</span> <span class="pre">==</span> <span class="pre">True</span></code>, detailed information will be displayed.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>dS</strong> : <code class="docutils literal notranslate"><span class="pre">float</span></code></p>
<blockquote>
<div><p>Entropy difference after the sweeps.</p>
</div></blockquote>
<p><strong>nattempts</strong> : <code class="docutils literal notranslate"><span class="pre">int</span></code></p>
<blockquote>
<div><p>Number of attempted merges.</p>
</div></blockquote>
<p><strong>nmoves</strong> : <code class="docutils literal notranslate"><span class="pre">int</span></code></p>
<blockquote class="last">
<div><p>Number of vertices merged.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>This function should only be called for block states, obtained from
<a class="reference internal" href="inference.html#graph_tool.inference.blockmodel.BlockState.get_block_state" title="graph_tool.inference.blockmodel.BlockState.get_block_state"><code class="xref py py-meth docutils literal notranslate"><span class="pre">graph_tool.inference.blockmodel.BlockState.get_block_state()</span></code></a>.</p>
<p class="rubric">References</p>
<table class="docutils citation" frame="void" id="peixoto-efficient-2014180" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="inference.html#id9">[peixoto-efficient-2014180]</a></td><td>Tiago P. Peixoto, “Efficient Monte Carlo and
greedy heuristic for the inference of stochastic block models”, Phys.
Rev. E 89, 012804 (2014), <a class="reference external" href="https://dx.doi.org/10.1103/PhysRevE.89.012804">DOI: 10.1103/PhysRevE.89.012804</a> [<a class="reference external" href="https://sci-hub.tw/10.1103/PhysRevE.89.012804">sci-hub</a>, <a class="reference external" href="https://scihub22266oqcxt.onion.link/10.1103/PhysRevE.89.012804">&#64;tor</a>],
<a class="reference external" href="https://arxiv.org/abs/1310.4378">arXiv: 1310.4378</a></td></tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="graph_tool.inference.blockmodel.BlockState.shrink">
<code class="descname">shrink</code><span class="sig-paren">(</span><em>B</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="http://graph-tool.skewed.de/static/doc/_modules/graph_tool/inference/blockmodel.html#BlockState.shrink"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="inference.html#graph_tool.inference.blockmodel.BlockState.shrink" title="Permalink to this definition">¶</a></dt>
<dd><p>Reduces the order of current state by progressively merging groups, until
only <code class="docutils literal notranslate"><span class="pre">B</span></code> are left. All remaining keyword arguments are passed to
<a class="reference internal" href="inference.html#graph_tool.inference.blockmodel.BlockState.merge_sweep" title="graph_tool.inference.blockmodel.BlockState.merge_sweep"><code class="xref py py-meth docutils literal notranslate"><span class="pre">graph_tool.inference.blockmodel.BlockState.merge_sweep()</span></code></a>.</p>
<p>This function leaves the current state untouched and returns instead a
copy with the new partition.</p>
</dd></dl>

<dl class="method">
<dt id="graph_tool.inference.blockmodel.BlockState.collect_edge_marginals">
<code class="descname">collect_edge_marginals</code><span class="sig-paren">(</span><em>p=None</em>, <em>update=1</em><span class="sig-paren">)</span><a class="reference internal" href="http://graph-tool.skewed.de/static/doc/_modules/graph_tool/inference/blockmodel.html#BlockState.collect_edge_marginals"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="inference.html#graph_tool.inference.blockmodel.BlockState.collect_edge_marginals" title="Permalink to this definition">¶</a></dt>
<dd><p>Collect the edge marginal histogram, which counts the number of times
the endpoints of each node have been assigned to a given block pair.</p>
<p>This should be called multiple times, e.g. after repeated runs of the
<a class="reference internal" href="inference.html#graph_tool.inference.blockmodel.BlockState.mcmc_sweep" title="graph_tool.inference.blockmodel.BlockState.mcmc_sweep"><code class="xref py py-meth docutils literal notranslate"><span class="pre">graph_tool.inference.blockmodel.BlockState.mcmc_sweep()</span></code></a> function.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>p</strong> : <a class="reference internal" href="graph_tool.html#graph_tool.PropertyMap" title="graph_tool.PropertyMap"><code class="xref py py-class docutils literal notranslate"><span class="pre">PropertyMap</span></code></a> (optional, default: <code class="docutils literal notranslate"><span class="pre">None</span></code>)</p>
<blockquote>
<div><p>Edge property map with edge marginals to be updated.  If not
provided, an empty histogram will be created.</p>
</div></blockquote>
<p><strong>update</strong> : float (optional, default: <code class="docutils literal notranslate"><span class="pre">1</span></code>)</p>
<blockquote>
<div><p>Each call increases the current count by the amount given by this
parameter.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>p</strong> : <a class="reference internal" href="graph_tool.html#graph_tool.PropertyMap" title="graph_tool.PropertyMap"><code class="xref py py-class docutils literal notranslate"><span class="pre">PropertyMap</span></code></a></p>
<blockquote class="last">
<div><p>Edge property map with updated edge marginals.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">g</span> <span class="o">=</span> <span class="n">gt</span><span class="o">.</span><span class="n">collection</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;polbooks&quot;</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">state</span> <span class="o">=</span> <span class="n">gt</span><span class="o">.</span><span class="n">BlockState</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">B</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span> <span class="n">deg_corr</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pe</span> <span class="o">=</span> <span class="bp">None</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">state</span><span class="o">.</span><span class="n">mcmc_sweep</span><span class="p">(</span><span class="n">niter</span><span class="o">=</span><span class="mi">1000</span><span class="p">)</span>   <span class="c1"># remove part of the transient</span>
<span class="go">(...)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1000</span><span class="p">):</span>
<span class="gp">... </span>    <span class="n">ret</span> <span class="o">=</span> <span class="n">state</span><span class="o">.</span><span class="n">mcmc_sweep</span><span class="p">(</span><span class="n">niter</span><span class="o">=</span><span class="mi">10</span><span class="p">)</span>
<span class="gp">... </span>    <span class="n">pe</span> <span class="o">=</span> <span class="n">state</span><span class="o">.</span><span class="n">collect_edge_marginals</span><span class="p">(</span><span class="n">pe</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">gt</span><span class="o">.</span><span class="n">bethe_entropy</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">pe</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
<span class="go">-0.901611...</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="graph_tool.inference.blockmodel.BlockState.collect_vertex_marginals">
<code class="descname">collect_vertex_marginals</code><span class="sig-paren">(</span><em>p=None</em>, <em>unlabel=False</em>, <em>update=1</em><span class="sig-paren">)</span><a class="reference internal" href="http://graph-tool.skewed.de/static/doc/_modules/graph_tool/inference/blockmodel.html#BlockState.collect_vertex_marginals"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="inference.html#graph_tool.inference.blockmodel.BlockState.collect_vertex_marginals" title="Permalink to this definition">¶</a></dt>
<dd><p>Collect the vertex marginal histogram, which counts the number of times a
node was assigned to a given block.</p>
<p>This should be called multiple times, e.g. after repeated runs of the
<a class="reference internal" href="inference.html#graph_tool.inference.blockmodel.BlockState.mcmc_sweep" title="graph_tool.inference.blockmodel.BlockState.mcmc_sweep"><code class="xref py py-meth docutils literal notranslate"><span class="pre">graph_tool.inference.blockmodel.BlockState.mcmc_sweep()</span></code></a> function.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>p</strong> : <a class="reference internal" href="graph_tool.html#graph_tool.PropertyMap" title="graph_tool.PropertyMap"><code class="xref py py-class docutils literal notranslate"><span class="pre">PropertyMap</span></code></a> (optional, default: <code class="docutils literal notranslate"><span class="pre">None</span></code>)</p>
<blockquote>
<div><p>Vertex property map with vector-type values, storing the previous block
membership counts. If not provided, an empty histogram will be created.</p>
</div></blockquote>
<p><strong>unlabel</strong> : bool (optional, default: <code class="docutils literal notranslate"><span class="pre">False</span></code>)</p>
<blockquote>
<div><p>If <code class="docutils literal notranslate"><span class="pre">True</span></code>, a canonical labelling of the groups will be used, so
that each partition is uniquely represented.</p>
</div></blockquote>
<p><strong>update</strong> : int (optional, default: <code class="docutils literal notranslate"><span class="pre">1</span></code>)</p>
<blockquote>
<div><p>Each call increases the current count by the amount given by this
parameter.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>p</strong> : <a class="reference internal" href="graph_tool.html#graph_tool.PropertyMap" title="graph_tool.PropertyMap"><code class="xref py py-class docutils literal notranslate"><span class="pre">PropertyMap</span></code></a></p>
<blockquote class="last">
<div><p>Vertex property map with vector-type values, storing the accumulated
block membership counts.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">g</span> <span class="o">=</span> <span class="n">gt</span><span class="o">.</span><span class="n">collection</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;polbooks&quot;</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">state</span> <span class="o">=</span> <span class="n">gt</span><span class="o">.</span><span class="n">BlockState</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">B</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span> <span class="n">deg_corr</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pv</span> <span class="o">=</span> <span class="bp">None</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">state</span><span class="o">.</span><span class="n">mcmc_sweep</span><span class="p">(</span><span class="n">niter</span><span class="o">=</span><span class="mi">1000</span><span class="p">)</span>   <span class="c1"># remove part of the transient</span>
<span class="go">(...)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1000</span><span class="p">):</span>
<span class="gp">... </span>    <span class="n">ret</span> <span class="o">=</span> <span class="n">state</span><span class="o">.</span><span class="n">mcmc_sweep</span><span class="p">(</span><span class="n">niter</span><span class="o">=</span><span class="mi">10</span><span class="p">)</span>
<span class="gp">... </span>    <span class="n">pv</span> <span class="o">=</span> <span class="n">state</span><span class="o">.</span><span class="n">collect_vertex_marginals</span><span class="p">(</span><span class="n">pv</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">gt</span><span class="o">.</span><span class="n">mf_entropy</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">pv</span><span class="p">)</span>
<span class="go">26.887021...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">gt</span><span class="o">.</span><span class="n">graph_draw</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">pos</span><span class="o">=</span><span class="n">g</span><span class="o">.</span><span class="n">vp</span><span class="p">[</span><span class="s2">&quot;pos&quot;</span><span class="p">],</span> <span class="n">vertex_shape</span><span class="o">=</span><span class="s2">&quot;pie&quot;</span><span class="p">,</span>
<span class="gp">... </span>              <span class="n">vertex_pie_fractions</span><span class="o">=</span><span class="n">pv</span><span class="p">,</span> <span class="n">output</span><span class="o">=</span><span class="s2">&quot;polbooks_blocks_soft_B4.pdf&quot;</span><span class="p">)</span>
<span class="go">&lt;...&gt;</span>
</pre></div>
</div>
<div class="figure align-center" id="id52">
<img alt="_images/polbooks_blocks_soft_B4.png" src="_images/polbooks_blocks_soft_B4.png" />
<p class="caption"><span class="caption-text">“Soft” block partition of a political books network with <span class="math">\(B=4\)</span>.</span></p>
</div>
</dd></dl>

<dl class="method">
<dt id="graph_tool.inference.blockmodel.BlockState.collect_partition_histogram">
<code class="descname">collect_partition_histogram</code><span class="sig-paren">(</span><em>h=None</em>, <em>update=1</em>, <em>unlabel=True</em><span class="sig-paren">)</span><a class="reference internal" href="http://graph-tool.skewed.de/static/doc/_modules/graph_tool/inference/blockmodel.html#BlockState.collect_partition_histogram"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="inference.html#graph_tool.inference.blockmodel.BlockState.collect_partition_histogram" title="Permalink to this definition">¶</a></dt>
<dd><p>Collect a histogram of partitions.</p>
<p>This should be called multiple times, e.g. after repeated runs of the
<a class="reference internal" href="inference.html#graph_tool.inference.blockmodel.BlockState.mcmc_sweep" title="graph_tool.inference.blockmodel.BlockState.mcmc_sweep"><code class="xref py py-meth docutils literal notranslate"><span class="pre">graph_tool.inference.blockmodel.BlockState.mcmc_sweep()</span></code></a> function.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>h</strong> : <a class="reference internal" href="inference.html#graph_tool.inference.blockmodel.PartitionHist" title="graph_tool.inference.blockmodel.PartitionHist"><code class="xref py py-class docutils literal notranslate"><span class="pre">PartitionHist</span></code></a> (optional, default: <code class="docutils literal notranslate"><span class="pre">None</span></code>)</p>
<blockquote>
<div><p>Partition histogram. If not provided, an empty histogram will be created.</p>
</div></blockquote>
<p><strong>update</strong> : float (optional, default: <code class="docutils literal notranslate"><span class="pre">1</span></code>)</p>
<blockquote>
<div><p>Each call increases the current count by the amount given by this
parameter.</p>
</div></blockquote>
<p><strong>unlabel</strong> : bool (optional, default: <code class="docutils literal notranslate"><span class="pre">True</span></code>)</p>
<blockquote>
<div><p>If <code class="docutils literal notranslate"><span class="pre">True</span></code>, a canonical labelling of the groups will be used, so
that each partition is uniquely represented.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>h</strong> : <a class="reference internal" href="inference.html#graph_tool.inference.blockmodel.PartitionHist" title="graph_tool.inference.blockmodel.PartitionHist"><code class="xref py py-class docutils literal notranslate"><span class="pre">PartitionHist</span></code></a> (optional, default: <code class="docutils literal notranslate"><span class="pre">None</span></code>)</p>
<blockquote class="last">
<div><p>Updated Partition histogram.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">g</span> <span class="o">=</span> <span class="n">gt</span><span class="o">.</span><span class="n">collection</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;polbooks&quot;</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">state</span> <span class="o">=</span> <span class="n">gt</span><span class="o">.</span><span class="n">BlockState</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">B</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span> <span class="n">deg_corr</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ph</span> <span class="o">=</span> <span class="bp">None</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">state</span><span class="o">.</span><span class="n">mcmc_sweep</span><span class="p">(</span><span class="n">niter</span><span class="o">=</span><span class="mi">1000</span><span class="p">)</span>   <span class="c1"># remove part of the transient</span>
<span class="go">(...)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1000</span><span class="p">):</span>
<span class="gp">... </span>    <span class="n">ret</span> <span class="o">=</span> <span class="n">state</span><span class="o">.</span><span class="n">mcmc_sweep</span><span class="p">(</span><span class="n">niter</span><span class="o">=</span><span class="mi">10</span><span class="p">)</span>
<span class="gp">... </span>    <span class="n">ph</span> <span class="o">=</span> <span class="n">state</span><span class="o">.</span><span class="n">collect_partition_histogram</span><span class="p">(</span><span class="n">ph</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">gt</span><span class="o">.</span><span class="n">microstate_entropy</span><span class="p">(</span><span class="n">ph</span><span class="p">)</span>
<span class="go">129.330077...</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="graph_tool.inference.blockmodel.BlockState.draw">
<code class="descname">draw</code><span class="sig-paren">(</span><em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="http://graph-tool.skewed.de/static/doc/_modules/graph_tool/inference/blockmodel.html#BlockState.draw"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="inference.html#graph_tool.inference.blockmodel.BlockState.draw" title="Permalink to this definition">¶</a></dt>
<dd><p>Convenience wrapper to <a class="reference internal" href="draw.html#graph_tool.draw.graph_draw" title="graph_tool.draw.graph_draw"><code class="xref py py-func docutils literal notranslate"><span class="pre">graph_draw()</span></code></a> that
draws the state of the graph as colors on the vertices and edges.</p>
</dd></dl>

<dl class="method">
<dt id="graph_tool.inference.blockmodel.BlockState.sample_graph">
<code class="descname">sample_graph</code><span class="sig-paren">(</span><em>canonical=False</em>, <em>multigraph=True</em>, <em>self_loops=True</em><span class="sig-paren">)</span><a class="reference internal" href="http://graph-tool.skewed.de/static/doc/_modules/graph_tool/inference/blockmodel.html#BlockState.sample_graph"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="inference.html#graph_tool.inference.blockmodel.BlockState.sample_graph" title="Permalink to this definition">¶</a></dt>
<dd><p>Sample a new graph from the fitted model.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>canonical</strong> : <code class="docutils literal notranslate"><span class="pre">bool</span></code> (optional, default: <code class="docutils literal notranslate"><span class="pre">False</span></code>)</p>
<blockquote>
<div><p>If <code class="docutils literal notranslate"><span class="pre">canonical</span> <span class="pre">==</span> <span class="pre">True</span></code>, the graph will be sampled from the
maximum-likelihood estimate of the canonical stochastic block
model. Otherwise, it will be sampled from the microcanonical model.</p>
</div></blockquote>
<p><strong>multigraph</strong> : <code class="docutils literal notranslate"><span class="pre">bool</span></code> (optional, default: <code class="docutils literal notranslate"><span class="pre">True</span></code>)</p>
<blockquote>
<div><p>If <code class="docutils literal notranslate"><span class="pre">True</span></code>, parallel edges will be allowed.</p>
</div></blockquote>
<p><strong>self-loops</strong> : <code class="docutils literal notranslate"><span class="pre">bool</span></code> (optional, default: <code class="docutils literal notranslate"><span class="pre">True</span></code>)</p>
<blockquote>
<div><p>If <code class="docutils literal notranslate"><span class="pre">True</span></code>, self-loops will be allowed.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>g</strong> : <a class="reference internal" href="graph_tool.html#graph_tool.Graph" title="graph_tool.Graph"><code class="xref py py-class docutils literal notranslate"><span class="pre">Graph</span></code></a></p>
<blockquote class="last">
<div><p>Generated graph.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>This function is just a convenience wrapper to
<a class="reference internal" href="http://graph-tool.skewed.de/static/doc/generation.html#graph_tool.generation.generate_sbm" title="graph_tool.generation.generate_sbm"><code class="xref py py-func docutils literal notranslate"><span class="pre">generate_sbm()</span></code></a>.</p>
<p class="rubric">Examples</p>
<div class="highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">g</span> <span class="o">=</span> <span class="n">gt</span><span class="o">.</span><span class="n">collection</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;polbooks&quot;</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">state</span> <span class="o">=</span> <span class="n">gt</span><span class="o">.</span><span class="n">minimize_blockmodel_dl</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">B_max</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">u</span> <span class="o">=</span> <span class="n">state</span><span class="o">.</span><span class="n">sample_graph</span><span class="p">(</span><span class="n">canonical</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">self_loops</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">multigraph</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ustate</span> <span class="o">=</span> <span class="n">gt</span><span class="o">.</span><span class="n">BlockState</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">b</span><span class="o">=</span><span class="n">state</span><span class="o">.</span><span class="n">b</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">state</span><span class="o">.</span><span class="n">draw</span><span class="p">(</span><span class="n">pos</span><span class="o">=</span><span class="n">g</span><span class="o">.</span><span class="n">vp</span><span class="o">.</span><span class="n">pos</span><span class="p">,</span> <span class="n">output</span><span class="o">=</span><span class="s2">&quot;polbooks-sbm.png&quot;</span><span class="p">)</span>
<span class="go">&lt;...&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ustate</span><span class="o">.</span><span class="n">draw</span><span class="p">(</span><span class="n">pos</span><span class="o">=</span><span class="n">u</span><span class="o">.</span><span class="n">own_property</span><span class="p">(</span><span class="n">g</span><span class="o">.</span><span class="n">vp</span><span class="o">.</span><span class="n">pos</span><span class="p">),</span> <span class="n">output</span><span class="o">=</span><span class="s2">&quot;polbooks-sbm-sampled.png&quot;</span><span class="p">)</span>
<span class="go">&lt;...&gt;</span>
</pre></div>
</div>
<a class="reference internal image-reference" href="_images/polbooks-sbm.png"><img alt="_images/polbooks-sbm.png" src="_images/polbooks-sbm.png" style="width: 40%;" /></a>
<a class="reference internal image-reference" href="_images/polbooks-sbm-sampled.png"><img alt="_images/polbooks-sbm-sampled.png" src="_images/polbooks-sbm-sampled.png" style="width: 40%;" /></a>
<p><em>Left:</em> Political books network. <em>Right:</em> Sample from the degree-corrected
SBM fitted to the original network.</p>
</dd></dl>

</dd></dl>

<dl class="function">
<dt id="graph_tool.inference.blockmodel.model_entropy">
<code class="descclassname">graph_tool.inference.blockmodel.</code><code class="descname">model_entropy</code><span class="sig-paren">(</span><em>B</em>, <em>N</em>, <em>E</em>, <em>directed=False</em>, <em>nr=None</em>, <em>allow_empty=True</em><span class="sig-paren">)</span><a class="reference internal" href="http://graph-tool.skewed.de/static/doc/_modules/graph_tool/inference/blockmodel.html#model_entropy"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="inference.html#graph_tool.inference.blockmodel.model_entropy" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes the amount of information necessary for the parameters of the
traditional blockmodel ensemble, for <code class="docutils literal notranslate"><span class="pre">B</span></code> blocks, <code class="docutils literal notranslate"><span class="pre">N</span></code> vertices, <code class="docutils literal notranslate"><span class="pre">E</span></code>
edges, and either a directed or undirected graph.</p>
<p>This is equivalently defined as minus the log-likelihood of sampling the
parameters from a nonparametric generative model.</p>
<p>A traditional blockmodel is defined as a set of <span class="math">\(N\)</span> vertices which can
belong to one of <span class="math">\(B\)</span> blocks, and the matrix <span class="math">\(e_{rs}\)</span> describes
the number of edges from block <span class="math">\(r\)</span> to <span class="math">\(s\)</span> (or twice that number
if <span class="math">\(r=s\)</span> and the graph is undirected).</p>
<p>For an undirected graph, the number of distinct <span class="math">\(e_{rs}\)</span> matrices is
given by,</p>
<div class="math">
\[\Omega_m = \left(\!\!{B(B+1)/2 \choose E}\!\!\right)\]</div>
<p>and for a directed graph,</p>
<div class="math">
\[\Omega_m = \left(\!\!{B^2 \choose E}\!\!\right)\]</div>
<p>where <span class="math">\(\left(\!{n \choose k}\!\right) = {n+k-1\choose k}\)</span> is the
number of <span class="math">\(k\)</span> combinations with repetitions from a set of size
<span class="math">\(n\)</span>. Hence, we have the description length of the edge counts</p>
<div class="math">
\[-\ln P(\boldsymbol{e}) = \ln \Omega_m.\]</div>
<p>For the node partition <span class="math">\(\boldsymbol{b}\)</span> we assume a two-level Bayesian
hierarchy, where first the group size histogram is generated, and
conditioned on it the partition, which leads to a description length:</p>
<div class="math">
\[-\ln P(\boldsymbol{b}) = \ln\left(\!\!{B \choose N}\!\!\right) + \ln N! - \sum_r \ln n_r!,\]</div>
<p>where <span class="math">\(n_r\)</span> is the number of nodes in block <span class="math">\(r\)</span>. If we forbid
empty groups, with <code class="docutils literal notranslate"><span class="pre">allow_empty</span> <span class="pre">==</span> <span class="pre">False</span></code>, this changes slightly to</p>
<div class="math">
\[-\ln P(\boldsymbol{b}) = \ln {N - 1 \choose B - 1} + \ln N! - \sum_r \ln n_r!.\]</div>
<p>The total information necessary to describe the model is then,</p>
<div class="math">
\[-\ln P(\boldsymbol{e}, \boldsymbol{b}) = -\ln P(\boldsymbol{e}) - \ln P(\boldsymbol{b}).\]</div>
<p>If <code class="docutils literal notranslate"><span class="pre">nr</span></code> is <code class="docutils literal notranslate"><span class="pre">None</span></code>, it is assumed <span class="math">\(n_r=N/B\)</span>. If <code class="docutils literal notranslate"><span class="pre">nr</span></code> is
<code class="docutils literal notranslate"><span class="pre">False</span></code>, the partition term <span class="math">\(-\ln P(\boldsymbol{b})\)</span> is omitted
entirely.</p>
<p class="rubric">References</p>
<table class="docutils citation" frame="void" id="peixoto-parsimonious-2013181" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="inference.html#id10">[peixoto-parsimonious-2013181]</a></td><td>Tiago P. Peixoto, “Parsimonious module
inference in large networks”, Phys. Rev. Lett. 110, 148701 (2013),
<a class="reference external" href="https://dx.doi.org/10.1103/PhysRevLett.110.148701">DOI: 10.1103/PhysRevLett.110.148701</a> [<a class="reference external" href="https://sci-hub.tw/10.1103/PhysRevLett.110.148701">sci-hub</a>, <a class="reference external" href="https://scihub22266oqcxt.onion.link/10.1103/PhysRevLett.110.148701">&#64;tor</a>], <a class="reference external" href="https://arxiv.org/abs/1212.4794">arXiv: 1212.4794</a>.</td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="peixoto-nonparametric-2017181" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="inference.html#id11">[peixoto-nonparametric-2017181]</a></td><td>Tiago P. Peixoto, “Nonparametric
Bayesian inference of the microcanonical stochastic block model”,
Phys. Rev. E 95 012317 (2017), <a class="reference external" href="https://dx.doi.org/10.1103/PhysRevE.95.012317">DOI: 10.1103/PhysRevE.95.012317</a> [<a class="reference external" href="https://sci-hub.tw/10.1103/PhysRevE.95.012317">sci-hub</a>, <a class="reference external" href="https://scihub22266oqcxt.onion.link/10.1103/PhysRevE.95.012317">&#64;tor</a>],
<a class="reference external" href="https://arxiv.org/abs/1610.02703">arXiv: 1610.02703</a></td></tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="graph_tool.inference.blockmodel.bethe_entropy">
<code class="descclassname">graph_tool.inference.blockmodel.</code><code class="descname">bethe_entropy</code><span class="sig-paren">(</span><em>g</em>, <em>p</em><span class="sig-paren">)</span><a class="reference internal" href="http://graph-tool.skewed.de/static/doc/_modules/graph_tool/inference/blockmodel.html#bethe_entropy"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="inference.html#graph_tool.inference.blockmodel.bethe_entropy" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the Bethe entropy given the edge block membership marginals.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>g</strong> : <a class="reference internal" href="graph_tool.html#graph_tool.Graph" title="graph_tool.Graph"><code class="xref py py-class docutils literal notranslate"><span class="pre">Graph</span></code></a></p>
<blockquote>
<div><p>The graph.</p>
</div></blockquote>
<p><strong>p</strong> : <a class="reference internal" href="graph_tool.html#graph_tool.PropertyMap" title="graph_tool.PropertyMap"><code class="xref py py-class docutils literal notranslate"><span class="pre">PropertyMap</span></code></a></p>
<blockquote>
<div><p>Edge property map with edge marginals.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>H</strong> : <code class="docutils literal notranslate"><span class="pre">float</span></code></p>
<blockquote>
<div><p>The Bethe entropy value (in <a class="reference external" href="http://en.wikipedia.org/wiki/Nat_%28information%29">nats</a>)</p>
</div></blockquote>
<p><strong>Hmf</strong> : <code class="docutils literal notranslate"><span class="pre">float</span></code></p>
<blockquote>
<div><p>The “mean field” entropy value (in <a class="reference external" href="http://en.wikipedia.org/wiki/Nat_%28information%29">nats</a>),
as would be returned by the <a class="reference internal" href="inference.html#graph_tool.inference.blockmodel.mf_entropy" title="graph_tool.inference.blockmodel.mf_entropy"><code class="xref py py-func docutils literal notranslate"><span class="pre">mf_entropy()</span></code></a> function.</p>
</div></blockquote>
<p><strong>pv</strong> : <a class="reference internal" href="graph_tool.html#graph_tool.PropertyMap" title="graph_tool.PropertyMap"><code class="xref py py-class docutils literal notranslate"><span class="pre">PropertyMap</span></code></a> (optional, default: <code class="docutils literal notranslate"><span class="pre">None</span></code>)</p>
<blockquote class="last">
<div><p>Vertex property map with vector-type values, storing the accumulated
block membership counts. These are the node marginals, as would be
returned by the
<a class="reference internal" href="inference.html#graph_tool.inference.blockmodel.BlockState.collect_vertex_marginals" title="graph_tool.inference.blockmodel.BlockState.collect_vertex_marginals"><code class="xref py py-meth docutils literal notranslate"><span class="pre">collect_vertex_marginals()</span></code></a>
method.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>The Bethe entropy is defined as,</p>
<div class="math">
\[H = -\sum_{ij}A_{ij}\sum_{rs}\pi_{ij}(r,s)\ln\pi_{ij}(r,s) - \sum_i(1-k_i)\sum_r\pi_i(r)\ln\pi_i(r),\]</div>
<p>where <span class="math">\(\pi_{ij}(r,s)\)</span> is the marginal probability that vertices
<span class="math">\(i\)</span> and <span class="math">\(j\)</span> belong to blocks <span class="math">\(r\)</span> and <span class="math">\(s\)</span>,
respectively, and <span class="math">\(\pi_i(r)\)</span> is the marginal probability that vertex
<span class="math">\(i\)</span> belongs to block <span class="math">\(r\)</span>, and <span class="math">\(k_i\)</span> is the degree of
vertex <span class="math">\(i\)</span> (or total degree for directed graphs).</p>
<p class="rubric">References</p>
<table class="docutils citation" frame="void" id="mezard-information-2009183" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="inference.html#id12">[mezard-information-2009183]</a></td><td>Marc Mézard, Andrea Montanari, “Information,
Physics, and Computation”, Oxford Univ Press, 2009.
<a class="reference external" href="https://dx.doi.org/10.1093/acprof:oso/9780198570837.001.0001">DOI: 10.1093/acprof:oso/9780198570837.001.0001</a> [<a class="reference external" href="https://sci-hub.tw/10.1093/acprof:oso/9780198570837.001.0001">sci-hub</a>, <a class="reference external" href="https://scihub22266oqcxt.onion.link/10.1093/acprof:oso/9780198570837.001.0001">&#64;tor</a>]</td></tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="graph_tool.inference.blockmodel.mf_entropy">
<code class="descclassname">graph_tool.inference.blockmodel.</code><code class="descname">mf_entropy</code><span class="sig-paren">(</span><em>g</em>, <em>p</em><span class="sig-paren">)</span><a class="reference internal" href="http://graph-tool.skewed.de/static/doc/_modules/graph_tool/inference/blockmodel.html#mf_entropy"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="inference.html#graph_tool.inference.blockmodel.mf_entropy" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the “mean field” entropy given the vertex block membership marginals.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>g</strong> : <a class="reference internal" href="graph_tool.html#graph_tool.Graph" title="graph_tool.Graph"><code class="xref py py-class docutils literal notranslate"><span class="pre">Graph</span></code></a></p>
<blockquote>
<div><p>The graph.</p>
</div></blockquote>
<p><strong>p</strong> : <a class="reference internal" href="graph_tool.html#graph_tool.PropertyMap" title="graph_tool.PropertyMap"><code class="xref py py-class docutils literal notranslate"><span class="pre">PropertyMap</span></code></a></p>
<blockquote>
<div><p>Vertex property map with vector-type values, storing the accumulated block
membership counts.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>Hmf</strong> : <code class="docutils literal notranslate"><span class="pre">float</span></code></p>
<blockquote class="last">
<div><p>The “mean field” entropy value (in <a class="reference external" href="http://en.wikipedia.org/wiki/Nat_%28information%29">nats</a>).</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>The “mean field” entropy is defined as,</p>
<div class="math">
\[H = - \sum_{i,r}\pi_i(r)\ln\pi_i(r),\]</div>
<p>where <span class="math">\(\pi_i(r)\)</span> is the marginal probability that vertex <span class="math">\(i\)</span>
belongs to block <span class="math">\(r\)</span>.</p>
<p class="rubric">References</p>
<table class="docutils citation" frame="void" id="mezard-information-2009184" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="inference.html#id13">[mezard-information-2009184]</a></td><td>Marc Mézard, Andrea Montanari, “Information,
Physics, and Computation”, Oxford Univ Press, 2009.
<a class="reference external" href="https://dx.doi.org/10.1093/acprof:oso/9780198570837.001.0001">DOI: 10.1093/acprof:oso/9780198570837.001.0001</a> [<a class="reference external" href="https://sci-hub.tw/10.1093/acprof:oso/9780198570837.001.0001">sci-hub</a>, <a class="reference external" href="https://scihub22266oqcxt.onion.link/10.1093/acprof:oso/9780198570837.001.0001">&#64;tor</a>]</td></tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="graph_tool.inference.blockmodel.microstate_entropy">
<code class="descclassname">graph_tool.inference.blockmodel.</code><code class="descname">microstate_entropy</code><span class="sig-paren">(</span><em>h</em>, <em>unlabel=True</em><span class="sig-paren">)</span><a class="reference internal" href="http://graph-tool.skewed.de/static/doc/_modules/graph_tool/inference/blockmodel.html#microstate_entropy"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="inference.html#graph_tool.inference.blockmodel.microstate_entropy" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute microstate entropy given a histogram of partitions.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>h</strong> : <a class="reference internal" href="inference.html#graph_tool.inference.blockmodel.PartitionHist" title="graph_tool.inference.blockmodel.PartitionHist"><code class="xref py py-class docutils literal notranslate"><span class="pre">PartitionHist</span></code></a> (optional, default: <code class="docutils literal notranslate"><span class="pre">None</span></code>)</p>
<blockquote>
<div><p>Partition histogram.</p>
</div></blockquote>
<p><strong>unlabel</strong> : bool (optional, default: <code class="docutils literal notranslate"><span class="pre">True</span></code>)</p>
<blockquote>
<div><p>If <code class="docutils literal notranslate"><span class="pre">True</span></code>, a canonical labelling of the groups will be used, so that
each partition is uniquely represented. However, the entropy computed
will still correspond to the full distribution over labelled partitions,
where all permutations are assumed to be equally likely.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>H</strong> : <code class="docutils literal notranslate"><span class="pre">float</span></code></p>
<blockquote class="last">
<div><p>The microstate entropy value (in <a class="reference external" href="http://en.wikipedia.org/wiki/Nat_%28information%29">nats</a>).</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>The microstate entropy is defined as,</p>
<div class="math">
\[H = - \sum_{\boldsymbol b}p({\boldsymbol b})\ln p({\boldsymbol b}),\]</div>
<p>where <span class="math">\(p({\boldsymbol b})\)</span> is observed frequency of labelled partition
<span class="math">\({\boldsymbol b}\)</span>.</p>
<p class="rubric">References</p>
<table class="docutils citation" frame="void" id="mezard-information-2009185" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="inference.html#id14">[mezard-information-2009185]</a></td><td>Marc Mézard, Andrea Montanari, “Information,
Physics, and Computation”, Oxford Univ Press, 2009.
<a class="reference external" href="https://dx.doi.org/10.1093/acprof:oso/9780198570837.001.0001">DOI: 10.1093/acprof:oso/9780198570837.001.0001</a> [<a class="reference external" href="https://sci-hub.tw/10.1093/acprof:oso/9780198570837.001.0001">sci-hub</a>, <a class="reference external" href="https://scihub22266oqcxt.onion.link/10.1093/acprof:oso/9780198570837.001.0001">&#64;tor</a>]</td></tr>
</tbody>
</table>
</dd></dl>

<span class="target" id="module-graph_tool.inference.overlap_blockmodel"></span><dl class="class">
<dt id="graph_tool.inference.overlap_blockmodel.OverlapBlockState">
<em class="property">class </em><code class="descclassname">graph_tool.inference.overlap_blockmodel.</code><code class="descname">OverlapBlockState</code><span class="sig-paren">(</span><em>g</em>, <em>b=None</em>, <em>B=None</em>, <em>recs=[]</em>, <em>rec_types=[]</em>, <em>rec_params=[]</em>, <em>clabel=None</em>, <em>pclabel=None</em>, <em>deg_corr=True</em>, <em>allow_empty=False</em>, <em>max_BE=1000</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="http://graph-tool.skewed.de/static/doc/_modules/graph_tool/inference/overlap_blockmodel.html#OverlapBlockState"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="inference.html#graph_tool.inference.overlap_blockmodel.OverlapBlockState" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="inference.html#graph_tool.inference.blockmodel.BlockState" title="graph_tool.inference.blockmodel.BlockState"><code class="xref py py-class docutils literal notranslate"><span class="pre">graph_tool.inference.blockmodel.BlockState</span></code></a></p>
<p>The overlapping stochastic block model state of a given graph.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>g</strong> : <a class="reference internal" href="graph_tool.html#graph_tool.Graph" title="graph_tool.Graph"><code class="xref py py-class docutils literal notranslate"><span class="pre">Graph</span></code></a></p>
<blockquote>
<div><p>Graph to be modelled.</p>
</div></blockquote>
<p><strong>b</strong> : <a class="reference internal" href="graph_tool.html#graph_tool.PropertyMap" title="graph_tool.PropertyMap"><code class="xref py py-class docutils literal notranslate"><span class="pre">PropertyMap</span></code></a> or <a class="reference external" href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v1.14)"><code class="xref py py-class docutils literal notranslate"><span class="pre">numpy.ndarray</span></code></a> (optional, default: <code class="docutils literal notranslate"><span class="pre">None</span></code>)</p>
<blockquote>
<div><p>Initial block labels on the vertices or half-edges. If not supplied, it
will be randomly sampled.
If the value passed is a vertex property map, it will be assumed to be a
non-overlapping partition of the vertices. If it is an edge property
map, it should contain a vector for each edge, with the block labels at
each end point (sorted according to their vertex index, in the case of
undirected graphs, otherwise from source to target). If the value is an
<a class="reference external" href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v1.14)"><code class="xref py py-class docutils literal notranslate"><span class="pre">numpy.ndarray</span></code></a>, it will be assumed to correspond directly to a
partition of the list of half-edges.</p>
</div></blockquote>
<p><strong>B</strong> : <code class="docutils literal notranslate"><span class="pre">int</span></code> (optional, default: <code class="docutils literal notranslate"><span class="pre">None</span></code>)</p>
<blockquote>
<div><p>Number of blocks (or vertex groups). If not supplied it will be obtained
from the parameter <code class="docutils literal notranslate"><span class="pre">b</span></code>.</p>
</div></blockquote>
<p><strong>recs</strong> : list of <a class="reference internal" href="graph_tool.html#graph_tool.PropertyMap" title="graph_tool.PropertyMap"><code class="xref py py-class docutils literal notranslate"><span class="pre">PropertyMap</span></code></a> instances (optional, default: <code class="docutils literal notranslate"><span class="pre">[]</span></code>)</p>
<blockquote>
<div><p>List of real or discrete-valued edge covariates.</p>
</div></blockquote>
<p><strong>rec_types</strong> : list of edge covariate types (optional, default: <code class="docutils literal notranslate"><span class="pre">[]</span></code>)</p>
<blockquote>
<div><p>List of types of edge covariates. The possible types are:
<code class="docutils literal notranslate"><span class="pre">&quot;real-exponential&quot;</span></code>, <code class="docutils literal notranslate"><span class="pre">&quot;real-normal&quot;</span></code>, <code class="docutils literal notranslate"><span class="pre">&quot;discrete-geometric&quot;</span></code>,
<code class="docutils literal notranslate"><span class="pre">&quot;discrete-poisson&quot;</span></code> or <code class="docutils literal notranslate"><span class="pre">&quot;discrete-binomial&quot;</span></code>.</p>
</div></blockquote>
<p><strong>rec_params</strong> : list of <code class="docutils literal notranslate"><span class="pre">dict</span></code> (optional, default: <code class="docutils literal notranslate"><span class="pre">[]</span></code>)</p>
<blockquote>
<div><p>Model hyperparameters for edge covariates. This should a list of
<code class="docutils literal notranslate"><span class="pre">dict</span></code> instances. See <a class="reference internal" href="inference.html#graph_tool.inference.blockmodel.BlockState" title="graph_tool.inference.blockmodel.BlockState"><code class="xref py py-class docutils literal notranslate"><span class="pre">BlockState</span></code></a> for
more details.</p>
</div></blockquote>
<p><strong>clabel</strong> : <a class="reference internal" href="graph_tool.html#graph_tool.PropertyMap" title="graph_tool.PropertyMap"><code class="xref py py-class docutils literal notranslate"><span class="pre">PropertyMap</span></code></a> (optional, default: <code class="docutils literal notranslate"><span class="pre">None</span></code>)</p>
<blockquote>
<div><p>Constraint labels on the vertices. If supplied, vertices with different
label values will not be clustered in the same group.</p>
</div></blockquote>
<p><strong>deg_corr</strong> : <code class="docutils literal notranslate"><span class="pre">bool</span></code> (optional, default: <code class="docutils literal notranslate"><span class="pre">True</span></code>)</p>
<blockquote>
<div><p>If <code class="docutils literal notranslate"><span class="pre">True</span></code>, the degree-corrected version of the blockmodel ensemble will
be assumed, otherwise the traditional variant will be used.</p>
</div></blockquote>
<p><strong>allow_empty</strong> : <code class="docutils literal notranslate"><span class="pre">bool</span></code> (optional, default: <code class="docutils literal notranslate"><span class="pre">False</span></code>)</p>
<blockquote>
<div><p>If <code class="docutils literal notranslate"><span class="pre">True</span></code>, partition description length computed will allow for empty
groups.</p>
</div></blockquote>
<p><strong>max_BE</strong> : <code class="docutils literal notranslate"><span class="pre">int</span></code> (optional, default: <code class="docutils literal notranslate"><span class="pre">1000</span></code>)</p>
<blockquote class="last">
<div><p>If the number of blocks exceeds this number, a sparse representation of
the block graph is used, which is slightly less efficient, but uses less
memory,</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="graph_tool.inference.overlap_blockmodel.OverlapBlockState.copy">
<code class="descname">copy</code><span class="sig-paren">(</span><em>g=None</em>, <em>b=None</em>, <em>B=None</em>, <em>deg_corr=None</em>, <em>clabel=None</em>, <em>pclabel=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="http://graph-tool.skewed.de/static/doc/_modules/graph_tool/inference/overlap_blockmodel.html#OverlapBlockState.copy"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="inference.html#graph_tool.inference.overlap_blockmodel.OverlapBlockState.copy" title="Permalink to this definition">¶</a></dt>
<dd><p>Copies the block state. The parameters override the state properties, and
have the same meaning as in the constructor. If <code class="docutils literal notranslate"><span class="pre">overlap=False</span></code> an
instance of <a class="reference internal" href="inference.html#graph_tool.inference.blockmodel.BlockState" title="graph_tool.inference.blockmodel.BlockState"><code class="xref py py-class docutils literal notranslate"><span class="pre">BlockState</span></code></a> is returned. This
is by default a shallow copy.</p>
</dd></dl>

<dl class="method">
<dt id="graph_tool.inference.overlap_blockmodel.OverlapBlockState.get_E">
<code class="descname">get_E</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="http://graph-tool.skewed.de/static/doc/_modules/graph_tool/inference/overlap_blockmodel.html#OverlapBlockState.get_E"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="inference.html#graph_tool.inference.overlap_blockmodel.OverlapBlockState.get_E" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the total number of edges.</p>
</dd></dl>

<dl class="method">
<dt id="graph_tool.inference.overlap_blockmodel.OverlapBlockState.get_N">
<code class="descname">get_N</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="http://graph-tool.skewed.de/static/doc/_modules/graph_tool/inference/overlap_blockmodel.html#OverlapBlockState.get_N"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="inference.html#graph_tool.inference.overlap_blockmodel.OverlapBlockState.get_N" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the total number of nodes.</p>
</dd></dl>

<dl class="method">
<dt id="graph_tool.inference.overlap_blockmodel.OverlapBlockState.get_B">
<code class="descname">get_B</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="http://graph-tool.skewed.de/static/doc/_modules/graph_tool/inference/overlap_blockmodel.html#OverlapBlockState.get_B"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="inference.html#graph_tool.inference.overlap_blockmodel.OverlapBlockState.get_B" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the total number of blocks.</p>
</dd></dl>

<dl class="method">
<dt id="graph_tool.inference.overlap_blockmodel.OverlapBlockState.get_nonempty_B">
<code class="descname">get_nonempty_B</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="http://graph-tool.skewed.de/static/doc/_modules/graph_tool/inference/overlap_blockmodel.html#OverlapBlockState.get_nonempty_B"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="inference.html#graph_tool.inference.overlap_blockmodel.OverlapBlockState.get_nonempty_B" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the total number of nonempty blocks.</p>
</dd></dl>

<dl class="method">
<dt id="graph_tool.inference.overlap_blockmodel.OverlapBlockState.get_edge_blocks">
<code class="descname">get_edge_blocks</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="http://graph-tool.skewed.de/static/doc/_modules/graph_tool/inference/overlap_blockmodel.html#OverlapBlockState.get_edge_blocks"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="inference.html#graph_tool.inference.overlap_blockmodel.OverlapBlockState.get_edge_blocks" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns an edge property map which contains the block labels pairs for each
edge.</p>
</dd></dl>

<dl class="method">
<dt id="graph_tool.inference.overlap_blockmodel.OverlapBlockState.get_overlap_blocks">
<code class="descname">get_overlap_blocks</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="http://graph-tool.skewed.de/static/doc/_modules/graph_tool/inference/overlap_blockmodel.html#OverlapBlockState.get_overlap_blocks"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="inference.html#graph_tool.inference.overlap_blockmodel.OverlapBlockState.get_overlap_blocks" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the mixed membership of each vertex.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>bv</strong> : <a class="reference internal" href="graph_tool.html#graph_tool.PropertyMap" title="graph_tool.PropertyMap"><code class="xref py py-class docutils literal notranslate"><span class="pre">PropertyMap</span></code></a></p>
<blockquote>
<div><p>A vector-valued vertex property map containing the block memberships
of each node.</p>
</div></blockquote>
<p><strong>bc_in</strong> : <a class="reference internal" href="graph_tool.html#graph_tool.PropertyMap" title="graph_tool.PropertyMap"><code class="xref py py-class docutils literal notranslate"><span class="pre">PropertyMap</span></code></a></p>
<blockquote>
<div><p>The labelled in-degrees of each node, i.e. how many in-edges belong
to each group, in the same order as the <code class="docutils literal notranslate"><span class="pre">bv</span></code> property above.</p>
</div></blockquote>
<p><strong>bc_out</strong> : <a class="reference internal" href="graph_tool.html#graph_tool.PropertyMap" title="graph_tool.PropertyMap"><code class="xref py py-class docutils literal notranslate"><span class="pre">PropertyMap</span></code></a></p>
<blockquote>
<div><p>The labelled out-degrees of each node, i.e. how many out-edges belong
to each group, in the same order as the <code class="docutils literal notranslate"><span class="pre">bv</span></code> property above.</p>
</div></blockquote>
<p><strong>bc_total</strong> : <a class="reference internal" href="graph_tool.html#graph_tool.PropertyMap" title="graph_tool.PropertyMap"><code class="xref py py-class docutils literal notranslate"><span class="pre">PropertyMap</span></code></a></p>
<blockquote class="last">
<div><p>The labelled total degrees of each node, i.e. how many incident edges
belong to each group, in the same order as the <code class="docutils literal notranslate"><span class="pre">bv</span></code> property above.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="graph_tool.inference.overlap_blockmodel.OverlapBlockState.get_nonoverlap_blocks">
<code class="descname">get_nonoverlap_blocks</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="http://graph-tool.skewed.de/static/doc/_modules/graph_tool/inference/overlap_blockmodel.html#OverlapBlockState.get_nonoverlap_blocks"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="inference.html#graph_tool.inference.overlap_blockmodel.OverlapBlockState.get_nonoverlap_blocks" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a scalar-valued vertex property map with the block mixture
represented as a single number.</p>
</dd></dl>

<dl class="method">
<dt id="graph_tool.inference.overlap_blockmodel.OverlapBlockState.get_majority_blocks">
<code class="descname">get_majority_blocks</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="http://graph-tool.skewed.de/static/doc/_modules/graph_tool/inference/overlap_blockmodel.html#OverlapBlockState.get_majority_blocks"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="inference.html#graph_tool.inference.overlap_blockmodel.OverlapBlockState.get_majority_blocks" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a scalar-valued vertex property map with the majority block
membership of each node.</p>
</dd></dl>

<dl class="method">
<dt id="graph_tool.inference.overlap_blockmodel.OverlapBlockState.entropy">
<code class="descname">entropy</code><span class="sig-paren">(</span><em>adjacency=True</em>, <em>dl=True</em>, <em>partition_dl=True</em>, <em>degree_dl=True</em>, <em>degree_dl_kind='distributed'</em>, <em>edges_dl=True</em>, <em>dense=False</em>, <em>multigraph=True</em>, <em>deg_entropy=True</em>, <em>recs=True</em>, <em>recs_dl=True</em>, <em>beta_dl=1.0</em>, <em>exact=True</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="http://graph-tool.skewed.de/static/doc/_modules/graph_tool/inference/overlap_blockmodel.html#OverlapBlockState.entropy"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="inference.html#graph_tool.inference.overlap_blockmodel.OverlapBlockState.entropy" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the entropy associated with the current block partition.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>adjacency</strong> : <code class="docutils literal notranslate"><span class="pre">bool</span></code> (optional, default: <code class="docutils literal notranslate"><span class="pre">True</span></code>)</p>
<blockquote>
<div><p>If <code class="docutils literal notranslate"><span class="pre">True</span></code>, the adjacency term of the description length will be
included.</p>
</div></blockquote>
<p><strong>dl</strong> : <code class="docutils literal notranslate"><span class="pre">bool</span></code> (optional, default: <code class="docutils literal notranslate"><span class="pre">True</span></code>)</p>
<blockquote>
<div><p>If <code class="docutils literal notranslate"><span class="pre">True</span></code>, the description length for the parameters will be
included.</p>
</div></blockquote>
<p><strong>partition_dl</strong> : <code class="docutils literal notranslate"><span class="pre">bool</span></code> (optional, default: <code class="docutils literal notranslate"><span class="pre">True</span></code>)</p>
<blockquote>
<div><p>If <code class="docutils literal notranslate"><span class="pre">True</span></code>, and <code class="docutils literal notranslate"><span class="pre">dl</span> <span class="pre">==</span> <span class="pre">True</span></code> the partition description length
will be included.</p>
</div></blockquote>
<p><strong>degree_dl</strong> : <code class="docutils literal notranslate"><span class="pre">bool</span></code> (optional, default: <code class="docutils literal notranslate"><span class="pre">True</span></code>)</p>
<blockquote>
<div><p>If <code class="docutils literal notranslate"><span class="pre">True</span></code>, and <code class="docutils literal notranslate"><span class="pre">dl</span> <span class="pre">==</span> <span class="pre">True</span></code> the degree sequence description
length will be included (for degree-corrected models).</p>
</div></blockquote>
<p><strong>degree_dl_kind</strong> : <code class="docutils literal notranslate"><span class="pre">str</span></code> (optional, default: <code class="docutils literal notranslate"><span class="pre">&quot;distributed&quot;</span></code>)</p>
<blockquote>
<div><p>This specifies the prior used for the degree sequence. It must be
one of: <code class="docutils literal notranslate"><span class="pre">&quot;uniform&quot;</span></code>, <code class="docutils literal notranslate"><span class="pre">&quot;distributed&quot;</span></code> (default) or <code class="docutils literal notranslate"><span class="pre">&quot;entropy&quot;</span></code>.</p>
</div></blockquote>
<p><strong>edges_dl</strong> : <code class="docutils literal notranslate"><span class="pre">bool</span></code> (optional, default: <code class="docutils literal notranslate"><span class="pre">True</span></code>)</p>
<blockquote>
<div><p>If <code class="docutils literal notranslate"><span class="pre">True</span></code>, and <code class="docutils literal notranslate"><span class="pre">dl</span> <span class="pre">==</span> <span class="pre">True</span></code> the edge matrix description length
will be included.</p>
</div></blockquote>
<p><strong>dense</strong> : <code class="docutils literal notranslate"><span class="pre">bool</span></code> (optional, default: <code class="docutils literal notranslate"><span class="pre">False</span></code>)</p>
<blockquote>
<div><p>If <code class="docutils literal notranslate"><span class="pre">True</span></code>, the “dense” variant of the entropy will be computed.</p>
</div></blockquote>
<p><strong>multigraph</strong> : <code class="docutils literal notranslate"><span class="pre">bool</span></code> (optional, default: <code class="docutils literal notranslate"><span class="pre">True</span></code>)</p>
<blockquote>
<div><p>If <code class="docutils literal notranslate"><span class="pre">True</span></code>, the multigraph entropy will be used.</p>
</div></blockquote>
<p><strong>deg_entropy</strong> : <code class="docutils literal notranslate"><span class="pre">bool</span></code> (optional, default: <code class="docutils literal notranslate"><span class="pre">True</span></code>)</p>
<blockquote>
<div><p>If <code class="docutils literal notranslate"><span class="pre">True</span></code>, the degree entropy term that is independent of the
network partition will be included (for degree-corrected models).</p>
</div></blockquote>
<p><strong>recs</strong> : <code class="docutils literal notranslate"><span class="pre">bool</span></code> (optional, default: <code class="docutils literal notranslate"><span class="pre">True</span></code>)</p>
<blockquote>
<div><p>If <code class="docutils literal notranslate"><span class="pre">True</span></code>, the likelihood for real or discrete-valued edge
covariates is computed.</p>
</div></blockquote>
<p><strong>recs_dl</strong> : <code class="docutils literal notranslate"><span class="pre">bool</span></code> (optional, default: <code class="docutils literal notranslate"><span class="pre">True</span></code>)</p>
<blockquote>
<div><p>If <code class="docutils literal notranslate"><span class="pre">True</span></code>, and <code class="docutils literal notranslate"><span class="pre">dl</span> <span class="pre">==</span> <span class="pre">True</span></code> the edge covariate description
length will be included.</p>
</div></blockquote>
<p><strong>beta_dl</strong> : <code class="docutils literal notranslate"><span class="pre">double</span></code> (optional, default: <code class="docutils literal notranslate"><span class="pre">1.</span></code>)</p>
<blockquote>
<div><p>Prior inverse temperature.</p>
</div></blockquote>
<p><strong>exact</strong> : <code class="docutils literal notranslate"><span class="pre">bool</span></code> (optional, default: <code class="docutils literal notranslate"><span class="pre">True</span></code>)</p>
<blockquote class="last">
<div><p>If <code class="docutils literal notranslate"><span class="pre">True</span></code>, the exact expressions will be used. Otherwise,
Stirling’s factorial approximation will be used for some terms.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>The “entropy” of the state is minus the log-likelihood of the
microcanonical SBM, that includes the generated graph
<span class="math">\(\boldsymbol{A}\)</span> and the model parameters <span class="math">\(\boldsymbol{\theta}\)</span>,</p>
<div class="math">
\[\begin{split}\mathcal{S} &amp;= - \ln P(\boldsymbol{A},\boldsymbol{\theta}) \\
            &amp;= - \ln P(\boldsymbol{A}|\boldsymbol{\theta}) - \ln P(\boldsymbol{\theta}).\end{split}\]</div>
<p>This value is also called the <a class="reference external" href="https://en.wikipedia.org/wiki/Minimum_description_length">description length</a> of the data,
and it corresponds to the amount of information required to describe it
(in <a class="reference external" href="https://en.wikipedia.org/wiki/Nat_(unit)">nats</a>).</p>
<p>For the traditional blockmodel (<code class="docutils literal notranslate"><span class="pre">deg_corr</span> <span class="pre">==</span> <span class="pre">False</span></code>), the model
parameters are <span class="math">\(\boldsymbol{\theta} = \{\boldsymbol{e},
\boldsymbol{b}\}\)</span>, where <span class="math">\(\boldsymbol{e}\)</span> is the matrix of edge
counts between blocks, and <span class="math">\(\boldsymbol{b}\)</span> is the <cite>overlapping</cite>
partition of the nodes into blocks. For the degree-corrected blockmodel
(<code class="docutils literal notranslate"><span class="pre">deg_corr</span> <span class="pre">==</span> <span class="pre">True</span></code>), we have an additional set of parameters, namely
the <cite>labelled</cite> degree sequence <span class="math">\(\boldsymbol{k}\)</span>.</p>
<p>The model likelihood <span class="math">\(P(\boldsymbol{A}|\theta)\)</span> is given
analogously to the non-overlapping case, as described in
<a class="reference internal" href="inference.html#graph_tool.inference.blockmodel.BlockState.entropy" title="graph_tool.inference.blockmodel.BlockState.entropy"><code class="xref py py-meth docutils literal notranslate"><span class="pre">graph_tool.inference.blockmodel.BlockState.entropy()</span></code></a>.</p>
<p>If <code class="docutils literal notranslate"><span class="pre">dl</span> <span class="pre">==</span> <span class="pre">True</span></code>, the description length <span class="math">\(\mathcal{L} = -\ln
P(\boldsymbol{\theta})\)</span> of the model will be returned as well. The
edge-count prior <span class="math">\(P(\boldsymbol{e})\)</span> is described in described in
<a class="reference internal" href="inference.html#graph_tool.inference.blockmodel.model_entropy" title="graph_tool.inference.blockmodel.model_entropy"><code class="xref py py-func docutils literal notranslate"><span class="pre">model_entropy()</span></code></a>. For the
overlapping partition <span class="math">\(P(\boldsymbol{b})\)</span>, we have</p>
<div class="math">
\[-\ln P(\boldsymbol{b}) = \ln\left(\!\!{D \choose N}\!\!\right) + \sum_d \ln {\left(\!\!{{B\choose d}\choose n_d}\!\!\right)} + \ln N! - \sum_{\vec{b}}\ln n_{\vec{b}}!,\]</div>
<p>where <span class="math">\(d \equiv |\vec{b}|_1 = \sum_rb_r\)</span> is the mixture
size, <span class="math">\(n_d\)</span> is the number of nodes in a mixture of size <span class="math">\(d\)</span>,
<span class="math">\(D\)</span> is the maximum value of <span class="math">\(d\)</span>, <span class="math">\(n_{\vec{b}}\)</span> is the
number of nodes in mixture <span class="math">\(\vec{b}\)</span>.</p>
<p>For the degree-corrected model we need to specify the prior
<span class="math">\(P(\boldsymbol{k})\)</span> for the <cite>labelled</cite> degree sequence as well:</p>
<div class="math">
\[-\ln P(\boldsymbol{k}) = \sum_r\ln\left(\!\!{m_r \choose e_r}\!\!\right) - \sum_{\vec{b}}\ln P(\boldsymbol{k}|{\vec{b}}),\]</div>
<p>where <span class="math">\(m_r\)</span> is the number of non-empty mixtures which contain type
<span class="math">\(r\)</span>, and <span class="math">\(P(\boldsymbol{k}|{\vec{b}})\)</span> is the likelihood of
the labelled degree sequence inside mixture <span class="math">\(\vec{b}\)</span>. For this
term we have three options:</p>
<ol class="arabic">
<li><p class="first"><code class="docutils literal notranslate"><span class="pre">degree_dl_kind</span> <span class="pre">==</span> <span class="pre">&quot;uniform&quot;</span></code></p>
<blockquote>
<div><div class="math">
\[P(\boldsymbol{k}|\vec{b}) = \prod_r\left(\!\!{n_{\vec{b}}\choose e^r_{\vec{b}}}\!\!\right)^{-1}.\]</div>
</div></blockquote>
</li>
<li><p class="first"><code class="docutils literal notranslate"><span class="pre">degree_dl_kind</span> <span class="pre">==</span> <span class="pre">&quot;distributed&quot;</span></code></p>
<blockquote>
<div><div class="math">
\[P(\boldsymbol{k}|\vec{b}) = \prod_{\vec{b}}\frac{\prod_{\vec{k}}\eta_{\vec{k}}^{\vec{b}}!}{n_{\vec{b}}!} \prod_r q(e_{\vec{b}}^r - n_{\vec{b}}, n_{\vec{b}})\]</div>
<p>where <span class="math">\(n^{\vec{b}}_{\vec{k}}\)</span> is the number of nodes in
mixture <span class="math">\(\vec{b}\)</span> with labelled degree <span class="math">\(\vec{k}\)</span>, and
<span class="math">\(q(n,m)\)</span> is the number of <a class="reference external" href="https://en.wikipedia.org/wiki/Partition_(number_theory)">partitions</a> of
integer <span class="math">\(n\)</span> into at most <span class="math">\(m\)</span> parts.</p>
</div></blockquote>
</li>
<li><p class="first"><code class="docutils literal notranslate"><span class="pre">degree_dl_kind</span> <span class="pre">==</span> <span class="pre">&quot;entropy&quot;</span></code></p>
<blockquote>
<div><div class="math">
\[P(\boldsymbol{k}|\vec{b}) = \prod_{\vec{b}}\exp\left(-n_{\vec{b}}H(\boldsymbol{k}_{\vec{b}})\right)\]</div>
<p>where <span class="math">\(H(\boldsymbol{k}_{\vec{b}}) =
-\sum_{\vec{k}}p_{\vec{b}}(\vec{k})\ln p_{\vec{b}}(\vec{k})\)</span> is the
entropy of the labelled degree distribution inside mixture
<span class="math">\(\vec{b}\)</span>.</p>
<p>Note that, differently from the other two choices, this represents
only an approximation of the description length. It is meant to be
used only for comparison purposes, and should be avoided in practice.</p>
</div></blockquote>
</li>
</ol>
<p>For the directed case, the above expressions are duplicated for the in-
and out-degrees.</p>
</dd></dl>

<dl class="method">
<dt id="graph_tool.inference.overlap_blockmodel.OverlapBlockState.mcmc_sweep">
<code class="descname">mcmc_sweep</code><span class="sig-paren">(</span><em>bundled=False</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="http://graph-tool.skewed.de/static/doc/_modules/graph_tool/inference/overlap_blockmodel.html#OverlapBlockState.mcmc_sweep"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="inference.html#graph_tool.inference.overlap_blockmodel.OverlapBlockState.mcmc_sweep" title="Permalink to this definition">¶</a></dt>
<dd><p>Perform sweeps of a Metropolis-Hastings rejection sampling MCMC to sample
network partitions. If <code class="docutils literal notranslate"><span class="pre">bundled</span> <span class="pre">==</span> <span class="pre">True</span></code>, the half-edges incident of
the same node that belong to the same group are moved together. All
remaining parameters are passed to
<a class="reference internal" href="inference.html#graph_tool.inference.blockmodel.BlockState.mcmc_sweep" title="graph_tool.inference.blockmodel.BlockState.mcmc_sweep"><code class="xref py py-meth docutils literal notranslate"><span class="pre">graph_tool.inference.blockmodel.BlockState.mcmc_sweep()</span></code></a>.</p>
</dd></dl>

<dl class="method">
<dt id="graph_tool.inference.overlap_blockmodel.OverlapBlockState.shrink">
<code class="descname">shrink</code><span class="sig-paren">(</span><em>B</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="http://graph-tool.skewed.de/static/doc/_modules/graph_tool/inference/overlap_blockmodel.html#OverlapBlockState.shrink"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="inference.html#graph_tool.inference.overlap_blockmodel.OverlapBlockState.shrink" title="Permalink to this definition">¶</a></dt>
<dd><p>Reduces the order of current state by progressively merging groups,
until only <code class="docutils literal notranslate"><span class="pre">B</span></code> are left. All remaining keyword arguments are passed to
<a class="reference internal" href="inference.html#graph_tool.inference.blockmodel.BlockState.merge_sweep" title="graph_tool.inference.blockmodel.BlockState.merge_sweep"><code class="xref py py-meth docutils literal notranslate"><span class="pre">graph_tool.inference.blockmodel.BlockState.merge_sweep()</span></code></a>.</p>
<p>This function leaves the current state untouched and returns instead a
copy with the new partition.</p>
</dd></dl>

<dl class="method">
<dt id="graph_tool.inference.overlap_blockmodel.OverlapBlockState.draw">
<code class="descname">draw</code><span class="sig-paren">(</span><em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="http://graph-tool.skewed.de/static/doc/_modules/graph_tool/inference/overlap_blockmodel.html#OverlapBlockState.draw"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="inference.html#graph_tool.inference.overlap_blockmodel.OverlapBlockState.draw" title="Permalink to this definition">¶</a></dt>
<dd><p>Convenience wrapper to <a class="reference internal" href="draw.html#graph_tool.draw.graph_draw" title="graph_tool.draw.graph_draw"><code class="xref py py-func docutils literal notranslate"><span class="pre">graph_draw()</span></code></a> that
draws the state of the graph as colors on the vertices and edges.</p>
</dd></dl>

</dd></dl>

<dl class="function">
<dt id="graph_tool.inference.overlap_blockmodel.half_edge_graph">
<code class="descclassname">graph_tool.inference.overlap_blockmodel.</code><code class="descname">half_edge_graph</code><span class="sig-paren">(</span><em>g</em>, <em>b=None</em>, <em>B=None</em>, <em>rec=None</em><span class="sig-paren">)</span><a class="reference internal" href="http://graph-tool.skewed.de/static/doc/_modules/graph_tool/inference/overlap_blockmodel.html#half_edge_graph"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="inference.html#graph_tool.inference.overlap_blockmodel.half_edge_graph" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate a half-edge graph, where each half-edge is represented by a node,
and an edge connects the half-edges like in the original graph.</p>
</dd></dl>

<dl class="function">
<dt id="graph_tool.inference.overlap_blockmodel.augmented_graph">
<code class="descclassname">graph_tool.inference.overlap_blockmodel.</code><code class="descname">augmented_graph</code><span class="sig-paren">(</span><em>g</em>, <em>b</em>, <em>node_index</em>, <em>eweight=None</em><span class="sig-paren">)</span><a class="reference internal" href="http://graph-tool.skewed.de/static/doc/_modules/graph_tool/inference/overlap_blockmodel.html#augmented_graph"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="inference.html#graph_tool.inference.overlap_blockmodel.augmented_graph" title="Permalink to this definition">¶</a></dt>
<dd><p>Generates an augmented graph from the half-edge graph <code class="docutils literal notranslate"><span class="pre">g</span></code> partitioned
according to <code class="docutils literal notranslate"><span class="pre">b</span></code>, where each half-edge belonging to a different group
inside each node forms a new node.</p>
</dd></dl>

<dl class="function">
<dt id="graph_tool.inference.overlap_blockmodel.get_block_edge_gradient">
<code class="descclassname">graph_tool.inference.overlap_blockmodel.</code><code class="descname">get_block_edge_gradient</code><span class="sig-paren">(</span><em>g</em>, <em>be</em>, <em>cmap=None</em><span class="sig-paren">)</span><a class="reference internal" href="http://graph-tool.skewed.de/static/doc/_modules/graph_tool/inference/overlap_blockmodel.html#get_block_edge_gradient"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="inference.html#graph_tool.inference.overlap_blockmodel.get_block_edge_gradient" title="Permalink to this definition">¶</a></dt>
<dd><p>Get edge gradients corresponding to the block membership at the endpoints of
the edges given by the <code class="docutils literal notranslate"><span class="pre">be</span></code> edge property map.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>g</strong> : <a class="reference internal" href="graph_tool.html#graph_tool.Graph" title="graph_tool.Graph"><code class="xref py py-class docutils literal notranslate"><span class="pre">Graph</span></code></a></p>
<blockquote>
<div><p>The graph.</p>
</div></blockquote>
<p><strong>be</strong> : <a class="reference internal" href="graph_tool.html#graph_tool.PropertyMap" title="graph_tool.PropertyMap"><code class="xref py py-class docutils literal notranslate"><span class="pre">PropertyMap</span></code></a></p>
<blockquote>
<div><p>Vector-valued edge property map with the block membership at each
endpoint.</p>
</div></blockquote>
<p><strong>cmap</strong> : <a class="reference external" href="https://matplotlib.org/api/_as_gen/matplotlib.colors.Colormap.html#matplotlib.colors.Colormap" title="(in Matplotlib v2.2.2)"><code class="xref py py-class docutils literal notranslate"><span class="pre">matplotlib.colors.Colormap</span></code></a> (optional, default: <code class="docutils literal notranslate"><span class="pre">default_cm</span></code>)</p>
<blockquote>
<div><p>Color map used to construct the gradient.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>cp</strong> : <a class="reference internal" href="graph_tool.html#graph_tool.PropertyMap" title="graph_tool.PropertyMap"><code class="xref py py-class docutils literal notranslate"><span class="pre">PropertyMap</span></code></a></p>
<blockquote class="last">
<div><p>A vector-valued edge property map containing a color gradient.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<span class="target" id="module-graph_tool.inference.layered_blockmodel"></span><dl class="class">
<dt id="graph_tool.inference.layered_blockmodel.LayeredBlockState">
<em class="property">class </em><code class="descclassname">graph_tool.inference.layered_blockmodel.</code><code class="descname">LayeredBlockState</code><span class="sig-paren">(</span><em>g</em>, <em>ec</em>, <em>eweight=None</em>, <em>vweight=None</em>, <em>recs=[]</em>, <em>rec_types=[]</em>, <em>rec_params=[]</em>, <em>b=None</em>, <em>B=None</em>, <em>clabel=None</em>, <em>pclabel=False</em>, <em>layers=False</em>, <em>deg_corr=True</em>, <em>overlap=False</em>, <em>allow_empty=False</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="http://graph-tool.skewed.de/static/doc/_modules/graph_tool/inference/layered_blockmodel.html#LayeredBlockState"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="inference.html#graph_tool.inference.layered_blockmodel.LayeredBlockState" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="inference.html#graph_tool.inference.overlap_blockmodel.OverlapBlockState" title="graph_tool.inference.overlap_blockmodel.OverlapBlockState"><code class="xref py py-class docutils literal notranslate"><span class="pre">graph_tool.inference.overlap_blockmodel.OverlapBlockState</span></code></a>, <a class="reference internal" href="inference.html#graph_tool.inference.blockmodel.BlockState" title="graph_tool.inference.blockmodel.BlockState"><code class="xref py py-class docutils literal notranslate"><span class="pre">graph_tool.inference.blockmodel.BlockState</span></code></a></p>
<p>The (possibly overlapping) block state of a given graph, where the edges are
divided into discrete layers.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>g</strong> : <a class="reference internal" href="graph_tool.html#graph_tool.Graph" title="graph_tool.Graph"><code class="xref py py-class docutils literal notranslate"><span class="pre">Graph</span></code></a></p>
<blockquote>
<div><p>Graph to be modelled.</p>
</div></blockquote>
<p><strong>ec</strong> : <a class="reference internal" href="graph_tool.html#graph_tool.PropertyMap" title="graph_tool.PropertyMap"><code class="xref py py-class docutils literal notranslate"><span class="pre">PropertyMap</span></code></a> Edge <a class="reference internal" href="graph_tool.html#graph_tool.PropertyMap" title="graph_tool.PropertyMap"><code class="xref py py-class docutils literal notranslate"><span class="pre">PropertyMap</span></code></a></p>
<blockquote>
<div><p>containing discrete edge covariates that will split the network in
discrete layers.</p>
</div></blockquote>
<p><strong>recs</strong> : list of <a class="reference internal" href="graph_tool.html#graph_tool.PropertyMap" title="graph_tool.PropertyMap"><code class="xref py py-class docutils literal notranslate"><span class="pre">PropertyMap</span></code></a> instances (optional, default: <code class="docutils literal notranslate"><span class="pre">[]</span></code>)</p>
<blockquote>
<div><p>List of real or discrete-valued edge covariates.</p>
</div></blockquote>
<p><strong>rec_types</strong> : list of edge covariate types (optional, default: <code class="docutils literal notranslate"><span class="pre">[]</span></code>)</p>
<blockquote>
<div><p>List of types of edge covariates. The possible types are:
<code class="docutils literal notranslate"><span class="pre">&quot;real-exponential&quot;</span></code>, <code class="docutils literal notranslate"><span class="pre">&quot;real-normal&quot;</span></code>, <code class="docutils literal notranslate"><span class="pre">&quot;discrete-geometric&quot;</span></code>,
<code class="docutils literal notranslate"><span class="pre">&quot;discrete-poisson&quot;</span></code> or <code class="docutils literal notranslate"><span class="pre">&quot;discrete-binomial&quot;</span></code>.</p>
</div></blockquote>
<p><strong>rec_params</strong> : list of <code class="docutils literal notranslate"><span class="pre">dict</span></code> (optional, default: <code class="docutils literal notranslate"><span class="pre">[]</span></code>)</p>
<blockquote>
<div><p>Model hyperparameters for edge covariates. This should a list of
<code class="docutils literal notranslate"><span class="pre">dict</span></code> instances. See <a class="reference internal" href="inference.html#graph_tool.inference.blockmodel.BlockState" title="graph_tool.inference.blockmodel.BlockState"><code class="xref py py-class docutils literal notranslate"><span class="pre">BlockState</span></code></a> for
more details.</p>
</div></blockquote>
<p><strong>eweight</strong> : <a class="reference internal" href="graph_tool.html#graph_tool.PropertyMap" title="graph_tool.PropertyMap"><code class="xref py py-class docutils literal notranslate"><span class="pre">PropertyMap</span></code></a> (optional, default: <code class="docutils literal notranslate"><span class="pre">None</span></code>)</p>
<blockquote>
<div><p>Edge multiplicities (for multigraphs or block graphs).</p>
</div></blockquote>
<p><strong>vweight</strong> : <a class="reference internal" href="graph_tool.html#graph_tool.PropertyMap" title="graph_tool.PropertyMap"><code class="xref py py-class docutils literal notranslate"><span class="pre">PropertyMap</span></code></a> (optional, default: <code class="docutils literal notranslate"><span class="pre">None</span></code>)</p>
<blockquote>
<div><p>Vertex multiplicities (for block graphs).</p>
</div></blockquote>
<p><strong>b</strong> : <a class="reference internal" href="graph_tool.html#graph_tool.PropertyMap" title="graph_tool.PropertyMap"><code class="xref py py-class docutils literal notranslate"><span class="pre">PropertyMap</span></code></a> or <a class="reference external" href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v1.14)"><code class="xref py py-class docutils literal notranslate"><span class="pre">numpy.ndarray</span></code></a> (optional, default: <code class="docutils literal notranslate"><span class="pre">None</span></code>)</p>
<blockquote>
<div><p>Initial block labels on the vertices or half-edges. If not supplied, it
will be randomly sampled.</p>
</div></blockquote>
<p><strong>B</strong> : <code class="docutils literal notranslate"><span class="pre">int</span></code> (optional, default: <code class="docutils literal notranslate"><span class="pre">None</span></code>)</p>
<blockquote>
<div><p>Number of blocks (or vertex groups). If not supplied it will be obtained
from the parameter <code class="docutils literal notranslate"><span class="pre">b</span></code>.</p>
</div></blockquote>
<p><strong>clabel</strong> : <a class="reference internal" href="graph_tool.html#graph_tool.PropertyMap" title="graph_tool.PropertyMap"><code class="xref py py-class docutils literal notranslate"><span class="pre">PropertyMap</span></code></a> (optional, default: <code class="docutils literal notranslate"><span class="pre">None</span></code>)</p>
<blockquote>
<div><p>Constraint labels on the vertices. If supplied, vertices with different
label values will not be clustered in the same group.</p>
</div></blockquote>
<p><strong>pclabel</strong> : <a class="reference internal" href="graph_tool.html#graph_tool.PropertyMap" title="graph_tool.PropertyMap"><code class="xref py py-class docutils literal notranslate"><span class="pre">PropertyMap</span></code></a> (optional, default: <code class="docutils literal notranslate"><span class="pre">None</span></code>)</p>
<blockquote>
<div><p>Partition constraint labels on the vertices. This has the same
interpretation as <code class="docutils literal notranslate"><span class="pre">clabel</span></code>, but will be used to compute the partition
description length.</p>
</div></blockquote>
<p><strong>layers</strong> : <code class="docutils literal notranslate"><span class="pre">bool</span></code> (optional, default: <code class="docutils literal notranslate"><span class="pre">False</span></code>)</p>
<blockquote>
<div><p>If <code class="docutils literal notranslate"><span class="pre">layers</span> <span class="pre">==</span> <span class="pre">True</span></code>, the “independent layers” version of the model is
used, instead of the “edge covariates” version.</p>
</div></blockquote>
<p><strong>deg_corr</strong> : <code class="docutils literal notranslate"><span class="pre">bool</span></code> (optional, default: <code class="docutils literal notranslate"><span class="pre">True</span></code>)</p>
<blockquote>
<div><p>If <code class="docutils literal notranslate"><span class="pre">True</span></code>, the degree-corrected version of the blockmodel ensemble will
be assumed, otherwise the traditional variant will be used.</p>
</div></blockquote>
<p><strong>overlap</strong> : <code class="docutils literal notranslate"><span class="pre">bool</span></code> (optional, default: <code class="docutils literal notranslate"><span class="pre">False</span></code>)</p>
<blockquote>
<div><p>If <code class="docutils literal notranslate"><span class="pre">True</span></code>, the overlapping version of the model will be used.</p>
</div></blockquote>
<p><strong>allow_empty</strong> : <code class="docutils literal notranslate"><span class="pre">bool</span></code> (optional, default: <code class="docutils literal notranslate"><span class="pre">True</span></code>)</p>
<blockquote>
<div><p>If <code class="docutils literal notranslate"><span class="pre">True</span></code>, partition description length computed will allow for empty
groups.</p>
</div></blockquote>
<p><strong>max_BE</strong> : <code class="docutils literal notranslate"><span class="pre">int</span></code> (optional, default: <code class="docutils literal notranslate"><span class="pre">1000</span></code>)</p>
<blockquote class="last">
<div><p>If the number of blocks exceeds this value, a sparse matrix is used for
the block graph. Otherwise a dense matrix will be used.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="graph_tool.inference.layered_blockmodel.LayeredBlockState.get_N">
<code class="descname">get_N</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="http://graph-tool.skewed.de/static/doc/_modules/graph_tool/inference/layered_blockmodel.html#LayeredBlockState.get_N"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="inference.html#graph_tool.inference.layered_blockmodel.LayeredBlockState.get_N" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the total number of edges.</p>
</dd></dl>

<dl class="method">
<dt id="graph_tool.inference.layered_blockmodel.LayeredBlockState.get_E">
<code class="descname">get_E</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="http://graph-tool.skewed.de/static/doc/_modules/graph_tool/inference/layered_blockmodel.html#LayeredBlockState.get_E"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="inference.html#graph_tool.inference.layered_blockmodel.LayeredBlockState.get_E" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the total number of nodes.</p>
</dd></dl>

<dl class="method">
<dt id="graph_tool.inference.layered_blockmodel.LayeredBlockState.get_B">
<code class="descname">get_B</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="http://graph-tool.skewed.de/static/doc/_modules/graph_tool/inference/layered_blockmodel.html#LayeredBlockState.get_B"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="inference.html#graph_tool.inference.layered_blockmodel.LayeredBlockState.get_B" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the total number of blocks.</p>
</dd></dl>

<dl class="method">
<dt id="graph_tool.inference.layered_blockmodel.LayeredBlockState.get_nonempty_B">
<code class="descname">get_nonempty_B</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="http://graph-tool.skewed.de/static/doc/_modules/graph_tool/inference/layered_blockmodel.html#LayeredBlockState.get_nonempty_B"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="inference.html#graph_tool.inference.layered_blockmodel.LayeredBlockState.get_nonempty_B" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the total number of nonempty blocks.</p>
</dd></dl>

<dl class="method">
<dt id="graph_tool.inference.layered_blockmodel.LayeredBlockState.copy">
<code class="descname">copy</code><span class="sig-paren">(</span><em>g=None</em>, <em>eweight=None</em>, <em>vweight=None</em>, <em>b=None</em>, <em>B=None</em>, <em>deg_corr=None</em>, <em>clabel=None</em>, <em>pclabel=None</em>, <em>bfield=None</em>, <em>overlap=None</em>, <em>layers=None</em>, <em>ec=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="http://graph-tool.skewed.de/static/doc/_modules/graph_tool/inference/layered_blockmodel.html#LayeredBlockState.copy"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="inference.html#graph_tool.inference.layered_blockmodel.LayeredBlockState.copy" title="Permalink to this definition">¶</a></dt>
<dd><p>Copies the block state. The parameters override the state properties, and
have the same meaning as in the constructor.</p>
</dd></dl>

<dl class="method">
<dt id="graph_tool.inference.layered_blockmodel.LayeredBlockState.get_bg">
<code class="descname">get_bg</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="http://graph-tool.skewed.de/static/doc/_modules/graph_tool/inference/layered_blockmodel.html#LayeredBlockState.get_bg"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="inference.html#graph_tool.inference.layered_blockmodel.LayeredBlockState.get_bg" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the block graph.</p>
</dd></dl>

<dl class="method">
<dt id="graph_tool.inference.layered_blockmodel.LayeredBlockState.get_block_state">
<code class="descname">get_block_state</code><span class="sig-paren">(</span><em>b=None</em>, <em>vweight=False</em>, <em>deg_corr=False</em>, <em>overlap=False</em>, <em>layers=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="http://graph-tool.skewed.de/static/doc/_modules/graph_tool/inference/layered_blockmodel.html#LayeredBlockState.get_block_state"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="inference.html#graph_tool.inference.layered_blockmodel.LayeredBlockState.get_block_state" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a <a class="reference internal" href="inference.html#graph_tool.inference.layered_blockmodel.LayeredBlockState" title="graph_tool.inference.layered_blockmodel.LayeredBlockState"><code class="xref py py-class docutils literal notranslate"><span class="pre">LayeredBlockState</span></code></a>
corresponding to the block graph. The parameters have the same meaning
as the in the constructor.</p>
</dd></dl>

<dl class="method">
<dt id="graph_tool.inference.layered_blockmodel.LayeredBlockState.get_edge_blocks">
<code class="descname">get_edge_blocks</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="http://graph-tool.skewed.de/static/doc/_modules/graph_tool/inference/layered_blockmodel.html#LayeredBlockState.get_edge_blocks"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="inference.html#graph_tool.inference.layered_blockmodel.LayeredBlockState.get_edge_blocks" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns an edge property map which contains the block labels pairs for each
edge.</p>
</dd></dl>

<dl class="method">
<dt id="graph_tool.inference.layered_blockmodel.LayeredBlockState.get_overlap_blocks">
<code class="descname">get_overlap_blocks</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="http://graph-tool.skewed.de/static/doc/_modules/graph_tool/inference/layered_blockmodel.html#LayeredBlockState.get_overlap_blocks"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="inference.html#graph_tool.inference.layered_blockmodel.LayeredBlockState.get_overlap_blocks" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the mixed membership of each vertex.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>bv</strong> : <a class="reference internal" href="graph_tool.html#graph_tool.PropertyMap" title="graph_tool.PropertyMap"><code class="xref py py-class docutils literal notranslate"><span class="pre">PropertyMap</span></code></a></p>
<blockquote>
<div><p>A vector-valued vertex property map containing the block memberships
of each node.</p>
</div></blockquote>
<p><strong>bc_in</strong> : <a class="reference internal" href="graph_tool.html#graph_tool.PropertyMap" title="graph_tool.PropertyMap"><code class="xref py py-class docutils literal notranslate"><span class="pre">PropertyMap</span></code></a></p>
<blockquote>
<div><p>The labelled in-degrees of each node, i.e. how many in-edges belong
to each group, in the same order as the <code class="docutils literal notranslate"><span class="pre">bv</span></code> property above.</p>
</div></blockquote>
<p><strong>bc_out</strong> : <a class="reference internal" href="graph_tool.html#graph_tool.PropertyMap" title="graph_tool.PropertyMap"><code class="xref py py-class docutils literal notranslate"><span class="pre">PropertyMap</span></code></a></p>
<blockquote>
<div><p>The labelled out-degrees of each node, i.e. how many out-edges belong
to each group, in the same order as the <code class="docutils literal notranslate"><span class="pre">bv</span></code> property above.</p>
</div></blockquote>
<p><strong>bc_total</strong> : <a class="reference internal" href="graph_tool.html#graph_tool.PropertyMap" title="graph_tool.PropertyMap"><code class="xref py py-class docutils literal notranslate"><span class="pre">PropertyMap</span></code></a></p>
<blockquote class="last">
<div><p>The labelled total degrees of each node, i.e. how many incident edges
belong to each group, in the same order as the <code class="docutils literal notranslate"><span class="pre">bv</span></code> property above.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="graph_tool.inference.layered_blockmodel.LayeredBlockState.get_nonoverlap_blocks">
<code class="descname">get_nonoverlap_blocks</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="http://graph-tool.skewed.de/static/doc/_modules/graph_tool/inference/layered_blockmodel.html#LayeredBlockState.get_nonoverlap_blocks"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="inference.html#graph_tool.inference.layered_blockmodel.LayeredBlockState.get_nonoverlap_blocks" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a scalar-valued vertex property map with the block mixture
represented as a single number.</p>
</dd></dl>

<dl class="method">
<dt id="graph_tool.inference.layered_blockmodel.LayeredBlockState.get_majority_blocks">
<code class="descname">get_majority_blocks</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="http://graph-tool.skewed.de/static/doc/_modules/graph_tool/inference/layered_blockmodel.html#LayeredBlockState.get_majority_blocks"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="inference.html#graph_tool.inference.layered_blockmodel.LayeredBlockState.get_majority_blocks" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a scalar-valued vertex property map with the majority block
membership of each node.</p>
</dd></dl>

<dl class="method">
<dt id="graph_tool.inference.layered_blockmodel.LayeredBlockState.entropy">
<code class="descname">entropy</code><span class="sig-paren">(</span><em>adjacency=True</em>, <em>dl=True</em>, <em>partition_dl=True</em>, <em>degree_dl=True</em>, <em>degree_dl_kind='distributed'</em>, <em>edges_dl=True</em>, <em>dense=False</em>, <em>multigraph=True</em>, <em>deg_entropy=True</em>, <em>exact=True</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="http://graph-tool.skewed.de/static/doc/_modules/graph_tool/inference/layered_blockmodel.html#LayeredBlockState.entropy"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="inference.html#graph_tool.inference.layered_blockmodel.LayeredBlockState.entropy" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the entropy associated with the current block partition. The
meaning of the parameters are the same as in
<a class="reference internal" href="inference.html#graph_tool.inference.blockmodel.BlockState.entropy" title="graph_tool.inference.blockmodel.BlockState.entropy"><code class="xref py py-meth docutils literal notranslate"><span class="pre">graph_tool.inference.blockmodel.BlockState.entropy()</span></code></a>.</p>
</dd></dl>

<dl class="method">
<dt id="graph_tool.inference.layered_blockmodel.LayeredBlockState.get_edges_prob">
<code class="descname">get_edges_prob</code><span class="sig-paren">(</span><em>missing</em>, <em>spurious=[]</em>, <em>entropy_args={}</em><span class="sig-paren">)</span><a class="reference internal" href="http://graph-tool.skewed.de/static/doc/_modules/graph_tool/inference/layered_blockmodel.html#LayeredBlockState.get_edges_prob"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="inference.html#graph_tool.inference.layered_blockmodel.LayeredBlockState.get_edges_prob" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the joint log-probability of the missing and spurious edges given by
<code class="docutils literal notranslate"><span class="pre">missing</span></code> and <code class="docutils literal notranslate"><span class="pre">spurious</span></code> (a list of <code class="docutils literal notranslate"><span class="pre">(source,</span> <span class="pre">target,</span> <span class="pre">layer)</span></code>
tuples, or <a class="reference internal" href="graph_tool.html#graph_tool.Edge" title="graph_tool.Edge"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Edge()</span></code></a> instances), together with the
observed edges.</p>
<p>More precisely, the log-likelihood returned is</p>
<div class="math">
\[\ln \frac{P(\boldsymbol G + \delta \boldsymbol G | \boldsymbol b)}{P(\boldsymbol G| \boldsymbol b)}\]</div>
<p>where <span class="math">\(\boldsymbol G + \delta \boldsymbol G\)</span> is the modified graph
(with missing edges added and spurious edges deleted).</p>
<p>The values in <code class="docutils literal notranslate"><span class="pre">entropy_args</span></code> are passed to
<a class="reference internal" href="inference.html#graph_tool.inference.blockmodel.BlockState.entropy" title="graph_tool.inference.blockmodel.BlockState.entropy"><code class="xref py py-meth docutils literal notranslate"><span class="pre">graph_tool.inference.blockmodel.BlockState.entropy()</span></code></a> to calculate the
log-probability.</p>
</dd></dl>

<dl class="method">
<dt id="graph_tool.inference.layered_blockmodel.LayeredBlockState.mcmc_sweep">
<code class="descname">mcmc_sweep</code><span class="sig-paren">(</span><em>bundled=False</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="http://graph-tool.skewed.de/static/doc/_modules/graph_tool/inference/layered_blockmodel.html#LayeredBlockState.mcmc_sweep"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="inference.html#graph_tool.inference.layered_blockmodel.LayeredBlockState.mcmc_sweep" title="Permalink to this definition">¶</a></dt>
<dd><p>Perform sweeps of a Metropolis-Hastings rejection sampling MCMC to sample
network partitions. If <code class="docutils literal notranslate"><span class="pre">bundled</span> <span class="pre">==</span> <span class="pre">True</span></code> and the state is an
overlapping one, the half-edges incident of the same node that belong to
the same group are moved together. All remaining parameters are passed
to <a class="reference internal" href="inference.html#graph_tool.inference.blockmodel.BlockState.mcmc_sweep" title="graph_tool.inference.blockmodel.BlockState.mcmc_sweep"><code class="xref py py-meth docutils literal notranslate"><span class="pre">graph_tool.inference.blockmodel.BlockState.mcmc_sweep()</span></code></a>.</p>
</dd></dl>

<dl class="method">
<dt id="graph_tool.inference.layered_blockmodel.LayeredBlockState.shrink">
<code class="descname">shrink</code><span class="sig-paren">(</span><em>B</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="http://graph-tool.skewed.de/static/doc/_modules/graph_tool/inference/layered_blockmodel.html#LayeredBlockState.shrink"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="inference.html#graph_tool.inference.layered_blockmodel.LayeredBlockState.shrink" title="Permalink to this definition">¶</a></dt>
<dd><p>Reduces the order of current state by progressively merging groups, until
only <code class="docutils literal notranslate"><span class="pre">B</span></code> are left. All remaining keyword arguments are passed to
<a class="reference internal" href="inference.html#graph_tool.inference.blockmodel.BlockState.shrink" title="graph_tool.inference.blockmodel.BlockState.shrink"><code class="xref py py-meth docutils literal notranslate"><span class="pre">graph_tool.inference.blockmodel.BlockState.shrink()</span></code></a> or
<a class="reference internal" href="inference.html#graph_tool.inference.overlap_blockmodel.OverlapBlockState.shrink" title="graph_tool.inference.overlap_blockmodel.OverlapBlockState.shrink"><code class="xref py py-meth docutils literal notranslate"><span class="pre">graph_tool.inference.overlap_blockmodel.OverlapBlockState.shrink()</span></code></a>, as appropriate.</p>
<p>This function leaves the current state untouched and returns instead a
copy with the new partition.</p>
</dd></dl>

<dl class="method">
<dt id="graph_tool.inference.layered_blockmodel.LayeredBlockState.draw">
<code class="descname">draw</code><span class="sig-paren">(</span><em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="http://graph-tool.skewed.de/static/doc/_modules/graph_tool/inference/layered_blockmodel.html#LayeredBlockState.draw"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="inference.html#graph_tool.inference.layered_blockmodel.LayeredBlockState.draw" title="Permalink to this definition">¶</a></dt>
<dd><p>Convenience function to draw the current state. All keyword arguments are
passed to <a class="reference internal" href="inference.html#graph_tool.inference.blockmodel.BlockState.draw" title="graph_tool.inference.blockmodel.BlockState.draw"><code class="xref py py-meth docutils literal notranslate"><span class="pre">graph_tool.inference.blockmodel.BlockState.draw()</span></code></a> or
<a class="reference internal" href="inference.html#graph_tool.inference.overlap_blockmodel.OverlapBlockState.draw" title="graph_tool.inference.overlap_blockmodel.OverlapBlockState.draw"><code class="xref py py-meth docutils literal notranslate"><span class="pre">graph_tool.inference.overlap_blockmodel.OverlapBlockState.draw()</span></code></a>, as appropriate.</p>
</dd></dl>

</dd></dl>

<span class="target" id="module-graph_tool.inference.nested_blockmodel"></span><dl class="class">
<dt id="graph_tool.inference.nested_blockmodel.NestedBlockState">
<em class="property">class </em><code class="descclassname">graph_tool.inference.nested_blockmodel.</code><code class="descname">NestedBlockState</code><span class="sig-paren">(</span><em>g</em>, <em>bs</em>, <em>base_type=&lt;class 'graph_tool.inference.blockmodel.BlockState'&gt;</em>, <em>state_args={}</em>, <em>hstate_args={}</em>, <em>hentropy_args={}</em>, <em>sampling=False</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="http://graph-tool.skewed.de/static/doc/_modules/graph_tool/inference/nested_blockmodel.html#NestedBlockState"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="inference.html#graph_tool.inference.nested_blockmodel.NestedBlockState" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference external" href="https://docs.python.org/3/library/functions.html#object" title="(in Python v3.7)"><code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></a></p>
<p>The nested stochastic block model state of a given graph.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>g</strong> : <a class="reference internal" href="graph_tool.html#graph_tool.Graph" title="graph_tool.Graph"><code class="xref py py-class docutils literal notranslate"><span class="pre">Graph</span></code></a></p>
<blockquote>
<div><p>Graph to be modeled.</p>
</div></blockquote>
<p><strong>bs</strong> : <code class="docutils literal notranslate"><span class="pre">list</span></code> of <a class="reference internal" href="graph_tool.html#graph_tool.PropertyMap" title="graph_tool.PropertyMap"><code class="xref py py-class docutils literal notranslate"><span class="pre">PropertyMap</span></code></a> or <a class="reference external" href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v1.14)"><code class="xref py py-class docutils literal notranslate"><span class="pre">numpy.ndarray</span></code></a></p>
<blockquote>
<div><p>Hierarchical node partition.</p>
</div></blockquote>
<p><strong>base_type</strong> : <code class="docutils literal notranslate"><span class="pre">type</span></code> (optional, default: <a class="reference internal" href="inference.html#graph_tool.inference.blockmodel.BlockState" title="graph_tool.inference.blockmodel.BlockState"><code class="xref py py-class docutils literal notranslate"><span class="pre">BlockState</span></code></a>)</p>
<blockquote>
<div><p>State type for lowermost level
(e.g. <a class="reference internal" href="inference.html#graph_tool.inference.blockmodel.BlockState" title="graph_tool.inference.blockmodel.BlockState"><code class="xref py py-class docutils literal notranslate"><span class="pre">BlockState</span></code></a>,
<a class="reference internal" href="inference.html#graph_tool.inference.overlap_blockmodel.OverlapBlockState" title="graph_tool.inference.overlap_blockmodel.OverlapBlockState"><code class="xref py py-class docutils literal notranslate"><span class="pre">OverlapBlockState</span></code></a> or
<a class="reference internal" href="inference.html#graph_tool.inference.layered_blockmodel.LayeredBlockState" title="graph_tool.inference.layered_blockmodel.LayeredBlockState"><code class="xref py py-class docutils literal notranslate"><span class="pre">LayeredBlockState</span></code></a>)</p>
</div></blockquote>
<p><strong>hstate_args</strong> : <code class="docutils literal notranslate"><span class="pre">dict</span></code> (optional, default: <cite>{}</cite>)</p>
<blockquote>
<div><p>Keyword arguments to be passed to the constructor of the higher-level
states.</p>
</div></blockquote>
<p><strong>hentropy_args</strong> : <code class="docutils literal notranslate"><span class="pre">dict</span></code> (optional, default: <cite>{}</cite>)</p>
<blockquote>
<div><p>Keyword arguments to be passed to the <code class="docutils literal notranslate"><span class="pre">entropy()</span></code> method of the
higher-level states.</p>
</div></blockquote>
<p><strong>sampling</strong> : <code class="docutils literal notranslate"><span class="pre">bool</span></code> (optional, default: <code class="docutils literal notranslate"><span class="pre">False</span></code>)</p>
<blockquote>
<div><p>If <code class="docutils literal notranslate"><span class="pre">True</span></code>, the state will be properly prepared for MCMC sampling (as
opposed to minimization).</p>
</div></blockquote>
<p><strong>state_args</strong> : <code class="docutils literal notranslate"><span class="pre">dict</span></code> (optional, default: <code class="docutils literal notranslate"><span class="pre">{}</span></code>)</p>
<blockquote>
<div><p>Keyword arguments to be passed to base type constructor.</p>
</div></blockquote>
<p><strong>**kwargs</strong> :  keyword arguments</p>
<blockquote class="last">
<div><p>Keyword arguments to be passed to base type constructor. The
<code class="docutils literal notranslate"><span class="pre">state_args</span></code> parameter overrides this.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="graph_tool.inference.nested_blockmodel.NestedBlockState.copy">
<code class="descname">copy</code><span class="sig-paren">(</span><em>g=None</em>, <em>bs=None</em>, <em>state_args=None</em>, <em>hstate_args=None</em>, <em>hentropy_args=None</em>, <em>sampling=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="http://graph-tool.skewed.de/static/doc/_modules/graph_tool/inference/nested_blockmodel.html#NestedBlockState.copy"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="inference.html#graph_tool.inference.nested_blockmodel.NestedBlockState.copy" title="Permalink to this definition">¶</a></dt>
<dd><p>Copies the block state. The parameters override the state properties,
and have the same meaning as in the constructor.</p>
</dd></dl>

<dl class="method">
<dt id="graph_tool.inference.nested_blockmodel.NestedBlockState.get_bs">
<code class="descname">get_bs</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="http://graph-tool.skewed.de/static/doc/_modules/graph_tool/inference/nested_blockmodel.html#NestedBlockState.get_bs"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="inference.html#graph_tool.inference.nested_blockmodel.NestedBlockState.get_bs" title="Permalink to this definition">¶</a></dt>
<dd><p>Get hierarchy levels as a list of <a class="reference external" href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v1.14)"><code class="xref py py-class docutils literal notranslate"><span class="pre">numpy.ndarray</span></code></a> objects with the
group memberships at each level.</p>
</dd></dl>

<dl class="method">
<dt id="graph_tool.inference.nested_blockmodel.NestedBlockState.get_levels">
<code class="descname">get_levels</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="http://graph-tool.skewed.de/static/doc/_modules/graph_tool/inference/nested_blockmodel.html#NestedBlockState.get_levels"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="inference.html#graph_tool.inference.nested_blockmodel.NestedBlockState.get_levels" title="Permalink to this definition">¶</a></dt>
<dd><p>Get hierarchy levels as a list of <a class="reference internal" href="inference.html#graph_tool.inference.blockmodel.BlockState" title="graph_tool.inference.blockmodel.BlockState"><code class="xref py py-class docutils literal notranslate"><span class="pre">BlockState</span></code></a>
instances.</p>
</dd></dl>

<dl class="method">
<dt id="graph_tool.inference.nested_blockmodel.NestedBlockState.project_partition">
<code class="descname">project_partition</code><span class="sig-paren">(</span><em>j</em>, <em>l</em><span class="sig-paren">)</span><a class="reference internal" href="http://graph-tool.skewed.de/static/doc/_modules/graph_tool/inference/nested_blockmodel.html#NestedBlockState.project_partition"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="inference.html#graph_tool.inference.nested_blockmodel.NestedBlockState.project_partition" title="Permalink to this definition">¶</a></dt>
<dd><p>Project partition of level <code class="docutils literal notranslate"><span class="pre">j</span></code> onto level <code class="docutils literal notranslate"><span class="pre">l</span></code>, and return it.</p>
</dd></dl>

<dl class="method">
<dt id="graph_tool.inference.nested_blockmodel.NestedBlockState.propagate_clabel">
<code class="descname">propagate_clabel</code><span class="sig-paren">(</span><em>l</em><span class="sig-paren">)</span><a class="reference internal" href="http://graph-tool.skewed.de/static/doc/_modules/graph_tool/inference/nested_blockmodel.html#NestedBlockState.propagate_clabel"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="inference.html#graph_tool.inference.nested_blockmodel.NestedBlockState.propagate_clabel" title="Permalink to this definition">¶</a></dt>
<dd><p>Project base clabel to level <code class="docutils literal notranslate"><span class="pre">l</span></code>.</p>
</dd></dl>

<dl class="method">
<dt id="graph_tool.inference.nested_blockmodel.NestedBlockState.get_clabel">
<code class="descname">get_clabel</code><span class="sig-paren">(</span><em>l</em><span class="sig-paren">)</span><a class="reference internal" href="http://graph-tool.skewed.de/static/doc/_modules/graph_tool/inference/nested_blockmodel.html#NestedBlockState.get_clabel"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="inference.html#graph_tool.inference.nested_blockmodel.NestedBlockState.get_clabel" title="Permalink to this definition">¶</a></dt>
<dd><p>Get clabel for level <code class="docutils literal notranslate"><span class="pre">l</span></code>.</p>
</dd></dl>

<dl class="method">
<dt id="graph_tool.inference.nested_blockmodel.NestedBlockState.replace_level">
<code class="descname">replace_level</code><span class="sig-paren">(</span><em>l</em>, <em>b</em><span class="sig-paren">)</span><a class="reference internal" href="http://graph-tool.skewed.de/static/doc/_modules/graph_tool/inference/nested_blockmodel.html#NestedBlockState.replace_level"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="inference.html#graph_tool.inference.nested_blockmodel.NestedBlockState.replace_level" title="Permalink to this definition">¶</a></dt>
<dd><p>Replace level <code class="docutils literal notranslate"><span class="pre">l</span></code> given the new partition <code class="docutils literal notranslate"><span class="pre">b</span></code></p>
</dd></dl>

<dl class="method">
<dt id="graph_tool.inference.nested_blockmodel.NestedBlockState.delete_level">
<code class="descname">delete_level</code><span class="sig-paren">(</span><em>l</em><span class="sig-paren">)</span><a class="reference internal" href="http://graph-tool.skewed.de/static/doc/_modules/graph_tool/inference/nested_blockmodel.html#NestedBlockState.delete_level"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="inference.html#graph_tool.inference.nested_blockmodel.NestedBlockState.delete_level" title="Permalink to this definition">¶</a></dt>
<dd><p>Delete level <code class="docutils literal notranslate"><span class="pre">l</span></code>.</p>
</dd></dl>

<dl class="method">
<dt id="graph_tool.inference.nested_blockmodel.NestedBlockState.duplicate_level">
<code class="descname">duplicate_level</code><span class="sig-paren">(</span><em>l</em><span class="sig-paren">)</span><a class="reference internal" href="http://graph-tool.skewed.de/static/doc/_modules/graph_tool/inference/nested_blockmodel.html#NestedBlockState.duplicate_level"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="inference.html#graph_tool.inference.nested_blockmodel.NestedBlockState.duplicate_level" title="Permalink to this definition">¶</a></dt>
<dd><p>Duplicate level <code class="docutils literal notranslate"><span class="pre">l</span></code>.</p>
</dd></dl>

<dl class="method">
<dt id="graph_tool.inference.nested_blockmodel.NestedBlockState.level_entropy">
<code class="descname">level_entropy</code><span class="sig-paren">(</span><em>l</em>, <em>bstate=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="http://graph-tool.skewed.de/static/doc/_modules/graph_tool/inference/nested_blockmodel.html#NestedBlockState.level_entropy"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="inference.html#graph_tool.inference.nested_blockmodel.NestedBlockState.level_entropy" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the entropy of level <code class="docutils literal notranslate"><span class="pre">l</span></code>.</p>
</dd></dl>

<dl class="method">
<dt id="graph_tool.inference.nested_blockmodel.NestedBlockState.entropy">
<code class="descname">entropy</code><span class="sig-paren">(</span><em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="http://graph-tool.skewed.de/static/doc/_modules/graph_tool/inference/nested_blockmodel.html#NestedBlockState.entropy"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="inference.html#graph_tool.inference.nested_blockmodel.NestedBlockState.entropy" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the entropy of whole hierarchy.</p>
<p>The keyword arguments are passed to the <code class="docutils literal notranslate"><span class="pre">entropy()</span></code> method of the
underlying state objects
(e.g. <a class="reference internal" href="inference.html#graph_tool.inference.blockmodel.BlockState.entropy" title="graph_tool.inference.blockmodel.BlockState.entropy"><code class="xref py py-class docutils literal notranslate"><span class="pre">graph_tool.inference.blockmodel.BlockState.entropy</span></code></a>,
<a class="reference internal" href="inference.html#graph_tool.inference.overlap_blockmodel.OverlapBlockState.entropy" title="graph_tool.inference.overlap_blockmodel.OverlapBlockState.entropy"><code class="xref py py-class docutils literal notranslate"><span class="pre">graph_tool.inference.overlap_blockmodel.OverlapBlockState.entropy</span></code></a>, or
<a class="reference internal" href="inference.html#graph_tool.inference.layered_blockmodel.LayeredBlockState.entropy" title="graph_tool.inference.layered_blockmodel.LayeredBlockState.entropy"><code class="xref py py-class docutils literal notranslate"><span class="pre">graph_tool.inference.layered_blockmodel.LayeredBlockState.entropy</span></code></a>).</p>
</dd></dl>

<dl class="method">
<dt id="graph_tool.inference.nested_blockmodel.NestedBlockState.move_vertex">
<code class="descname">move_vertex</code><span class="sig-paren">(</span><em>v</em>, <em>s</em><span class="sig-paren">)</span><a class="reference internal" href="http://graph-tool.skewed.de/static/doc/_modules/graph_tool/inference/nested_blockmodel.html#NestedBlockState.move_vertex"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="inference.html#graph_tool.inference.nested_blockmodel.NestedBlockState.move_vertex" title="Permalink to this definition">¶</a></dt>
<dd><p>Move vertex <code class="docutils literal notranslate"><span class="pre">v</span></code> to block <code class="docutils literal notranslate"><span class="pre">s</span></code>.</p>
</dd></dl>

<dl class="method">
<dt id="graph_tool.inference.nested_blockmodel.NestedBlockState.remove_vertex">
<code class="descname">remove_vertex</code><span class="sig-paren">(</span><em>v</em><span class="sig-paren">)</span><a class="reference internal" href="http://graph-tool.skewed.de/static/doc/_modules/graph_tool/inference/nested_blockmodel.html#NestedBlockState.remove_vertex"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="inference.html#graph_tool.inference.nested_blockmodel.NestedBlockState.remove_vertex" title="Permalink to this definition">¶</a></dt>
<dd><p>Remove vertex <code class="docutils literal notranslate"><span class="pre">v</span></code> from its current group.</p>
<p>This optionally accepts a list of vertices to remove.</p>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">This will leave the state in an inconsistent state before the vertex
is returned to some other group, or if the same vertex is removed
twice.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="graph_tool.inference.nested_blockmodel.NestedBlockState.add_vertex">
<code class="descname">add_vertex</code><span class="sig-paren">(</span><em>v</em>, <em>r</em><span class="sig-paren">)</span><a class="reference internal" href="http://graph-tool.skewed.de/static/doc/_modules/graph_tool/inference/nested_blockmodel.html#NestedBlockState.add_vertex"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="inference.html#graph_tool.inference.nested_blockmodel.NestedBlockState.add_vertex" title="Permalink to this definition">¶</a></dt>
<dd><p>Add vertex <code class="docutils literal notranslate"><span class="pre">v</span></code> to block <code class="docutils literal notranslate"><span class="pre">r</span></code>.</p>
<p>This optionally accepts a list of vertices and blocks to add.</p>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">This can leave the state in an inconsistent state if a vertex is
added twice to the same group.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="graph_tool.inference.nested_blockmodel.NestedBlockState.get_edges_prob">
<code class="descname">get_edges_prob</code><span class="sig-paren">(</span><em>missing</em>, <em>spurious=[]</em>, <em>entropy_args={}</em><span class="sig-paren">)</span><a class="reference internal" href="http://graph-tool.skewed.de/static/doc/_modules/graph_tool/inference/nested_blockmodel.html#NestedBlockState.get_edges_prob"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="inference.html#graph_tool.inference.nested_blockmodel.NestedBlockState.get_edges_prob" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the joint log-probability of the missing and spurious edges given by
<code class="docutils literal notranslate"><span class="pre">missing</span></code> and <code class="docutils literal notranslate"><span class="pre">spurious</span></code> (a list of <code class="docutils literal notranslate"><span class="pre">(source,</span> <span class="pre">target)</span></code>
tuples, or <a class="reference internal" href="graph_tool.html#graph_tool.Edge" title="graph_tool.Edge"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Edge()</span></code></a> instances), together with the
observed edges.</p>
<p>More precisely, the log-likelihood returned is</p>
<div class="math">
\[\ln \frac{P(\boldsymbol G + \delta \boldsymbol G | \boldsymbol b)}{P(\boldsymbol G| \boldsymbol b)}\]</div>
<p>where <span class="math">\(\boldsymbol G + \delta \boldsymbol G\)</span> is the modified graph
(with missing edges added and spurious edges deleted).</p>
<p>The values in <code class="docutils literal notranslate"><span class="pre">entropy_args</span></code> are passed to
<a class="reference internal" href="inference.html#graph_tool.inference.blockmodel.BlockState.entropy" title="graph_tool.inference.blockmodel.BlockState.entropy"><code class="xref py py-meth docutils literal notranslate"><span class="pre">graph_tool.inference.blockmodel.BlockState.entropy()</span></code></a> to calculate the
log-probability.</p>
</dd></dl>

<dl class="method">
<dt id="graph_tool.inference.nested_blockmodel.NestedBlockState.get_bstack">
<code class="descname">get_bstack</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="http://graph-tool.skewed.de/static/doc/_modules/graph_tool/inference/nested_blockmodel.html#NestedBlockState.get_bstack"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="inference.html#graph_tool.inference.nested_blockmodel.NestedBlockState.get_bstack" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the nested levels as individual graphs.</p>
<p>This returns a list of <a class="reference internal" href="graph_tool.html#graph_tool.Graph" title="graph_tool.Graph"><code class="xref py py-class docutils literal notranslate"><span class="pre">Graph</span></code></a> instances
representing the inferred hierarchy at each level. Each graph has two
internal vertex and edge property maps named “count” which correspond to
the vertex and edge counts at the lower level, respectively. Additionally,
an internal vertex property map named “b” specifies the block partition.</p>
</dd></dl>

<dl class="method">
<dt id="graph_tool.inference.nested_blockmodel.NestedBlockState.project_level">
<code class="descname">project_level</code><span class="sig-paren">(</span><em>l</em><span class="sig-paren">)</span><a class="reference internal" href="http://graph-tool.skewed.de/static/doc/_modules/graph_tool/inference/nested_blockmodel.html#NestedBlockState.project_level"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="inference.html#graph_tool.inference.nested_blockmodel.NestedBlockState.project_level" title="Permalink to this definition">¶</a></dt>
<dd><p>Project the partition at level <code class="docutils literal notranslate"><span class="pre">l</span></code> onto the lowest level, and return the
corresponding state.</p>
</dd></dl>

<dl class="method">
<dt id="graph_tool.inference.nested_blockmodel.NestedBlockState.print_summary">
<code class="descname">print_summary</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="http://graph-tool.skewed.de/static/doc/_modules/graph_tool/inference/nested_blockmodel.html#NestedBlockState.print_summary"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="inference.html#graph_tool.inference.nested_blockmodel.NestedBlockState.print_summary" title="Permalink to this definition">¶</a></dt>
<dd><p>Print a hierarchy summary.</p>
</dd></dl>

<dl class="method">
<dt id="graph_tool.inference.nested_blockmodel.NestedBlockState.find_new_level">
<code class="descname">find_new_level</code><span class="sig-paren">(</span><em>l</em>, <em>bisection_args={}</em>, <em>B_min=None</em>, <em>B_max=None</em>, <em>b_min=None</em>, <em>b_max=None</em><span class="sig-paren">)</span><a class="reference internal" href="http://graph-tool.skewed.de/static/doc/_modules/graph_tool/inference/nested_blockmodel.html#NestedBlockState.find_new_level"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="inference.html#graph_tool.inference.nested_blockmodel.NestedBlockState.find_new_level" title="Permalink to this definition">¶</a></dt>
<dd><p>Attempt to find a better network partition at level <code class="docutils literal notranslate"><span class="pre">l</span></code>, using
<a class="reference internal" href="inference.html#graph_tool.inference.bisection.bisection_minimize" title="graph_tool.inference.bisection.bisection_minimize"><code class="xref py py-func docutils literal notranslate"><span class="pre">bisection_minimize()</span></code></a> with arguments given by
<code class="docutils literal notranslate"><span class="pre">bisection_args</span></code>.</p>
</dd></dl>

<dl class="method">
<dt id="graph_tool.inference.nested_blockmodel.NestedBlockState.mcmc_sweep">
<code class="descname">mcmc_sweep</code><span class="sig-paren">(</span><em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="http://graph-tool.skewed.de/static/doc/_modules/graph_tool/inference/nested_blockmodel.html#NestedBlockState.mcmc_sweep"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="inference.html#graph_tool.inference.nested_blockmodel.NestedBlockState.mcmc_sweep" title="Permalink to this definition">¶</a></dt>
<dd><p>Perform <code class="docutils literal notranslate"><span class="pre">niter</span></code> sweeps of a Metropolis-Hastings acceptance-rejection
MCMC to sample hierarchical network partitions.</p>
<p>The arguments accepted are the same as in
<a class="reference internal" href="inference.html#graph_tool.inference.blockmodel.BlockState.mcmc_sweep" title="graph_tool.inference.blockmodel.BlockState.mcmc_sweep"><code class="xref py py-meth docutils literal notranslate"><span class="pre">graph_tool.inference.blockmodel.BlockState.mcmc_sweep()</span></code></a>.</p>
<p>If the parameter <code class="docutils literal notranslate"><span class="pre">c</span></code> is a scalar, the values used at each level are
<code class="docutils literal notranslate"><span class="pre">c</span> <span class="pre">*</span> <span class="pre">2</span> <span class="pre">**</span> <span class="pre">l</span></code> for <code class="docutils literal notranslate"><span class="pre">l</span></code> in the range <code class="docutils literal notranslate"><span class="pre">[0,</span> <span class="pre">L-1]</span></code>. Optionally, a list
of values may be passed instead, which specifies the value of <code class="docutils literal notranslate"><span class="pre">c[l]</span></code>
to be used at each level.</p>
</dd></dl>

<dl class="method">
<dt id="graph_tool.inference.nested_blockmodel.NestedBlockState.multiflip_mcmc_sweep">
<code class="descname">multiflip_mcmc_sweep</code><span class="sig-paren">(</span><em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="http://graph-tool.skewed.de/static/doc/_modules/graph_tool/inference/nested_blockmodel.html#NestedBlockState.multiflip_mcmc_sweep"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="inference.html#graph_tool.inference.nested_blockmodel.NestedBlockState.multiflip_mcmc_sweep" title="Permalink to this definition">¶</a></dt>
<dd><p>Perform <code class="docutils literal notranslate"><span class="pre">niter</span></code> sweeps of a Metropolis-Hastings acceptance-rejection MCMC
with multiple moves to sample hierarchical network partitions.</p>
<p>The arguments accepted are the same as in
<a class="reference internal" href="inference.html#graph_tool.inference.blockmodel.BlockState.multiflip_mcmc_sweep" title="graph_tool.inference.blockmodel.BlockState.multiflip_mcmc_sweep"><code class="xref py py-meth docutils literal notranslate"><span class="pre">graph_tool.inference.blockmodel.BlockState.multiflip_mcmc_sweep()</span></code></a>.</p>
<p>If the parameter <code class="docutils literal notranslate"><span class="pre">c</span></code> is a scalar, the values used at each level are
<code class="docutils literal notranslate"><span class="pre">c</span> <span class="pre">*</span> <span class="pre">2</span> <span class="pre">**</span> <span class="pre">l</span></code> for <code class="docutils literal notranslate"><span class="pre">l</span></code> in the range <code class="docutils literal notranslate"><span class="pre">[0,</span> <span class="pre">L-1]</span></code>. Optionally, a list
of values may be passed instead, which specifies the value of <code class="docutils literal notranslate"><span class="pre">c[l]</span></code>
to be used at each level.</p>
</dd></dl>

<dl class="method">
<dt id="graph_tool.inference.nested_blockmodel.NestedBlockState.multicanonical_sweep">
<code class="descname">multicanonical_sweep</code><span class="sig-paren">(</span><em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="http://graph-tool.skewed.de/static/doc/_modules/graph_tool/inference/nested_blockmodel.html#NestedBlockState.multicanonical_sweep"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="inference.html#graph_tool.inference.nested_blockmodel.NestedBlockState.multicanonical_sweep" title="Permalink to this definition">¶</a></dt>
<dd><p>Perform <code class="docutils literal notranslate"><span class="pre">niter</span></code> sweeps of a non-Markovian multicanonical sampling using the
Wang-Landau algorithm.</p>
<p>The arguments accepted are the same as in
<a class="reference internal" href="inference.html#graph_tool.inference.blockmodel.BlockState.multicanonical_sweep" title="graph_tool.inference.blockmodel.BlockState.multicanonical_sweep"><code class="xref py py-meth docutils literal notranslate"><span class="pre">graph_tool.inference.blockmodel.BlockState.multicanonical_sweep()</span></code></a>.</p>
</dd></dl>

<dl class="method">
<dt id="graph_tool.inference.nested_blockmodel.NestedBlockState.collect_partition_histogram">
<code class="descname">collect_partition_histogram</code><span class="sig-paren">(</span><em>h=None</em>, <em>update=1</em><span class="sig-paren">)</span><a class="reference internal" href="http://graph-tool.skewed.de/static/doc/_modules/graph_tool/inference/nested_blockmodel.html#NestedBlockState.collect_partition_histogram"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="inference.html#graph_tool.inference.nested_blockmodel.NestedBlockState.collect_partition_histogram" title="Permalink to this definition">¶</a></dt>
<dd><p>Collect a histogram of partitions.</p>
<p>This should be called multiple times, e.g. after repeated runs of the
<a class="reference internal" href="inference.html#graph_tool.inference.nested_blockmodel.NestedBlockState.mcmc_sweep" title="graph_tool.inference.nested_blockmodel.NestedBlockState.mcmc_sweep"><code class="xref py py-meth docutils literal notranslate"><span class="pre">graph_tool.inference.nested_blockmodel.NestedBlockState.mcmc_sweep()</span></code></a> function.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>h</strong> : <a class="reference internal" href="inference.html#graph_tool.inference.blockmodel.PartitionHist" title="graph_tool.inference.blockmodel.PartitionHist"><code class="xref py py-class docutils literal notranslate"><span class="pre">PartitionHist</span></code></a> (optional, default: <code class="docutils literal notranslate"><span class="pre">None</span></code>)</p>
<blockquote>
<div><p>Partition histogram. If not provided, an empty histogram will be created.</p>
</div></blockquote>
<p><strong>update</strong> : float (optional, default: <code class="docutils literal notranslate"><span class="pre">1</span></code>)</p>
<blockquote>
<div><p>Each call increases the current count by the amount given by this
parameter.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>h</strong> : <a class="reference internal" href="inference.html#graph_tool.inference.blockmodel.PartitionHist" title="graph_tool.inference.blockmodel.PartitionHist"><code class="xref py py-class docutils literal notranslate"><span class="pre">PartitionHist</span></code></a> (optional, default: <code class="docutils literal notranslate"><span class="pre">None</span></code>)</p>
<blockquote class="last">
<div><p>Updated Partition histogram.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="graph_tool.inference.nested_blockmodel.NestedBlockState.draw">
<code class="descname">draw</code><span class="sig-paren">(</span><em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="http://graph-tool.skewed.de/static/doc/_modules/graph_tool/inference/nested_blockmodel.html#NestedBlockState.draw"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="inference.html#graph_tool.inference.nested_blockmodel.NestedBlockState.draw" title="Permalink to this definition">¶</a></dt>
<dd><p>Convenience wrapper to <a class="reference internal" href="draw.html#graph_tool.draw.draw_hierarchy" title="graph_tool.draw.draw_hierarchy"><code class="xref py py-func docutils literal notranslate"><span class="pre">draw_hierarchy()</span></code></a> that
draws the hierarchical state.</p>
</dd></dl>

</dd></dl>

<dl class="function">
<dt id="graph_tool.inference.nested_blockmodel.hierarchy_minimize">
<code class="descclassname">graph_tool.inference.nested_blockmodel.</code><code class="descname">hierarchy_minimize</code><span class="sig-paren">(</span><em>state</em>, <em>B_min=None</em>, <em>B_max=None</em>, <em>b_min=None</em>, <em>b_max=None</em>, <em>frozen_levels=None</em>, <em>bisection_args={}</em>, <em>epsilon=1e-08</em>, <em>verbose=False</em><span class="sig-paren">)</span><a class="reference internal" href="http://graph-tool.skewed.de/static/doc/_modules/graph_tool/inference/nested_blockmodel.html#hierarchy_minimize"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="inference.html#graph_tool.inference.nested_blockmodel.hierarchy_minimize" title="Permalink to this definition">¶</a></dt>
<dd><p>Attempt to find a fit of the nested stochastic block model that minimizes the
description length.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>state</strong> : <a class="reference internal" href="inference.html#graph_tool.inference.nested_blockmodel.NestedBlockState" title="graph_tool.inference.nested_blockmodel.NestedBlockState"><code class="xref py py-class docutils literal notranslate"><span class="pre">NestedBlockState</span></code></a></p>
<blockquote>
<div><p>The nested block state.</p>
</div></blockquote>
<p><strong>B_min</strong> : <code class="docutils literal notranslate"><span class="pre">int</span></code> (optional, default: <code class="docutils literal notranslate"><span class="pre">None</span></code>)</p>
<blockquote>
<div><p>The minimum number of blocks.</p>
</div></blockquote>
<p><strong>B_max</strong> : <code class="docutils literal notranslate"><span class="pre">int</span></code> (optional, default: <code class="docutils literal notranslate"><span class="pre">None</span></code>)</p>
<blockquote>
<div><p>The maximum number of blocks.</p>
</div></blockquote>
<p><strong>b_min</strong> : <a class="reference internal" href="graph_tool.html#graph_tool.PropertyMap" title="graph_tool.PropertyMap"><code class="xref py py-class docutils literal notranslate"><span class="pre">PropertyMap</span></code></a> (optional, default: <code class="docutils literal notranslate"><span class="pre">None</span></code>)</p>
<blockquote>
<div><p>The partition to be used with the minimum number of blocks.</p>
</div></blockquote>
<p><strong>b_max</strong> : <a class="reference internal" href="graph_tool.html#graph_tool.PropertyMap" title="graph_tool.PropertyMap"><code class="xref py py-class docutils literal notranslate"><span class="pre">PropertyMap</span></code></a> (optional, default: <code class="docutils literal notranslate"><span class="pre">None</span></code>)</p>
<blockquote>
<div><p>The partition to be used with the maximum number of blocks.</p>
</div></blockquote>
<p><strong>frozen_levels</strong> : sequence of <code class="docutils literal notranslate"><span class="pre">int</span></code> values (optional, default: <code class="docutils literal notranslate"><span class="pre">None</span></code>)</p>
<blockquote>
<div><p>List of hierarchy levels that are kept constant during the minimization.</p>
</div></blockquote>
<p><strong>bisection_args</strong> : <code class="docutils literal notranslate"><span class="pre">dict</span></code> (optional, default: <code class="docutils literal notranslate"><span class="pre">{}</span></code>)</p>
<blockquote>
<div><p>Arguments to be passed to <a class="reference internal" href="inference.html#graph_tool.inference.bisection.bisection_minimize" title="graph_tool.inference.bisection.bisection_minimize"><code class="xref py py-func docutils literal notranslate"><span class="pre">bisection_minimize()</span></code></a>.</p>
</div></blockquote>
<p><strong>epsilon: ``float`` (optional, default: ``1e-8``)</strong></p>
<blockquote>
<div><p>Only replace levels if the description length difference is above this
threshold.</p>
</div></blockquote>
<p><strong>verbose</strong> : <code class="docutils literal notranslate"><span class="pre">bool</span></code> or <code class="docutils literal notranslate"><span class="pre">tuple</span></code> (optional, default: <code class="docutils literal notranslate"><span class="pre">False</span></code>)</p>
<blockquote>
<div><p>If <code class="docutils literal notranslate"><span class="pre">True</span></code>, progress information will be shown. Optionally, this
accepts arguments of the type <code class="docutils literal notranslate"><span class="pre">tuple</span></code> of the form <code class="docutils literal notranslate"><span class="pre">(level,</span> <span class="pre">prefix)</span></code>
where <code class="docutils literal notranslate"><span class="pre">level</span></code> is a positive integer that specifies the level of
detail, and <code class="docutils literal notranslate"><span class="pre">prefix</span></code> is a string that is prepended to the all output
messages.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>min_state</strong> : <a class="reference internal" href="inference.html#graph_tool.inference.nested_blockmodel.NestedBlockState" title="graph_tool.inference.nested_blockmodel.NestedBlockState"><code class="xref py py-class docutils literal notranslate"><span class="pre">NestedBlockState</span></code></a></p>
<blockquote class="last">
<div><p>Nested state with minimal description length.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>This algorithms moves along the hierarchical levels, attempting to replace,
delete or insert partitions that minimize the description length, until no
further progress is possible.</p>
<p>See <a class="reference internal" href="inference.html#peixoto-hierarchical-2014186" id="id18">[peixoto-hierarchical-2014186]</a> for details on the algorithm.</p>
<p>This algorithm has a complexity of <span class="math">\(O(V \ln^2 V)\)</span>, where <span class="math">\(V\)</span> is
the number of nodes in the network.</p>
<p class="rubric">References</p>
<table class="docutils citation" frame="void" id="peixoto-hierarchical-2014186" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[peixoto-hierarchical-2014186]</td><td><em>(<a class="fn-backref" href="inference.html#id18">1</a>, <a class="fn-backref" href="inference.html#id19">2</a>)</em> Tiago P. Peixoto, “Hierarchical block
structures and high-resolution model selection in large networks “,
Phys. Rev. X 4, 011047 (2014), <a class="reference external" href="https://dx.doi.org/10.1103/PhysRevX.4.011047">DOI: 10.1103/PhysRevX.4.011047</a> [<a class="reference external" href="https://sci-hub.tw/10.1103/PhysRevX.4.011047">sci-hub</a>, <a class="reference external" href="https://scihub22266oqcxt.onion.link/10.1103/PhysRevX.4.011047">&#64;tor</a>],
<a class="reference external" href="https://arxiv.org/abs/1310.4377">arXiv: 1310.4377</a>.</td></tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="graph_tool.inference.nested_blockmodel.get_hierarchy_tree">
<code class="descclassname">graph_tool.inference.nested_blockmodel.</code><code class="descname">get_hierarchy_tree</code><span class="sig-paren">(</span><em>state</em>, <em>empty_branches=True</em><span class="sig-paren">)</span><a class="reference internal" href="http://graph-tool.skewed.de/static/doc/_modules/graph_tool/inference/nested_blockmodel.html#get_hierarchy_tree"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="inference.html#graph_tool.inference.nested_blockmodel.get_hierarchy_tree" title="Permalink to this definition">¶</a></dt>
<dd><p>Obtain the nested hierarchical levels as a tree.</p>
<p>This transforms a <a class="reference internal" href="inference.html#graph_tool.inference.nested_blockmodel.NestedBlockState" title="graph_tool.inference.nested_blockmodel.NestedBlockState"><code class="xref py py-class docutils literal notranslate"><span class="pre">NestedBlockState</span></code></a> instance
into a single <a class="reference internal" href="graph_tool.html#graph_tool.Graph" title="graph_tool.Graph"><code class="xref py py-class docutils literal notranslate"><span class="pre">Graph</span></code></a> instance containing the hierarchy
tree.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>state</strong> : <a class="reference internal" href="inference.html#graph_tool.inference.nested_blockmodel.NestedBlockState" title="graph_tool.inference.nested_blockmodel.NestedBlockState"><code class="xref py py-class docutils literal notranslate"><span class="pre">NestedBlockState</span></code></a></p>
<blockquote>
<div><p>Nested block model state.</p>
</div></blockquote>
<p><strong>empty_branches</strong> : <code class="docutils literal notranslate"><span class="pre">bool</span></code> (optional, default: <code class="docutils literal notranslate"><span class="pre">True</span></code>)</p>
<blockquote>
<div><p>If <code class="docutils literal notranslate"><span class="pre">empty_branches</span> <span class="pre">==</span> <span class="pre">False</span></code>, dangling branches at the upper layers
will be pruned.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>tree</strong> : <a class="reference internal" href="graph_tool.html#graph_tool.Graph" title="graph_tool.Graph"><code class="xref py py-class docutils literal notranslate"><span class="pre">Graph</span></code></a></p>
<blockquote>
<div><p>A directed graph, where vertices are blocks, and a directed edge points
to an upper to a lower level in the hierarchy.</p>
</div></blockquote>
<p><strong>label</strong> : <a class="reference internal" href="graph_tool.html#graph_tool.PropertyMap" title="graph_tool.PropertyMap"><code class="xref py py-class docutils literal notranslate"><span class="pre">PropertyMap</span></code></a></p>
<blockquote>
<div><p>A vertex property map containing the block label for each node.</p>
</div></blockquote>
<p><strong>order</strong> : <a class="reference internal" href="graph_tool.html#graph_tool.PropertyMap" title="graph_tool.PropertyMap"><code class="xref py py-class docutils literal notranslate"><span class="pre">PropertyMap</span></code></a></p>
<blockquote class="last">
<div><p>A vertex property map containing the relative ordering of each layer
according to the total degree of the groups at the specific levels.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<span class="target" id="module-graph_tool.inference.uncertain_blockmodel"></span><dl class="class">
<dt id="graph_tool.inference.uncertain_blockmodel.UncertainBaseState">
<em class="property">class </em><code class="descclassname">graph_tool.inference.uncertain_blockmodel.</code><code class="descname">UncertainBaseState</code><span class="sig-paren">(</span><em>g</em>, <em>nested=True</em>, <em>state_args={}</em>, <em>bstate=None</em>, <em>self_loops=False</em>, <em>init_empty=False</em><span class="sig-paren">)</span><a class="reference internal" href="http://graph-tool.skewed.de/static/doc/_modules/graph_tool/inference/uncertain_blockmodel.html#UncertainBaseState"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="inference.html#graph_tool.inference.uncertain_blockmodel.UncertainBaseState" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference external" href="https://docs.python.org/3/library/functions.html#object" title="(in Python v3.7)"><code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></a></p>
<p>Base state for uncertain network inference.</p>
<dl class="method">
<dt id="graph_tool.inference.uncertain_blockmodel.UncertainBaseState.get_block_state">
<code class="descname">get_block_state</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="http://graph-tool.skewed.de/static/doc/_modules/graph_tool/inference/uncertain_blockmodel.html#UncertainBaseState.get_block_state"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="inference.html#graph_tool.inference.uncertain_blockmodel.UncertainBaseState.get_block_state" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the underlying block state, which can be either
<a class="reference internal" href="inference.html#graph_tool.inference.blockmodel.BlockState" title="graph_tool.inference.blockmodel.BlockState"><code class="xref py py-class docutils literal notranslate"><span class="pre">BlockState</span></code></a> or
<a class="reference internal" href="inference.html#graph_tool.inference.nested_blockmodel.NestedBlockState" title="graph_tool.inference.nested_blockmodel.NestedBlockState"><code class="xref py py-class docutils literal notranslate"><span class="pre">NestedBlockState</span></code></a>.</p>
</dd></dl>

<dl class="method">
<dt id="graph_tool.inference.uncertain_blockmodel.UncertainBaseState.entropy">
<code class="descname">entropy</code><span class="sig-paren">(</span><em>latent_edges=True</em>, <em>density=True</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="http://graph-tool.skewed.de/static/doc/_modules/graph_tool/inference/uncertain_blockmodel.html#UncertainBaseState.entropy"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="inference.html#graph_tool.inference.uncertain_blockmodel.UncertainBaseState.entropy" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the entropy, i.e. negative log-likelihood.</p>
</dd></dl>

<dl class="method">
<dt id="graph_tool.inference.uncertain_blockmodel.UncertainBaseState.mcmc_sweep">
<code class="descname">mcmc_sweep</code><span class="sig-paren">(</span><em>r=0.5</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="http://graph-tool.skewed.de/static/doc/_modules/graph_tool/inference/uncertain_blockmodel.html#UncertainBaseState.mcmc_sweep"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="inference.html#graph_tool.inference.uncertain_blockmodel.UncertainBaseState.mcmc_sweep" title="Permalink to this definition">¶</a></dt>
<dd><p>Perform sweeps of a Metropolis-Hastings acceptance-rejection sampling MCMC to
sample network partitions and latent edges. The parameter <code class="docutils literal notranslate"><span class="pre">r`</span></code>
controls the probability with which edge move will be attempted, instead
of partition moves. The remaining keyword parameters will be passed to
<a class="reference internal" href="inference.html#graph_tool.inference.blockmodel.BlockState.mcmc_sweep" title="graph_tool.inference.blockmodel.BlockState.mcmc_sweep"><code class="xref py py-meth docutils literal notranslate"><span class="pre">mcmc_sweep()</span></code></a>.</p>
</dd></dl>

<dl class="method">
<dt id="graph_tool.inference.uncertain_blockmodel.UncertainBaseState.multiflip_mcmc_sweep">
<code class="descname">multiflip_mcmc_sweep</code><span class="sig-paren">(</span><em>r=0.5</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="http://graph-tool.skewed.de/static/doc/_modules/graph_tool/inference/uncertain_blockmodel.html#UncertainBaseState.multiflip_mcmc_sweep"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="inference.html#graph_tool.inference.uncertain_blockmodel.UncertainBaseState.multiflip_mcmc_sweep" title="Permalink to this definition">¶</a></dt>
<dd><p>Perform sweeps of a multiflip Metropolis-Hastings acceptance-rejection
sampling MCMC to sample network partitions and latent edges. The
parameter <code class="docutils literal notranslate"><span class="pre">r`</span></code> controls the probability with which edge move will be
attempted, instead of partition moves. The remaining keyword parameters
will be passed to <a class="reference internal" href="inference.html#graph_tool.inference.blockmodel.BlockState.multiflip_mcmc_sweep" title="graph_tool.inference.blockmodel.BlockState.multiflip_mcmc_sweep"><code class="xref py py-meth docutils literal notranslate"><span class="pre">multiflip_mcmc_sweep()</span></code></a>.</p>
</dd></dl>

<dl class="method">
<dt id="graph_tool.inference.uncertain_blockmodel.UncertainBaseState.get_edge_prob">
<code class="descname">get_edge_prob</code><span class="sig-paren">(</span><em>u</em>, <em>v</em>, <em>entropy_args={}</em>, <em>epsilon=1e-08</em><span class="sig-paren">)</span><a class="reference internal" href="http://graph-tool.skewed.de/static/doc/_modules/graph_tool/inference/uncertain_blockmodel.html#UncertainBaseState.get_edge_prob"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="inference.html#graph_tool.inference.uncertain_blockmodel.UncertainBaseState.get_edge_prob" title="Permalink to this definition">¶</a></dt>
<dd><p>Return conditional posterior probability of edge <span class="math">\((u,v)\)</span>.</p>
</dd></dl>

<dl class="method">
<dt id="graph_tool.inference.uncertain_blockmodel.UncertainBaseState.get_edges_prob">
<code class="descname">get_edges_prob</code><span class="sig-paren">(</span><em>elist</em>, <em>entropy_args={}</em>, <em>epsilon=1e-08</em><span class="sig-paren">)</span><a class="reference internal" href="http://graph-tool.skewed.de/static/doc/_modules/graph_tool/inference/uncertain_blockmodel.html#UncertainBaseState.get_edges_prob"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="inference.html#graph_tool.inference.uncertain_blockmodel.UncertainBaseState.get_edges_prob" title="Permalink to this definition">¶</a></dt>
<dd><p>Return conditional posterior probability of an edge list, with
shape <span class="math">\((E,2)\)</span>.</p>
</dd></dl>

<dl class="method">
<dt id="graph_tool.inference.uncertain_blockmodel.UncertainBaseState.get_graph">
<code class="descname">get_graph</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="http://graph-tool.skewed.de/static/doc/_modules/graph_tool/inference/uncertain_blockmodel.html#UncertainBaseState.get_graph"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="inference.html#graph_tool.inference.uncertain_blockmodel.UncertainBaseState.get_graph" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the current inferred graph.</p>
</dd></dl>

<dl class="method">
<dt id="graph_tool.inference.uncertain_blockmodel.UncertainBaseState.collect_marginal">
<code class="descname">collect_marginal</code><span class="sig-paren">(</span><em>g=None</em><span class="sig-paren">)</span><a class="reference internal" href="http://graph-tool.skewed.de/static/doc/_modules/graph_tool/inference/uncertain_blockmodel.html#UncertainBaseState.collect_marginal"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="inference.html#graph_tool.inference.uncertain_blockmodel.UncertainBaseState.collect_marginal" title="Permalink to this definition">¶</a></dt>
<dd><p>Collect marginal inferred network during MCMC runs.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>g</strong> : <a class="reference internal" href="graph_tool.html#graph_tool.Graph" title="graph_tool.Graph"><code class="xref py py-class docutils literal notranslate"><span class="pre">Graph</span></code></a> (optional, default: <code class="docutils literal notranslate"><span class="pre">None</span></code>)</p>
<blockquote>
<div><p>Previous marginal graph.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>g</strong> : <a class="reference internal" href="graph_tool.html#graph_tool.Graph" title="graph_tool.Graph"><code class="xref py py-class docutils literal notranslate"><span class="pre">Graph</span></code></a></p>
<blockquote class="last">
<div><p>New marginal graph, with internal edge <a class="reference internal" href="graph_tool.html#graph_tool.PropertyMap" title="graph_tool.PropertyMap"><code class="xref py py-class docutils literal notranslate"><span class="pre">PropertyMap</span></code></a>
<code class="docutils literal notranslate"><span class="pre">&quot;eprob&quot;</span></code>, containing the marginal probabilities for each edge.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>The posterior marginal probability of an edge <span class="math">\((i,j)\)</span> is defined as</p>
<div class="math">
\[\pi_{ij} = \sum_{\boldsymbol A}A_{ij}P(\boldsymbol A|\boldsymbol D)\]</div>
<p>where <span class="math">\(P(\boldsymbol A|\boldsymbol D)\)</span> is the posterior
probability given the data.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="graph_tool.inference.uncertain_blockmodel.UncertainBlockState">
<em class="property">class </em><code class="descclassname">graph_tool.inference.uncertain_blockmodel.</code><code class="descname">UncertainBlockState</code><span class="sig-paren">(</span><em>g</em>, <em>q</em>, <em>q_default=0.0</em>, <em>aE=nan</em>, <em>nested=True</em>, <em>state_args={}</em>, <em>bstate=None</em>, <em>self_loops=False</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="http://graph-tool.skewed.de/static/doc/_modules/graph_tool/inference/uncertain_blockmodel.html#UncertainBlockState"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="inference.html#graph_tool.inference.uncertain_blockmodel.UncertainBlockState" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="inference.html#graph_tool.inference.uncertain_blockmodel.UncertainBaseState" title="graph_tool.inference.uncertain_blockmodel.UncertainBaseState"><code class="xref py py-class docutils literal notranslate"><span class="pre">graph_tool.inference.uncertain_blockmodel.UncertainBaseState</span></code></a></p>
<p>The inference state of an uncertain graph, using the stochastic block model
as a prior.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>g</strong> : <a class="reference internal" href="graph_tool.html#graph_tool.Graph" title="graph_tool.Graph"><code class="xref py py-class docutils literal notranslate"><span class="pre">Graph</span></code></a></p>
<blockquote>
<div><p>Measured graph.</p>
</div></blockquote>
<p><strong>q</strong> : <a class="reference internal" href="graph_tool.html#graph_tool.PropertyMap" title="graph_tool.PropertyMap"><code class="xref py py-class docutils literal notranslate"><span class="pre">PropertyMap</span></code></a></p>
<blockquote>
<div><p>Edge probabilities in range <span class="math">\([0,1]\)</span>.</p>
</div></blockquote>
<p><strong>q_default</strong> : <code class="docutils literal notranslate"><span class="pre">float</span></code> (optional, default: <code class="docutils literal notranslate"><span class="pre">0.</span></code>)</p>
<blockquote>
<div><p>Non-edge probability in range <span class="math">\([0,1]\)</span>.</p>
</div></blockquote>
<p><strong>aE</strong> : <code class="docutils literal notranslate"><span class="pre">float</span></code> (optional, default: <code class="docutils literal notranslate"><span class="pre">NaN</span></code>)</p>
<blockquote>
<div><p>Expected total number of edges used in prior. If <code class="docutils literal notranslate"><span class="pre">NaN</span></code>, a flat
prior will be used instead.</p>
</div></blockquote>
<p><strong>nested</strong> : <code class="docutils literal notranslate"><span class="pre">boolean</span></code> (optional, default: <code class="docutils literal notranslate"><span class="pre">True</span></code>)</p>
<blockquote>
<div><p>If <code class="docutils literal notranslate"><span class="pre">True</span></code>, a <a class="reference internal" href="inference.html#graph_tool.inference.nested_blockmodel.NestedBlockState" title="graph_tool.inference.nested_blockmodel.NestedBlockState"><code class="xref py py-class docutils literal notranslate"><span class="pre">NestedBlockState</span></code></a>
will be used, otherwise
<a class="reference internal" href="inference.html#graph_tool.inference.blockmodel.BlockState" title="graph_tool.inference.blockmodel.BlockState"><code class="xref py py-class docutils literal notranslate"><span class="pre">BlockState</span></code></a>.</p>
</div></blockquote>
<p><strong>state_args</strong> : <code class="docutils literal notranslate"><span class="pre">dict</span></code> (optional, default: <code class="docutils literal notranslate"><span class="pre">{}</span></code>)</p>
<blockquote>
<div><p>Arguments to be passed to
<a class="reference internal" href="inference.html#graph_tool.inference.nested_blockmodel.NestedBlockState" title="graph_tool.inference.nested_blockmodel.NestedBlockState"><code class="xref py py-class docutils literal notranslate"><span class="pre">NestedBlockState</span></code></a> or
<a class="reference internal" href="inference.html#graph_tool.inference.blockmodel.BlockState" title="graph_tool.inference.blockmodel.BlockState"><code class="xref py py-class docutils literal notranslate"><span class="pre">BlockState</span></code></a>.</p>
</div></blockquote>
<p><strong>bstate</strong> : <a class="reference internal" href="inference.html#graph_tool.inference.nested_blockmodel.NestedBlockState" title="graph_tool.inference.nested_blockmodel.NestedBlockState"><code class="xref py py-class docutils literal notranslate"><span class="pre">NestedBlockState</span></code></a> or <a class="reference internal" href="inference.html#graph_tool.inference.blockmodel.BlockState" title="graph_tool.inference.blockmodel.BlockState"><code class="xref py py-class docutils literal notranslate"><span class="pre">BlockState</span></code></a>  (optional, default: <code class="docutils literal notranslate"><span class="pre">None</span></code>)</p>
<blockquote>
<div><p>If passed, this will be used to initialize the block state
directly.</p>
</div></blockquote>
<p><strong>self_loops</strong> : bool (optional, default: <code class="docutils literal notranslate"><span class="pre">False</span></code>)</p>
<blockquote class="last">
<div><p>If <code class="docutils literal notranslate"><span class="pre">True</span></code>, it is assumed that the uncertain graph can contain
self-loops.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">References</p>
<table class="docutils citation" frame="void" id="peixoto-reconstructing-2018187" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="inference.html#id20">[peixoto-reconstructing-2018187]</a></td><td>Tiago P. Peixoto, “Reconstructing networks
with unknown and heterogeneous errors” <a class="reference external" href="https://arxiv.org/abs/1806.07956">arXiv: 1806.07956</a></td></tr>
</tbody>
</table>
<dl class="method">
<dt id="graph_tool.inference.uncertain_blockmodel.UncertainBlockState.copy">
<code class="descname">copy</code><span class="sig-paren">(</span><em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="http://graph-tool.skewed.de/static/doc/_modules/graph_tool/inference/uncertain_blockmodel.html#UncertainBlockState.copy"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="inference.html#graph_tool.inference.uncertain_blockmodel.UncertainBlockState.copy" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a copy of the state.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="graph_tool.inference.uncertain_blockmodel.MeasuredBlockState">
<em class="property">class </em><code class="descclassname">graph_tool.inference.uncertain_blockmodel.</code><code class="descname">MeasuredBlockState</code><span class="sig-paren">(</span><em>g</em>, <em>n</em>, <em>x</em>, <em>n_default=1</em>, <em>x_default=0</em>, <em>fn_params={'alpha': 1</em>, <em>'beta': 1}</em>, <em>fp_params={'mu': 1</em>, <em>'nu': 1}</em>, <em>aE=nan</em>, <em>nested=True</em>, <em>state_args={}</em>, <em>bstate=None</em>, <em>self_loops=False</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="http://graph-tool.skewed.de/static/doc/_modules/graph_tool/inference/uncertain_blockmodel.html#MeasuredBlockState"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="inference.html#graph_tool.inference.uncertain_blockmodel.MeasuredBlockState" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="inference.html#graph_tool.inference.uncertain_blockmodel.UncertainBaseState" title="graph_tool.inference.uncertain_blockmodel.UncertainBaseState"><code class="xref py py-class docutils literal notranslate"><span class="pre">graph_tool.inference.uncertain_blockmodel.UncertainBaseState</span></code></a></p>
<p>The inference state of a measured graph, using the stochastic block model as
a prior.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>g</strong> : <a class="reference internal" href="graph_tool.html#graph_tool.Graph" title="graph_tool.Graph"><code class="xref py py-class docutils literal notranslate"><span class="pre">Graph</span></code></a></p>
<blockquote>
<div><p>Measured graph.</p>
</div></blockquote>
<p><strong>n</strong> : <a class="reference internal" href="graph_tool.html#graph_tool.PropertyMap" title="graph_tool.PropertyMap"><code class="xref py py-class docutils literal notranslate"><span class="pre">PropertyMap</span></code></a></p>
<blockquote>
<div><p>Edge property map of type <code class="docutils literal notranslate"><span class="pre">int</span></code>, containing the total number of
measurements for each edge.</p>
</div></blockquote>
<p><strong>x</strong> : <a class="reference internal" href="graph_tool.html#graph_tool.PropertyMap" title="graph_tool.PropertyMap"><code class="xref py py-class docutils literal notranslate"><span class="pre">PropertyMap</span></code></a></p>
<blockquote>
<div><p>Edge property map of type <code class="docutils literal notranslate"><span class="pre">int</span></code>, containing the number of
positive measurements for each edge.</p>
</div></blockquote>
<p><strong>n_default</strong> : <code class="docutils literal notranslate"><span class="pre">int</span></code> (optional, default: <code class="docutils literal notranslate"><span class="pre">1</span></code>)</p>
<blockquote>
<div><p>Total number of measurements for each non-edge.</p>
</div></blockquote>
<p><strong>x_default</strong> : <code class="docutils literal notranslate"><span class="pre">int</span></code> (optional, default: <code class="docutils literal notranslate"><span class="pre">1</span></code>)</p>
<blockquote>
<div><p>Total number of positive measurements for each non-edge.</p>
</div></blockquote>
<p><strong>fn_params</strong> : <code class="docutils literal notranslate"><span class="pre">dict</span></code> (optional, default: <code class="docutils literal notranslate"><span class="pre">dict(alpha=1,</span> <span class="pre">beta=1)</span></code>)</p>
<blockquote>
<div><p>Beta distribution hyperparameters for the probability of missing
edges (false negatives).</p>
</div></blockquote>
<p><strong>fp_params</strong> : <code class="docutils literal notranslate"><span class="pre">dict</span></code> (optional, default: <code class="docutils literal notranslate"><span class="pre">dict(mu=1,</span> <span class="pre">nu=1)</span></code>)</p>
<blockquote>
<div><p>Beta distribution hyperparameters for the probability of spurious
edges (false positives).</p>
</div></blockquote>
<p><strong>aE</strong> : <code class="docutils literal notranslate"><span class="pre">float</span></code> (optional, default: <code class="docutils literal notranslate"><span class="pre">NaN</span></code>)</p>
<blockquote>
<div><p>Expected total number of edges used in prior. If <code class="docutils literal notranslate"><span class="pre">NaN</span></code>, a flat
prior will be used instead.</p>
</div></blockquote>
<p><strong>nested</strong> : <code class="docutils literal notranslate"><span class="pre">boolean</span></code> (optional, default: <code class="docutils literal notranslate"><span class="pre">True</span></code>)</p>
<blockquote>
<div><p>If <code class="docutils literal notranslate"><span class="pre">True</span></code>, a <a class="reference internal" href="inference.html#graph_tool.inference.nested_blockmodel.NestedBlockState" title="graph_tool.inference.nested_blockmodel.NestedBlockState"><code class="xref py py-class docutils literal notranslate"><span class="pre">NestedBlockState</span></code></a>
will be used, otherwise
<a class="reference internal" href="inference.html#graph_tool.inference.blockmodel.BlockState" title="graph_tool.inference.blockmodel.BlockState"><code class="xref py py-class docutils literal notranslate"><span class="pre">BlockState</span></code></a>.</p>
</div></blockquote>
<p><strong>state_args</strong> : <code class="docutils literal notranslate"><span class="pre">dict</span></code> (optional, default: <code class="docutils literal notranslate"><span class="pre">{}</span></code>)</p>
<blockquote>
<div><p>Arguments to be passed to
<a class="reference internal" href="inference.html#graph_tool.inference.nested_blockmodel.NestedBlockState" title="graph_tool.inference.nested_blockmodel.NestedBlockState"><code class="xref py py-class docutils literal notranslate"><span class="pre">NestedBlockState</span></code></a> or
<a class="reference internal" href="inference.html#graph_tool.inference.blockmodel.BlockState" title="graph_tool.inference.blockmodel.BlockState"><code class="xref py py-class docutils literal notranslate"><span class="pre">BlockState</span></code></a>.</p>
</div></blockquote>
<p><strong>bstate</strong> : <a class="reference internal" href="inference.html#graph_tool.inference.nested_blockmodel.NestedBlockState" title="graph_tool.inference.nested_blockmodel.NestedBlockState"><code class="xref py py-class docutils literal notranslate"><span class="pre">NestedBlockState</span></code></a> or <a class="reference internal" href="inference.html#graph_tool.inference.blockmodel.BlockState" title="graph_tool.inference.blockmodel.BlockState"><code class="xref py py-class docutils literal notranslate"><span class="pre">BlockState</span></code></a>  (optional, default: <code class="docutils literal notranslate"><span class="pre">None</span></code>)</p>
<blockquote>
<div><p>If passed, this will be used to initialize the block state
directly.</p>
</div></blockquote>
<p><strong>self_loops</strong> : bool (optional, default: <code class="docutils literal notranslate"><span class="pre">False</span></code>)</p>
<blockquote class="last">
<div><p>If <code class="docutils literal notranslate"><span class="pre">True</span></code>, it is assumed that the uncertain graph can contain
self-loops.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">References</p>
<table class="docutils citation" frame="void" id="peixoto-reconstructing-2018188" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="inference.html#id21">[peixoto-reconstructing-2018188]</a></td><td>Tiago P. Peixoto, “Reconstructing networks
with unknown and heterogeneous errors” <a class="reference external" href="https://arxiv.org/abs/1806.07956">arXiv: 1806.07956</a></td></tr>
</tbody>
</table>
<dl class="method">
<dt id="graph_tool.inference.uncertain_blockmodel.MeasuredBlockState.copy">
<code class="descname">copy</code><span class="sig-paren">(</span><em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="http://graph-tool.skewed.de/static/doc/_modules/graph_tool/inference/uncertain_blockmodel.html#MeasuredBlockState.copy"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="inference.html#graph_tool.inference.uncertain_blockmodel.MeasuredBlockState.copy" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a copy of the state.</p>
</dd></dl>

<dl class="method">
<dt id="graph_tool.inference.uncertain_blockmodel.MeasuredBlockState.set_hparams">
<code class="descname">set_hparams</code><span class="sig-paren">(</span><em>alpha</em>, <em>beta</em>, <em>mu</em>, <em>nu</em><span class="sig-paren">)</span><a class="reference internal" href="http://graph-tool.skewed.de/static/doc/_modules/graph_tool/inference/uncertain_blockmodel.html#MeasuredBlockState.set_hparams"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="inference.html#graph_tool.inference.uncertain_blockmodel.MeasuredBlockState.set_hparams" title="Permalink to this definition">¶</a></dt>
<dd><p>Set edge and non-edge hyperparameters.</p>
</dd></dl>

<dl class="method">
<dt id="graph_tool.inference.uncertain_blockmodel.MeasuredBlockState.get_p_posterior">
<code class="descname">get_p_posterior</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="http://graph-tool.skewed.de/static/doc/_modules/graph_tool/inference/uncertain_blockmodel.html#MeasuredBlockState.get_p_posterior"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="inference.html#graph_tool.inference.uncertain_blockmodel.MeasuredBlockState.get_p_posterior" title="Permalink to this definition">¶</a></dt>
<dd><p>Get beta distribution parameters for the posterior probability of missing edges.</p>
</dd></dl>

<dl class="method">
<dt id="graph_tool.inference.uncertain_blockmodel.MeasuredBlockState.get_q_posterior">
<code class="descname">get_q_posterior</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="http://graph-tool.skewed.de/static/doc/_modules/graph_tool/inference/uncertain_blockmodel.html#MeasuredBlockState.get_q_posterior"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="inference.html#graph_tool.inference.uncertain_blockmodel.MeasuredBlockState.get_q_posterior" title="Permalink to this definition">¶</a></dt>
<dd><p>Get beta distribution parameters for the posterior probability of spurious edges.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="graph_tool.inference.uncertain_blockmodel.MixedMeasuredBlockState">
<em class="property">class </em><code class="descclassname">graph_tool.inference.uncertain_blockmodel.</code><code class="descname">MixedMeasuredBlockState</code><span class="sig-paren">(</span><em>g</em>, <em>n</em>, <em>x</em>, <em>n_default=1</em>, <em>x_default=0</em>, <em>fn_params={'alpha': 1</em>, <em>'beta': 10}</em>, <em>fp_params={'mu': 1</em>, <em>'nu': 10}</em>, <em>aE=nan</em>, <em>nested=True</em>, <em>state_args={}</em>, <em>bstate=None</em>, <em>self_loops=False</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="http://graph-tool.skewed.de/static/doc/_modules/graph_tool/inference/uncertain_blockmodel.html#MixedMeasuredBlockState"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="inference.html#graph_tool.inference.uncertain_blockmodel.MixedMeasuredBlockState" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="inference.html#graph_tool.inference.uncertain_blockmodel.UncertainBaseState" title="graph_tool.inference.uncertain_blockmodel.UncertainBaseState"><code class="xref py py-class docutils literal notranslate"><span class="pre">graph_tool.inference.uncertain_blockmodel.UncertainBaseState</span></code></a></p>
<p>The inference state of a measured graph with heterogeneous errors, using the
stochastic block model as a prior.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>g</strong> : <a class="reference internal" href="graph_tool.html#graph_tool.Graph" title="graph_tool.Graph"><code class="xref py py-class docutils literal notranslate"><span class="pre">Graph</span></code></a></p>
<blockquote>
<div><p>Measured graph.</p>
</div></blockquote>
<p><strong>n</strong> : <a class="reference internal" href="graph_tool.html#graph_tool.PropertyMap" title="graph_tool.PropertyMap"><code class="xref py py-class docutils literal notranslate"><span class="pre">PropertyMap</span></code></a></p>
<blockquote>
<div><p>Edge property map of type <code class="docutils literal notranslate"><span class="pre">int</span></code>, containing the total number of
measurements for each edge.</p>
</div></blockquote>
<p><strong>x</strong> : <a class="reference internal" href="graph_tool.html#graph_tool.PropertyMap" title="graph_tool.PropertyMap"><code class="xref py py-class docutils literal notranslate"><span class="pre">PropertyMap</span></code></a></p>
<blockquote>
<div><p>Edge property map of type <code class="docutils literal notranslate"><span class="pre">int</span></code>, containing the number of
positive measurements for each edge.</p>
</div></blockquote>
<p><strong>n_default</strong> : <code class="docutils literal notranslate"><span class="pre">int</span></code> (optional, default: <code class="docutils literal notranslate"><span class="pre">1</span></code>)</p>
<blockquote>
<div><p>Total number of measurements for each non-edge.</p>
</div></blockquote>
<p><strong>x_default</strong> : <code class="docutils literal notranslate"><span class="pre">int</span></code> (optional, default: <code class="docutils literal notranslate"><span class="pre">1</span></code>)</p>
<blockquote>
<div><p>Total number of positive measurements for each non-edge.</p>
</div></blockquote>
<p><strong>fn_params</strong> : <code class="docutils literal notranslate"><span class="pre">dict</span></code> (optional, default: <code class="docutils literal notranslate"><span class="pre">dict(alpha=1,</span> <span class="pre">beta=10)</span></code>)</p>
<blockquote>
<div><p>Beta distribution hyperparameters for the probability of missing
edges (false negatives).</p>
</div></blockquote>
<p><strong>fp_params</strong> : <code class="docutils literal notranslate"><span class="pre">dict</span></code> (optional, default: <code class="docutils literal notranslate"><span class="pre">dict(mu=1,</span> <span class="pre">nu=10)</span></code>)</p>
<blockquote>
<div><p>Beta distribution hyperparameters for the probability of spurious
edges (false positives).</p>
</div></blockquote>
<p><strong>aE</strong> : <code class="docutils literal notranslate"><span class="pre">float</span></code> (optional, default: <code class="docutils literal notranslate"><span class="pre">NaN</span></code>)</p>
<blockquote>
<div><p>Expected total number of edges used in prior. If <code class="docutils literal notranslate"><span class="pre">NaN</span></code>, a flat
prior will be used instead.</p>
</div></blockquote>
<p><strong>nested</strong> : <code class="docutils literal notranslate"><span class="pre">boolean</span></code> (optional, default: <code class="docutils literal notranslate"><span class="pre">True</span></code>)</p>
<blockquote>
<div><p>If <code class="docutils literal notranslate"><span class="pre">True</span></code>, a <a class="reference internal" href="inference.html#graph_tool.inference.nested_blockmodel.NestedBlockState" title="graph_tool.inference.nested_blockmodel.NestedBlockState"><code class="xref py py-class docutils literal notranslate"><span class="pre">NestedBlockState</span></code></a>
will be used, otherwise
<a class="reference internal" href="inference.html#graph_tool.inference.blockmodel.BlockState" title="graph_tool.inference.blockmodel.BlockState"><code class="xref py py-class docutils literal notranslate"><span class="pre">BlockState</span></code></a>.</p>
</div></blockquote>
<p><strong>state_args</strong> : <code class="docutils literal notranslate"><span class="pre">dict</span></code> (optional, default: <code class="docutils literal notranslate"><span class="pre">{}</span></code>)</p>
<blockquote>
<div><p>Arguments to be passed to
<a class="reference internal" href="inference.html#graph_tool.inference.nested_blockmodel.NestedBlockState" title="graph_tool.inference.nested_blockmodel.NestedBlockState"><code class="xref py py-class docutils literal notranslate"><span class="pre">NestedBlockState</span></code></a> or
<a class="reference internal" href="inference.html#graph_tool.inference.blockmodel.BlockState" title="graph_tool.inference.blockmodel.BlockState"><code class="xref py py-class docutils literal notranslate"><span class="pre">BlockState</span></code></a>.</p>
</div></blockquote>
<p><strong>bstate</strong> : <a class="reference internal" href="inference.html#graph_tool.inference.nested_blockmodel.NestedBlockState" title="graph_tool.inference.nested_blockmodel.NestedBlockState"><code class="xref py py-class docutils literal notranslate"><span class="pre">NestedBlockState</span></code></a> or <a class="reference internal" href="inference.html#graph_tool.inference.blockmodel.BlockState" title="graph_tool.inference.blockmodel.BlockState"><code class="xref py py-class docutils literal notranslate"><span class="pre">BlockState</span></code></a>  (optional, default: <code class="docutils literal notranslate"><span class="pre">None</span></code>)</p>
<blockquote>
<div><p>If passed, this will be used to initialize the block state
directly.</p>
</div></blockquote>
<p><strong>self_loops</strong> : bool (optional, default: <code class="docutils literal notranslate"><span class="pre">False</span></code>)</p>
<blockquote class="last">
<div><p>If <code class="docutils literal notranslate"><span class="pre">True</span></code>, it is assumed that the uncertain graph can contain
self-loops.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">References</p>
<table class="docutils citation" frame="void" id="peixoto-reconstructing-2018189" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="inference.html#id22">[peixoto-reconstructing-2018189]</a></td><td>Tiago P. Peixoto, “Reconstructing networks
with unknown and heterogeneous errors” <a class="reference external" href="https://arxiv.org/abs/1806.07956">arXiv: 1806.07956</a></td></tr>
</tbody>
</table>
<dl class="method">
<dt id="graph_tool.inference.uncertain_blockmodel.MixedMeasuredBlockState.set_hparams">
<code class="descname">set_hparams</code><span class="sig-paren">(</span><em>alpha</em>, <em>beta</em>, <em>mu</em>, <em>nu</em><span class="sig-paren">)</span><a class="reference internal" href="http://graph-tool.skewed.de/static/doc/_modules/graph_tool/inference/uncertain_blockmodel.html#MixedMeasuredBlockState.set_hparams"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="inference.html#graph_tool.inference.uncertain_blockmodel.MixedMeasuredBlockState.set_hparams" title="Permalink to this definition">¶</a></dt>
<dd><p>Set edge and non-edge hyperparameters.</p>
</dd></dl>

<dl class="method">
<dt id="graph_tool.inference.uncertain_blockmodel.MixedMeasuredBlockState.copy">
<code class="descname">copy</code><span class="sig-paren">(</span><em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="http://graph-tool.skewed.de/static/doc/_modules/graph_tool/inference/uncertain_blockmodel.html#MixedMeasuredBlockState.copy"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="inference.html#graph_tool.inference.uncertain_blockmodel.MixedMeasuredBlockState.copy" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a copy of the state.</p>
</dd></dl>

</dd></dl>

<span class="target" id="module-graph_tool.inference.mcmc"></span><dl class="function">
<dt id="graph_tool.inference.mcmc.mcmc_equilibrate">
<code class="descclassname">graph_tool.inference.mcmc.</code><code class="descname">mcmc_equilibrate</code><span class="sig-paren">(</span><em>state</em>, <em>wait=1000</em>, <em>nbreaks=2</em>, <em>max_niter=inf</em>, <em>force_niter=None</em>, <em>epsilon=0</em>, <em>gibbs=False</em>, <em>multiflip=False</em>, <em>mcmc_args={}</em>, <em>entropy_args={}</em>, <em>history=False</em>, <em>callback=None</em>, <em>verbose=False</em><span class="sig-paren">)</span><a class="reference internal" href="http://graph-tool.skewed.de/static/doc/_modules/graph_tool/inference/mcmc.html#mcmc_equilibrate"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="inference.html#graph_tool.inference.mcmc.mcmc_equilibrate" title="Permalink to this definition">¶</a></dt>
<dd><p>Equilibrate a MCMC with a given starting state.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>state</strong> : Any state class (e.g. <a class="reference internal" href="inference.html#graph_tool.inference.blockmodel.BlockState" title="graph_tool.inference.blockmodel.BlockState"><code class="xref py py-class docutils literal notranslate"><span class="pre">BlockState</span></code></a>)</p>
<blockquote>
<div><p>Initial state. This state will be modified during the algorithm.</p>
</div></blockquote>
<p><strong>wait</strong> : <code class="docutils literal notranslate"><span class="pre">int</span></code> (optional, default: <code class="docutils literal notranslate"><span class="pre">1000</span></code>)</p>
<blockquote>
<div><p>Number of iterations to wait for a record-breaking event.</p>
</div></blockquote>
<p><strong>nbreaks</strong> : <code class="docutils literal notranslate"><span class="pre">int</span></code> (optional, default: <code class="docutils literal notranslate"><span class="pre">2</span></code>)</p>
<blockquote>
<div><p>Number of iteration intervals (of size <code class="docutils literal notranslate"><span class="pre">wait</span></code>) without record-breaking
events necessary to stop the algorithm.</p>
</div></blockquote>
<p><strong>max_niter</strong> : <code class="docutils literal notranslate"><span class="pre">int</span></code> (optional, default: <code class="docutils literal notranslate"><span class="pre">numpy.inf</span></code>)</p>
<blockquote>
<div><p>Maximum number of iterations.</p>
</div></blockquote>
<p><strong>force_niter</strong> : <code class="docutils literal notranslate"><span class="pre">int</span></code> (optional, default: <code class="docutils literal notranslate"><span class="pre">None</span></code>)</p>
<blockquote>
<div><p>If given, will force the algorithm to run this exact number of
iterations.</p>
</div></blockquote>
<p><strong>epsilon</strong> : <code class="docutils literal notranslate"><span class="pre">float</span></code> (optional, default: <code class="docutils literal notranslate"><span class="pre">0</span></code>)</p>
<blockquote>
<div><p>Relative changes in entropy smaller than epsilon will not be considered
as record-breaking.</p>
</div></blockquote>
<p><strong>gibbs</strong> : <code class="docutils literal notranslate"><span class="pre">bool</span></code> (optional, default: <code class="docutils literal notranslate"><span class="pre">False</span></code>)</p>
<blockquote>
<div><p>If <code class="docutils literal notranslate"><span class="pre">True</span></code>, each step will call <code class="docutils literal notranslate"><span class="pre">state.gibbs_sweep</span></code> instead of
<code class="docutils literal notranslate"><span class="pre">state.mcmc_sweep</span></code>.</p>
</div></blockquote>
<p><strong>multiflip</strong> : <code class="docutils literal notranslate"><span class="pre">bool</span></code> (optional, default: <code class="docutils literal notranslate"><span class="pre">False</span></code>)</p>
<blockquote>
<div><p>If <code class="docutils literal notranslate"><span class="pre">True</span></code>, each step will call <code class="docutils literal notranslate"><span class="pre">state.multiflip_mcmc_sweep</span></code> instead of
<code class="docutils literal notranslate"><span class="pre">state.mcmc_sweep</span></code>.</p>
</div></blockquote>
<p><strong>mcmc_args</strong> : <code class="docutils literal notranslate"><span class="pre">dict</span></code> (optional, default: <code class="docutils literal notranslate"><span class="pre">{}</span></code>)</p>
<blockquote>
<div><p>Arguments to be passed to <code class="docutils literal notranslate"><span class="pre">state.mcmc_sweep</span></code> (or <code class="docutils literal notranslate"><span class="pre">state.gibbs_sweep</span></code>).</p>
</div></blockquote>
<p><strong>history</strong> : <code class="docutils literal notranslate"><span class="pre">bool</span></code> (optional, default: <code class="docutils literal notranslate"><span class="pre">False</span></code>)</p>
<blockquote>
<div><p>If <code class="docutils literal notranslate"><span class="pre">True</span></code>, a list of tuples of the form <code class="docutils literal notranslate"><span class="pre">(nattempts,</span> <span class="pre">nmoves,</span>
<span class="pre">entropy)</span></code> will be kept and returned, where <code class="docutils literal notranslate"><span class="pre">entropy</span></code> is the current
entropy and <code class="docutils literal notranslate"><span class="pre">nmoves</span></code> is the number of vertices moved.</p>
</div></blockquote>
<p><strong>callback</strong> : <code class="docutils literal notranslate"><span class="pre">function</span></code> (optional, default: <code class="docutils literal notranslate"><span class="pre">None</span></code>)</p>
<blockquote>
<div><p>If given, this function will be called after each iteration. The
function must accept the current state as an argument, and its return
value must be either <cite>None</cite> or a (possibly empty) list of values that
will be append to the history, if <code class="docutils literal notranslate"><span class="pre">history</span> <span class="pre">==</span> <span class="pre">True</span></code>.</p>
</div></blockquote>
<p><strong>verbose</strong> : <code class="docutils literal notranslate"><span class="pre">bool</span></code> or <code class="docutils literal notranslate"><span class="pre">tuple</span></code> (optional, default: <code class="docutils literal notranslate"><span class="pre">False</span></code>)</p>
<blockquote>
<div><p>If <code class="docutils literal notranslate"><span class="pre">True</span></code>, progress information will be shown. Optionally, this
accepts arguments of the type <code class="docutils literal notranslate"><span class="pre">tuple</span></code> of the form <code class="docutils literal notranslate"><span class="pre">(level,</span> <span class="pre">prefix)</span></code>
where <code class="docutils literal notranslate"><span class="pre">level</span></code> is a positive integer that specifies the level of
detail, and <code class="docutils literal notranslate"><span class="pre">prefix</span></code> is a string that is prepended to the all output
messages.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>history</strong> : list of tuples of the form <code class="docutils literal notranslate"><span class="pre">(nattempts,</span> <span class="pre">nmoves,</span> <span class="pre">entropy)</span></code></p>
<blockquote>
<div><p>Summary of the MCMC run. This is returned only if <code class="docutils literal notranslate"><span class="pre">history</span> <span class="pre">==</span> <span class="pre">True</span></code>.</p>
</div></blockquote>
<p><strong>entropy</strong> : <code class="docutils literal notranslate"><span class="pre">float</span></code></p>
<blockquote>
<div><p>Current entropy value after run. This is returned only if <code class="docutils literal notranslate"><span class="pre">history</span> <span class="pre">==</span>
<span class="pre">False</span></code>.</p>
</div></blockquote>
<p><strong>nattempts</strong> : <code class="docutils literal notranslate"><span class="pre">int</span></code></p>
<blockquote>
<div><p>Number of node move attempts.</p>
</div></blockquote>
<p><strong>nmoves</strong> : <code class="docutils literal notranslate"><span class="pre">int</span></code></p>
<blockquote class="last">
<div><p>Number of node moves.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>The MCMC equilibration is attempted by keeping track of the maximum and
minimum values, and waiting sufficiently long without a record-breaking
event.</p>
<p>This function calls <code class="docutils literal notranslate"><span class="pre">state.mcmc_sweep</span></code> (or <code class="docutils literal notranslate"><span class="pre">state.gibbs_sweep</span></code>) at each
iteration (e.g. <a class="reference internal" href="inference.html#graph_tool.inference.blockmodel.BlockState.mcmc_sweep" title="graph_tool.inference.blockmodel.BlockState.mcmc_sweep"><code class="xref py py-meth docutils literal notranslate"><span class="pre">graph_tool.inference.blockmodel.BlockState.mcmc_sweep()</span></code></a> and
<a class="reference internal" href="inference.html#graph_tool.inference.blockmodel.BlockState.gibbs_sweep" title="graph_tool.inference.blockmodel.BlockState.gibbs_sweep"><code class="xref py py-meth docutils literal notranslate"><span class="pre">graph_tool.inference.blockmodel.BlockState.gibbs_sweep()</span></code></a>), and keeps track of
the value of <code class="docutils literal notranslate"><span class="pre">state.entropy(**args)</span></code> with <code class="docutils literal notranslate"><span class="pre">args</span></code> corresponding to
<code class="docutils literal notranslate"><span class="pre">mcmc_args[&quot;entropy_args&quot;]</span></code>.</p>
<p class="rubric">References</p>
<table class="docutils citation" frame="void" id="peixoto-efficient-2014190" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="inference.html#id23">[peixoto-efficient-2014190]</a></td><td>Tiago P. Peixoto, “Efficient Monte Carlo and
greedy heuristic for the inference of stochastic block models”, Phys.
Rev. E 89, 012804 (2014), <a class="reference external" href="https://dx.doi.org/10.1103/PhysRevE.89.012804">DOI: 10.1103/PhysRevE.89.012804</a> [<a class="reference external" href="https://sci-hub.tw/10.1103/PhysRevE.89.012804">sci-hub</a>, <a class="reference external" href="https://scihub22266oqcxt.onion.link/10.1103/PhysRevE.89.012804">&#64;tor</a>],
<a class="reference external" href="https://arxiv.org/abs/1310.4378">arXiv: 1310.4378</a></td></tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="graph_tool.inference.mcmc.mcmc_anneal">
<code class="descclassname">graph_tool.inference.mcmc.</code><code class="descname">mcmc_anneal</code><span class="sig-paren">(</span><em>state</em>, <em>beta_range=(1.0</em>, <em>10.0)</em>, <em>niter=100</em>, <em>history=False</em>, <em>mcmc_equilibrate_args={}</em>, <em>verbose=False</em><span class="sig-paren">)</span><a class="reference internal" href="http://graph-tool.skewed.de/static/doc/_modules/graph_tool/inference/mcmc.html#mcmc_anneal"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="inference.html#graph_tool.inference.mcmc.mcmc_anneal" title="Permalink to this definition">¶</a></dt>
<dd><p>Equilibrate a MCMC at a specified target temperature by performing simulated
annealing.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>state</strong> : Any state class (e.g. <a class="reference internal" href="inference.html#graph_tool.inference.blockmodel.BlockState" title="graph_tool.inference.blockmodel.BlockState"><code class="xref py py-class docutils literal notranslate"><span class="pre">BlockState</span></code></a>)</p>
<blockquote>
<div><p>Initial state. This state will be modified during the algorithm.</p>
</div></blockquote>
<p><strong>beta_range</strong> : <code class="docutils literal notranslate"><span class="pre">tuple</span></code> of two floats (optional, default: <code class="docutils literal notranslate"><span class="pre">(1.,</span> <span class="pre">10.)</span></code>)</p>
<blockquote>
<div><p>Inverse temperature range.</p>
</div></blockquote>
<p><strong>niter</strong> : <code class="docutils literal notranslate"><span class="pre">int</span></code> (optional, default: <code class="docutils literal notranslate"><span class="pre">100</span></code>)</p>
<blockquote>
<div><p>Number of steps (in logspace) from the starting temperature to the final
one.</p>
</div></blockquote>
<p><strong>history</strong> : <code class="docutils literal notranslate"><span class="pre">bool</span></code> (optional, default: <code class="docutils literal notranslate"><span class="pre">False</span></code>)</p>
<blockquote>
<div><p>If <code class="docutils literal notranslate"><span class="pre">True</span></code>, a list of tuples of the form <code class="docutils literal notranslate"><span class="pre">(nattempts,</span> <span class="pre">nmoves,</span> <span class="pre">beta,</span> <span class="pre">entropy)</span></code></p>
</div></blockquote>
<p><strong>mcmc_equilibrate_args</strong> : <code class="docutils literal notranslate"><span class="pre">dict</span></code> (optional, default: <code class="docutils literal notranslate"><span class="pre">{}</span></code>)</p>
<blockquote>
<div><p>Arguments to be passed to <a class="reference internal" href="inference.html#graph_tool.inference.mcmc.mcmc_equilibrate" title="graph_tool.inference.mcmc.mcmc_equilibrate"><code class="xref py py-func docutils literal notranslate"><span class="pre">mcmc_equilibrate()</span></code></a>.</p>
</div></blockquote>
<p><strong>verbose</strong> : <code class="docutils literal notranslate"><span class="pre">bool</span></code> or <code class="docutils literal notranslate"><span class="pre">tuple</span></code> (optional, default: <code class="docutils literal notranslate"><span class="pre">False</span></code>)</p>
<blockquote>
<div><p>If <code class="docutils literal notranslate"><span class="pre">True</span></code>, progress information will be shown. Optionally, this
accepts arguments of the type <code class="docutils literal notranslate"><span class="pre">tuple</span></code> of the form <code class="docutils literal notranslate"><span class="pre">(level,</span> <span class="pre">prefix)</span></code>
where <code class="docutils literal notranslate"><span class="pre">level</span></code> is a positive integer that specifies the level of
detail, and <code class="docutils literal notranslate"><span class="pre">prefix</span></code> is a string that is prepended to the all output
messages.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>history</strong> : list of tuples of the form <code class="docutils literal notranslate"><span class="pre">(nattempts,</span> <span class="pre">nmoves,</span> <span class="pre">beta,</span> <span class="pre">entropy)</span></code></p>
<blockquote>
<div><p>Summary of the MCMC run. This is returned only if <code class="docutils literal notranslate"><span class="pre">history</span> <span class="pre">==</span> <span class="pre">True</span></code>.</p>
</div></blockquote>
<p><strong>entropy</strong> : <code class="docutils literal notranslate"><span class="pre">float</span></code></p>
<blockquote>
<div><p>Current entropy value after run. This is returned only if <code class="docutils literal notranslate"><span class="pre">history</span> <span class="pre">==</span>
<span class="pre">False</span></code>.</p>
</div></blockquote>
<p><strong>nattempts</strong> : <code class="docutils literal notranslate"><span class="pre">int</span></code></p>
<blockquote>
<div><p>Number of node move attempts.</p>
</div></blockquote>
<p><strong>nmoves</strong> : <code class="docutils literal notranslate"><span class="pre">int</span></code></p>
<blockquote class="last">
<div><p>Number of node moves.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>This algorithm employs exponential cooling, where the value of beta is
multiplied by a constant at each iteration, so that starting from
<cite>beta_range[0]</cite> the value of <cite>beta_range[1]</cite> is reached after <cite>niter</cite>
iterations.</p>
<p>At each iteration, the function
<a class="reference internal" href="inference.html#graph_tool.inference.mcmc.mcmc_equilibrate" title="graph_tool.inference.mcmc.mcmc_equilibrate"><code class="xref py py-func docutils literal notranslate"><span class="pre">mcmc_equilibrate()</span></code></a> is called with the current
value of <cite>beta</cite> (via the <code class="docutils literal notranslate"><span class="pre">mcmc_args</span></code> parameter).</p>
<p class="rubric">References</p>
<table class="docutils citation" frame="void" id="peixoto-efficient-2014191" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="inference.html#id24">[peixoto-efficient-2014191]</a></td><td>Tiago P. Peixoto, “Efficient Monte Carlo and
greedy heuristic for the inference of stochastic block models”, Phys.
Rev. E 89, 012804 (2014), <a class="reference external" href="https://dx.doi.org/10.1103/PhysRevE.89.012804">DOI: 10.1103/PhysRevE.89.012804</a> [<a class="reference external" href="https://sci-hub.tw/10.1103/PhysRevE.89.012804">sci-hub</a>, <a class="reference external" href="https://scihub22266oqcxt.onion.link/10.1103/PhysRevE.89.012804">&#64;tor</a>],
<a class="reference external" href="https://arxiv.org/abs/1310.4378">arXiv: 1310.4378</a></td></tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="graph_tool.inference.mcmc.mcmc_multilevel">
<code class="descclassname">graph_tool.inference.mcmc.</code><code class="descname">mcmc_multilevel</code><span class="sig-paren">(</span><em>state</em>, <em>B</em>, <em>r=2</em>, <em>b_cache=None</em>, <em>anneal=False</em>, <em>mcmc_equilibrate_args={}</em>, <em>anneal_args={}</em>, <em>shrink_args={}</em>, <em>verbose=False</em><span class="sig-paren">)</span><a class="reference internal" href="http://graph-tool.skewed.de/static/doc/_modules/graph_tool/inference/mcmc.html#mcmc_multilevel"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="inference.html#graph_tool.inference.mcmc.mcmc_multilevel" title="Permalink to this definition">¶</a></dt>
<dd><p>Equilibrate a MCMC from a starting state with a higher order, by performing
successive agglomerative initializations and equilibrations until the
desired order is reached, such that metastable states are avoided.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>state</strong> : Any state class (e.g. <a class="reference internal" href="inference.html#graph_tool.inference.blockmodel.BlockState" title="graph_tool.inference.blockmodel.BlockState"><code class="xref py py-class docutils literal notranslate"><span class="pre">BlockState</span></code></a>)</p>
<blockquote>
<div><p>Initial state. This state will <strong>not</strong> be modified during the algorithm.</p>
</div></blockquote>
<p><strong>B</strong> : <code class="docutils literal notranslate"><span class="pre">int</span></code></p>
<blockquote>
<div><p>Desired model order (i.e. number of groups).</p>
</div></blockquote>
<p><strong>r</strong> : <code class="docutils literal notranslate"><span class="pre">int</span></code> (optional, default: <code class="docutils literal notranslate"><span class="pre">2</span></code>)</p>
<blockquote>
<div><p>Greediness of agglomeration. At each iteration, the state order will be
reduced by a factor <code class="docutils literal notranslate"><span class="pre">r</span></code>.</p>
</div></blockquote>
<p><strong>b_cache</strong> : <code class="docutils literal notranslate"><span class="pre">dict</span></code> (optional, default: <code class="docutils literal notranslate"><span class="pre">None</span></code>)</p>
<blockquote>
<div><p>If specified, this should be a dictionary with key-value pairs of the
form <code class="docutils literal notranslate"><span class="pre">(B,</span> <span class="pre">state)</span></code> that contain pre-computed states of the specified
order. This dictionary will be modified during the algorithm.</p>
</div></blockquote>
<p><strong>anneal</strong> : <code class="docutils literal notranslate"><span class="pre">bool</span></code> (optional, default: <code class="docutils literal notranslate"><span class="pre">False</span></code>)</p>
<blockquote>
<div><p>If <code class="docutils literal notranslate"><span class="pre">True</span></code>, the equilibration steps will use simulated annealing, by
calling <a class="reference internal" href="inference.html#graph_tool.inference.mcmc.mcmc_anneal" title="graph_tool.inference.mcmc.mcmc_anneal"><code class="xref py py-func docutils literal notranslate"><span class="pre">mcmc_anneal()</span></code></a>, instead of
<a class="reference internal" href="inference.html#graph_tool.inference.mcmc.mcmc_equilibrate" title="graph_tool.inference.mcmc.mcmc_equilibrate"><code class="xref py py-func docutils literal notranslate"><span class="pre">mcmc_equilibrate()</span></code></a>.</p>
</div></blockquote>
<p><strong>mcmc_equilibrate_args</strong> : <code class="docutils literal notranslate"><span class="pre">dict</span></code> (optional, default: <code class="docutils literal notranslate"><span class="pre">{}</span></code>)</p>
<blockquote>
<div><p>Arguments to be passed to <a class="reference internal" href="inference.html#graph_tool.inference.mcmc.mcmc_equilibrate" title="graph_tool.inference.mcmc.mcmc_equilibrate"><code class="xref py py-func docutils literal notranslate"><span class="pre">mcmc_equilibrate()</span></code></a>.</p>
</div></blockquote>
<p><strong>mcmc_anneal_args</strong> : <code class="docutils literal notranslate"><span class="pre">dict</span></code> (optional, default: <code class="docutils literal notranslate"><span class="pre">{}</span></code>)</p>
<blockquote>
<div><p>Arguments to be passed to <a class="reference internal" href="inference.html#graph_tool.inference.mcmc.mcmc_anneal" title="graph_tool.inference.mcmc.mcmc_anneal"><code class="xref py py-func docutils literal notranslate"><span class="pre">mcmc_anneal()</span></code></a>.</p>
</div></blockquote>
<p><strong>shrink_args</strong> : <code class="docutils literal notranslate"><span class="pre">dict</span></code> (optional, default: <code class="docutils literal notranslate"><span class="pre">{}</span></code>)</p>
<blockquote>
<div><p>Arguments to be passed to <code class="docutils literal notranslate"><span class="pre">state.shrink</span></code>
(e.g. <a class="reference internal" href="inference.html#graph_tool.inference.blockmodel.BlockState.shrink" title="graph_tool.inference.blockmodel.BlockState.shrink"><code class="xref py py-meth docutils literal notranslate"><span class="pre">graph_tool.inference.blockmodel.BlockState.shrink()</span></code></a>).</p>
</div></blockquote>
<p><strong>verbose</strong> : <code class="docutils literal notranslate"><span class="pre">bool</span></code> or <code class="docutils literal notranslate"><span class="pre">tuple</span></code> (optional, default: <code class="docutils literal notranslate"><span class="pre">False</span></code>)</p>
<blockquote>
<div><p>If <code class="docutils literal notranslate"><span class="pre">True</span></code>, progress information will be shown. Optionally, this
accepts arguments of the type <code class="docutils literal notranslate"><span class="pre">tuple</span></code> of the form <code class="docutils literal notranslate"><span class="pre">(level,</span> <span class="pre">prefix)</span></code>
where <code class="docutils literal notranslate"><span class="pre">level</span></code> is a positive integer that specifies the level of
detail, and <code class="docutils literal notranslate"><span class="pre">prefix</span></code> is a string that is prepended to the all output
messages.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>state</strong> : The same type as parameter <code class="docutils literal notranslate"><span class="pre">state</span></code></p>
<blockquote class="last">
<div><p>This is the final state after the MCMC run.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>This algorithm alternates between equilibrating the MCMC state and reducing
the state order (via calls to <code class="docutils literal notranslate"><span class="pre">state.shrink</span></code>,
e.g. <a class="reference internal" href="inference.html#graph_tool.inference.blockmodel.BlockState.shrink" title="graph_tool.inference.blockmodel.BlockState.shrink"><code class="xref py py-meth docutils literal notranslate"><span class="pre">graph_tool.inference.blockmodel.BlockState.shrink()</span></code></a>).</p>
<p>This greatly reduces the changes of getting trapped in metastable states if
the starting point if far away from equilibrium, as discussed in
<a class="reference internal" href="inference.html#peixoto-efficient-2014192" id="id25">[peixoto-efficient-2014192]</a>.</p>
<p class="rubric">References</p>
<table class="docutils citation" frame="void" id="peixoto-efficient-2014192" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[peixoto-efficient-2014192]</td><td><em>(<a class="fn-backref" href="inference.html#id25">1</a>, <a class="fn-backref" href="inference.html#id26">2</a>)</em> Tiago P. Peixoto, “Efficient Monte Carlo and
greedy heuristic for the inference of stochastic block models”, Phys.
Rev. E 89, 012804 (2014), <a class="reference external" href="https://dx.doi.org/10.1103/PhysRevE.89.012804">DOI: 10.1103/PhysRevE.89.012804</a> [<a class="reference external" href="https://sci-hub.tw/10.1103/PhysRevE.89.012804">sci-hub</a>, <a class="reference external" href="https://scihub22266oqcxt.onion.link/10.1103/PhysRevE.89.012804">&#64;tor</a>],
<a class="reference external" href="https://arxiv.org/abs/1310.4378">arXiv: 1310.4378</a></td></tr>
</tbody>
</table>
</dd></dl>

<dl class="class">
<dt id="graph_tool.inference.mcmc.MulticanonicalState">
<em class="property">class </em><code class="descclassname">graph_tool.inference.mcmc.</code><code class="descname">MulticanonicalState</code><span class="sig-paren">(</span><em>g</em>, <em>S_min</em>, <em>S_max</em>, <em>nbins=1000</em><span class="sig-paren">)</span><a class="reference internal" href="http://graph-tool.skewed.de/static/doc/_modules/graph_tool/inference/mcmc.html#MulticanonicalState"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="inference.html#graph_tool.inference.mcmc.MulticanonicalState" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference external" href="https://docs.python.org/3/library/functions.html#object" title="(in Python v3.7)"><code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></a></p>
<p>The density of states of a multicanonical Monte Carlo algorithm. It is used
by <a class="reference internal" href="inference.html#graph_tool.inference.mcmc.multicanonical_equilibrate" title="graph_tool.inference.mcmc.multicanonical_equilibrate"><code class="xref py py-func docutils literal notranslate"><span class="pre">graph_tool.inference.mcmc.multicanonical_equilibrate()</span></code></a>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>g</strong> : <a class="reference internal" href="graph_tool.html#graph_tool.Graph" title="graph_tool.Graph"><code class="xref py py-class docutils literal notranslate"><span class="pre">Graph</span></code></a></p>
<blockquote>
<div><p>Graph to be modelled.</p>
</div></blockquote>
<p><strong>S_min</strong> : <code class="docutils literal notranslate"><span class="pre">float</span></code></p>
<blockquote>
<div><p>Minimum energy.</p>
</div></blockquote>
<p><strong>S_max</strong> : <code class="docutils literal notranslate"><span class="pre">float</span></code></p>
<blockquote>
<div><p>Maximum energy.</p>
</div></blockquote>
<p><strong>nbins</strong> : <code class="docutils literal notranslate"><span class="pre">int</span></code> (optional, default: <code class="docutils literal notranslate"><span class="pre">1000</span></code>)</p>
<blockquote class="last">
<div><p>Number of bins.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="graph_tool.inference.mcmc.MulticanonicalState.get_energies">
<code class="descname">get_energies</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="http://graph-tool.skewed.de/static/doc/_modules/graph_tool/inference/mcmc.html#MulticanonicalState.get_energies"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="inference.html#graph_tool.inference.mcmc.MulticanonicalState.get_energies" title="Permalink to this definition">¶</a></dt>
<dd><p>Get energy bounds.</p>
</dd></dl>

<dl class="method">
<dt id="graph_tool.inference.mcmc.MulticanonicalState.get_allowed_energies">
<code class="descname">get_allowed_energies</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="http://graph-tool.skewed.de/static/doc/_modules/graph_tool/inference/mcmc.html#MulticanonicalState.get_allowed_energies"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="inference.html#graph_tool.inference.mcmc.MulticanonicalState.get_allowed_energies" title="Permalink to this definition">¶</a></dt>
<dd><p>Get allowed energy bounds.</p>
</dd></dl>

<dl class="method">
<dt id="graph_tool.inference.mcmc.MulticanonicalState.get_range">
<code class="descname">get_range</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="http://graph-tool.skewed.de/static/doc/_modules/graph_tool/inference/mcmc.html#MulticanonicalState.get_range"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="inference.html#graph_tool.inference.mcmc.MulticanonicalState.get_range" title="Permalink to this definition">¶</a></dt>
<dd><p>Get energy range.</p>
</dd></dl>

<dl class="method">
<dt id="graph_tool.inference.mcmc.MulticanonicalState.get_density">
<code class="descname">get_density</code><span class="sig-paren">(</span><em>B=None</em><span class="sig-paren">)</span><a class="reference internal" href="http://graph-tool.skewed.de/static/doc/_modules/graph_tool/inference/mcmc.html#MulticanonicalState.get_density"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="inference.html#graph_tool.inference.mcmc.MulticanonicalState.get_density" title="Permalink to this definition">¶</a></dt>
<dd><p>Get density of states, normalized so that total sum is <span class="math">\(B^N\)</span>, where
<span class="math">\(B\)</span> is the number of groups, and <span class="math">\(N\)</span> is the number of
nodes. If not supplied <span class="math">\(B=N\)</span> is assumed.</p>
</dd></dl>

<dl class="method">
<dt id="graph_tool.inference.mcmc.MulticanonicalState.get_hist">
<code class="descname">get_hist</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="http://graph-tool.skewed.de/static/doc/_modules/graph_tool/inference/mcmc.html#MulticanonicalState.get_hist"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="inference.html#graph_tool.inference.mcmc.MulticanonicalState.get_hist" title="Permalink to this definition">¶</a></dt>
<dd><p>Get energy histogram.</p>
</dd></dl>

<dl class="method">
<dt id="graph_tool.inference.mcmc.MulticanonicalState.get_perm_hist">
<code class="descname">get_perm_hist</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="http://graph-tool.skewed.de/static/doc/_modules/graph_tool/inference/mcmc.html#MulticanonicalState.get_perm_hist"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="inference.html#graph_tool.inference.mcmc.MulticanonicalState.get_perm_hist" title="Permalink to this definition">¶</a></dt>
<dd><p>Get permanent energy histogram.</p>
</dd></dl>

<dl class="method">
<dt id="graph_tool.inference.mcmc.MulticanonicalState.get_flatness">
<code class="descname">get_flatness</code><span class="sig-paren">(</span><em>h=None</em>, <em>allow_gaps=True</em><span class="sig-paren">)</span><a class="reference internal" href="http://graph-tool.skewed.de/static/doc/_modules/graph_tool/inference/mcmc.html#MulticanonicalState.get_flatness"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="inference.html#graph_tool.inference.mcmc.MulticanonicalState.get_flatness" title="Permalink to this definition">¶</a></dt>
<dd><p>Get energy histogram flatness.</p>
</dd></dl>

<dl class="method">
<dt id="graph_tool.inference.mcmc.MulticanonicalState.get_posterior">
<code class="descname">get_posterior</code><span class="sig-paren">(</span><em>N=None</em><span class="sig-paren">)</span><a class="reference internal" href="http://graph-tool.skewed.de/static/doc/_modules/graph_tool/inference/mcmc.html#MulticanonicalState.get_posterior"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="inference.html#graph_tool.inference.mcmc.MulticanonicalState.get_posterior" title="Permalink to this definition">¶</a></dt>
<dd><p>Get posterior probability.</p>
</dd></dl>

<dl class="method">
<dt id="graph_tool.inference.mcmc.MulticanonicalState.reset_hist">
<code class="descname">reset_hist</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="http://graph-tool.skewed.de/static/doc/_modules/graph_tool/inference/mcmc.html#MulticanonicalState.reset_hist"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="inference.html#graph_tool.inference.mcmc.MulticanonicalState.reset_hist" title="Permalink to this definition">¶</a></dt>
<dd><p>Reset energy histogram.</p>
</dd></dl>

</dd></dl>

<dl class="function">
<dt id="graph_tool.inference.mcmc.multicanonical_equilibrate">
<code class="descclassname">graph_tool.inference.mcmc.</code><code class="descname">multicanonical_equilibrate</code><span class="sig-paren">(</span><em>state</em>, <em>m_state</em>, <em>f_range=(1.0</em>, <em>1e-06)</em>, <em>r=2</em>, <em>flatness=0.95</em>, <em>allow_gaps=True</em>, <em>callback=None</em>, <em>multicanonical_args={}</em>, <em>verbose=False</em><span class="sig-paren">)</span><a class="reference internal" href="http://graph-tool.skewed.de/static/doc/_modules/graph_tool/inference/mcmc.html#multicanonical_equilibrate"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="inference.html#graph_tool.inference.mcmc.multicanonical_equilibrate" title="Permalink to this definition">¶</a></dt>
<dd><p>Equilibrate a multicanonical Monte Carlo sampling using the Wang-Landau
algorithm.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>state</strong> : Any state class (e.g. <a class="reference internal" href="inference.html#graph_tool.inference.blockmodel.BlockState" title="graph_tool.inference.blockmodel.BlockState"><code class="xref py py-class docutils literal notranslate"><span class="pre">BlockState</span></code></a>)</p>
<blockquote>
<div><p>Initial state. This state will be modified during the algorithm.</p>
</div></blockquote>
<p><strong>m_state</strong> :  <a class="reference internal" href="inference.html#graph_tool.inference.mcmc.MulticanonicalState" title="graph_tool.inference.mcmc.MulticanonicalState"><code class="xref py py-class docutils literal notranslate"><span class="pre">MulticanonicalState</span></code></a></p>
<blockquote>
<div><p>Initial multicanonical state, where the state density will be stored.</p>
</div></blockquote>
<p><strong>f_range</strong> : <code class="docutils literal notranslate"><span class="pre">tuple</span></code> of two floats (optional, default: <code class="docutils literal notranslate"><span class="pre">(1.,</span> <span class="pre">1e-6)</span></code>)</p>
<blockquote>
<div><p>Range of density updates.</p>
</div></blockquote>
<p><strong>r</strong> : <code class="docutils literal notranslate"><span class="pre">float</span></code> (optional, default: <code class="docutils literal notranslate"><span class="pre">2.</span></code>)</p>
<blockquote>
<div><p>Greediness of convergence. At each iteration, the density updates will
be reduced by a factor <code class="docutils literal notranslate"><span class="pre">r</span></code>.</p>
</div></blockquote>
<p><strong>flatness</strong> : <code class="docutils literal notranslate"><span class="pre">float</span></code> (optional, default: <code class="docutils literal notranslate"><span class="pre">.95</span></code>)</p>
<blockquote>
<div><p>Sufficient histogram flatness threshold used to continue the algorithm.</p>
</div></blockquote>
<p><strong>allow_gaps</strong> : <code class="docutils literal notranslate"><span class="pre">bool</span></code> (optional, default: <code class="docutils literal notranslate"><span class="pre">True</span></code>)</p>
<blockquote>
<div><p>If <code class="docutils literal notranslate"><span class="pre">True</span></code>, gaps in the histogram (regions with zero count) will be
ignored when computing the flatness.</p>
</div></blockquote>
<p><strong>callback</strong> : <code class="docutils literal notranslate"><span class="pre">function</span></code> (optional, default: <code class="docutils literal notranslate"><span class="pre">None</span></code>)</p>
<blockquote>
<div><p>If given, this function will be called after each iteration. The
function must accept the current <code class="docutils literal notranslate"><span class="pre">state</span></code> and <code class="docutils literal notranslate"><span class="pre">m_state</span></code> as arguments.</p>
</div></blockquote>
<p><strong>multicanonical_args</strong> : <code class="docutils literal notranslate"><span class="pre">dict</span></code> (optional, default: <code class="docutils literal notranslate"><span class="pre">{}</span></code>)</p>
<blockquote>
<div><p>Arguments to be passed to <code class="docutils literal notranslate"><span class="pre">state.multicanonical_sweep</span></code> (e.g.
<a class="reference internal" href="inference.html#graph_tool.inference.blockmodel.BlockState.multicanonical_sweep" title="graph_tool.inference.blockmodel.BlockState.multicanonical_sweep"><code class="xref py py-meth docutils literal notranslate"><span class="pre">graph_tool.inference.blockmodel.BlockState.multicanonical_sweep()</span></code></a>).</p>
</div></blockquote>
<p><strong>verbose</strong> : <code class="docutils literal notranslate"><span class="pre">bool</span></code> or <code class="docutils literal notranslate"><span class="pre">tuple</span></code> (optional, default: <code class="docutils literal notranslate"><span class="pre">False</span></code>)</p>
<blockquote>
<div><p>If <code class="docutils literal notranslate"><span class="pre">True</span></code>, progress information will be shown. Optionally, this
accepts arguments of the type <code class="docutils literal notranslate"><span class="pre">tuple</span></code> of the form <code class="docutils literal notranslate"><span class="pre">(level,</span> <span class="pre">prefix)</span></code>
where <code class="docutils literal notranslate"><span class="pre">level</span></code> is a positive integer that specifies the level of
detail, and <code class="docutils literal notranslate"><span class="pre">prefix</span></code> is a string that is prepended to the all output
messages.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>niter</strong> : <code class="docutils literal notranslate"><span class="pre">int</span></code></p>
<blockquote class="last">
<div><p>Number of iterations required for convergence.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">References</p>
<table class="docutils citation" frame="void" id="wang-efficient-2001193" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="inference.html#id27">[wang-efficient-2001193]</a></td><td>Fugao Wang, D. P. Landau, “An efficient, multiple
range random walk algorithm to calculate the density of states”, Phys.
Rev. Lett. 86, 2050 (2001), <a class="reference external" href="https://dx.doi.org/10.1103/PhysRevLett.86.2050">DOI: 10.1103/PhysRevLett.86.2050</a> [<a class="reference external" href="https://sci-hub.tw/10.1103/PhysRevLett.86.2050">sci-hub</a>, <a class="reference external" href="https://scihub22266oqcxt.onion.link/10.1103/PhysRevLett.86.2050">&#64;tor</a>],
<a class="reference external" href="https://arxiv.org/abs/cond-mat/0011174">arXiv: cond-mat/0011174</a></td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="belardinelli-wang-2007193" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="inference.html#id28">[belardinelli-wang-2007193]</a></td><td>R. E. Belardinelli, V. D. Pereyra,
“Wang-Landau algorithm: A theoretical analysis of the saturation of
the error”, J. Chem. Phys. 127, 184105 (2007),
<a class="reference external" href="https://dx.doi.org/10.1063/1.2803061">DOI: 10.1063/1.2803061</a> [<a class="reference external" href="https://sci-hub.tw/10.1063/1.2803061">sci-hub</a>, <a class="reference external" href="https://scihub22266oqcxt.onion.link/10.1063/1.2803061">&#64;tor</a>], <a class="reference external" href="https://arxiv.org/abs/cond-mat/0702414">arXiv: cond-mat/0702414</a></td></tr>
</tbody>
</table>
</dd></dl>

<dl class="class">
<dt id="graph_tool.inference.mcmc.TemperingState">
<em class="property">class </em><code class="descclassname">graph_tool.inference.mcmc.</code><code class="descname">TemperingState</code><span class="sig-paren">(</span><em>states</em>, <em>betas</em>, <em>idx=None</em><span class="sig-paren">)</span><a class="reference internal" href="http://graph-tool.skewed.de/static/doc/_modules/graph_tool/inference/mcmc.html#TemperingState"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="inference.html#graph_tool.inference.mcmc.TemperingState" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference external" href="https://docs.python.org/3/library/functions.html#object" title="(in Python v3.7)"><code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></a></p>
<p>This class aggregates several state classes and corresponding
inverse-temperature values to implement <a class="reference external" href="https://en.wikipedia.org/wiki/Parallel_tempering">parallel tempering MCMC</a>.</p>
<p>This is meant to be used with <a class="reference internal" href="inference.html#graph_tool.inference.mcmc.mcmc_equilibrate" title="graph_tool.inference.mcmc.mcmc_equilibrate"><code class="xref py py-func docutils literal notranslate"><span class="pre">mcmc_equilibrate()</span></code></a>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>states</strong> : list of state objects (e.g. <a class="reference internal" href="inference.html#graph_tool.inference.blockmodel.BlockState" title="graph_tool.inference.blockmodel.BlockState"><code class="xref py py-class docutils literal notranslate"><span class="pre">BlockState</span></code></a>)</p>
<blockquote>
<div><p>Initial parallel states.</p>
</div></blockquote>
<p><strong>betas</strong> : list of floats</p>
<blockquote class="last">
<div><p>Inverse temperature values.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="graph_tool.inference.mcmc.TemperingState.entropy">
<code class="descname">entropy</code><span class="sig-paren">(</span><em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="http://graph-tool.skewed.de/static/doc/_modules/graph_tool/inference/mcmc.html#TemperingState.entropy"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="inference.html#graph_tool.inference.mcmc.TemperingState.entropy" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the sum of the entropy of the parallel states. All keyword
arguments are propagated to the individual states’ <cite>entropy()</cite>
method.</p>
</dd></dl>

<dl class="method">
<dt id="graph_tool.inference.mcmc.TemperingState.entropies">
<code class="descname">entropies</code><span class="sig-paren">(</span><em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="http://graph-tool.skewed.de/static/doc/_modules/graph_tool/inference/mcmc.html#TemperingState.entropies"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="inference.html#graph_tool.inference.mcmc.TemperingState.entropies" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the entropies of the parallel states. All keyword
arguments are propagated to the individual states’ <cite>entropy()</cite>
method.</p>
</dd></dl>

<dl class="method">
<dt id="graph_tool.inference.mcmc.TemperingState.states_swap">
<code class="descname">states_swap</code><span class="sig-paren">(</span><em>adjacent=True</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="http://graph-tool.skewed.de/static/doc/_modules/graph_tool/inference/mcmc.html#TemperingState.states_swap"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="inference.html#graph_tool.inference.mcmc.TemperingState.states_swap" title="Permalink to this definition">¶</a></dt>
<dd><p>Perform a full sweep of the parallel states, where swaps are attempted. All
relevant keyword arguments are propagated to the individual states’
<cite>entropy()</cite> method.</p>
</dd></dl>

<dl class="method">
<dt id="graph_tool.inference.mcmc.TemperingState.states_move">
<code class="descname">states_move</code><span class="sig-paren">(</span><em>sweep_algo</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="http://graph-tool.skewed.de/static/doc/_modules/graph_tool/inference/mcmc.html#TemperingState.states_move"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="inference.html#graph_tool.inference.mcmc.TemperingState.states_move" title="Permalink to this definition">¶</a></dt>
<dd><p>Perform a full sweep of the parallel states, where state moves are
attempted by calling <cite>sweep_algo(state, beta=beta, **kwargs)</cite>.</p>
</dd></dl>

<dl class="method">
<dt id="graph_tool.inference.mcmc.TemperingState.mcmc_sweep">
<code class="descname">mcmc_sweep</code><span class="sig-paren">(</span><em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="http://graph-tool.skewed.de/static/doc/_modules/graph_tool/inference/mcmc.html#TemperingState.mcmc_sweep"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="inference.html#graph_tool.inference.mcmc.TemperingState.mcmc_sweep" title="Permalink to this definition">¶</a></dt>
<dd><p>Perform a full mcmc sweep of the parallel states, where swap or moves are
chosen randomly. It accepts an keyword argument <code class="docutils literal notranslate"><span class="pre">r</span></code> (default: <code class="docutils literal notranslate"><span class="pre">0.1</span></code>)
specifying the relative probability with which state swaps is performed
with respect to node moves.  All remaining keyword arguments are
propagated to the individual states’ <cite>mcmc_sweep()</cite> method.</p>
</dd></dl>

<dl class="method">
<dt id="graph_tool.inference.mcmc.TemperingState.multiflip_mcmc_sweep">
<code class="descname">multiflip_mcmc_sweep</code><span class="sig-paren">(</span><em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="http://graph-tool.skewed.de/static/doc/_modules/graph_tool/inference/mcmc.html#TemperingState.multiflip_mcmc_sweep"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="inference.html#graph_tool.inference.mcmc.TemperingState.multiflip_mcmc_sweep" title="Permalink to this definition">¶</a></dt>
<dd><p>Perform a full mcmc sweep of the parallel states, where swap or moves are
chosen randomly. It accepts an keyword argument <code class="docutils literal notranslate"><span class="pre">r</span></code> (default: <code class="docutils literal notranslate"><span class="pre">0.1</span></code>)
specifying the relative probability with which state swaps is performed
with respect to node moves.  All remaining keyword arguments are
propagated to the individual states’ <cite>mcmc_sweep()</cite> method.</p>
</dd></dl>

<dl class="method">
<dt id="graph_tool.inference.mcmc.TemperingState.gibbs_sweep">
<code class="descname">gibbs_sweep</code><span class="sig-paren">(</span><em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="http://graph-tool.skewed.de/static/doc/_modules/graph_tool/inference/mcmc.html#TemperingState.gibbs_sweep"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="inference.html#graph_tool.inference.mcmc.TemperingState.gibbs_sweep" title="Permalink to this definition">¶</a></dt>
<dd><p>Perform a full Gibbs mcmc sweep of the parallel states, where swap or moves
are chosen randomly. It accepts an keyword argument <code class="docutils literal notranslate"><span class="pre">r</span></code> (default:
<code class="docutils literal notranslate"><span class="pre">0.1</span></code>) specifying the relative probability with which state swaps is
performed with respect to node moves.  All remaining keyword arguments
are propagated to the individual states’ <cite>gibbs_sweep()</cite> method.</p>
</dd></dl>

</dd></dl>

<span class="target" id="module-graph_tool.inference.bisection"></span><dl class="function">
<dt id="graph_tool.inference.bisection.bisection_minimize">
<code class="descclassname">graph_tool.inference.bisection.</code><code class="descname">bisection_minimize</code><span class="sig-paren">(</span><em>init_states</em>, <em>random_bisection=False</em>, <em>mcmc_multilevel_args={}</em>, <em>verbose=False</em><span class="sig-paren">)</span><a class="reference internal" href="http://graph-tool.skewed.de/static/doc/_modules/graph_tool/inference/bisection.html#bisection_minimize"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="inference.html#graph_tool.inference.bisection.bisection_minimize" title="Permalink to this definition">¶</a></dt>
<dd><p>Find the best order (number of groups) given an initial set of states by
performing a one-dimension minimization, using a Fibonacci (or golden
section) search.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>init_states</strong> : Any state class (e.g. <a class="reference internal" href="inference.html#graph_tool.inference.blockmodel.BlockState" title="graph_tool.inference.blockmodel.BlockState"><code class="xref py py-class docutils literal notranslate"><span class="pre">BlockState</span></code></a>)</p>
<blockquote>
<div><p>List with two or more states that will be used to bracket the search.</p>
</div></blockquote>
<p><strong>random_bisection</strong> : <code class="docutils literal notranslate"><span class="pre">bool</span></code> (optional, default: <code class="docutils literal notranslate"><span class="pre">False</span></code>)</p>
<blockquote>
<div><p>If <code class="docutils literal notranslate"><span class="pre">True</span></code>, the bisection will be done randomly in the interval,
instead of using the golden rule.</p>
</div></blockquote>
<p><strong>mcmc_multilevel_args</strong> : <code class="docutils literal notranslate"><span class="pre">dict</span></code> (optional, default: <code class="docutils literal notranslate"><span class="pre">{}</span></code>)</p>
<blockquote>
<div><p>Arguments to be passed to <a class="reference internal" href="inference.html#graph_tool.inference.mcmc.mcmc_multilevel" title="graph_tool.inference.mcmc.mcmc_multilevel"><code class="xref py py-func docutils literal notranslate"><span class="pre">mcmc_multilevel()</span></code></a>.</p>
</div></blockquote>
<p><strong>verbose</strong> : <code class="docutils literal notranslate"><span class="pre">bool</span></code> or <code class="docutils literal notranslate"><span class="pre">tuple</span></code> (optional, default: <code class="docutils literal notranslate"><span class="pre">False</span></code>)</p>
<blockquote>
<div><p>If <code class="docutils literal notranslate"><span class="pre">True</span></code>, progress information will be shown. Optionally, this
accepts arguments of the type <code class="docutils literal notranslate"><span class="pre">tuple</span></code> of the form <code class="docutils literal notranslate"><span class="pre">(level,</span> <span class="pre">prefix)</span></code>
where <code class="docutils literal notranslate"><span class="pre">level</span></code> is a positive integer that specifies the level of
detail, and <code class="docutils literal notranslate"><span class="pre">prefix</span></code> is a string that is prepended to the all output
messages.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>min_state</strong> : Any state class (e.g. <a class="reference internal" href="inference.html#graph_tool.inference.blockmodel.BlockState" title="graph_tool.inference.blockmodel.BlockState"><code class="xref py py-class docutils literal notranslate"><span class="pre">BlockState</span></code></a>)</p>
<blockquote class="last">
<div><p>State with minimal entropy in the interval.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>This function calls <a class="reference internal" href="inference.html#graph_tool.inference.mcmc.mcmc_multilevel" title="graph_tool.inference.mcmc.mcmc_multilevel"><code class="xref py py-func docutils literal notranslate"><span class="pre">mcmc_multilevel()</span></code></a> to
reduce the order of a given state, and uses the value of
<code class="docutils literal notranslate"><span class="pre">state.entropy(**args)</span></code> for the minimization, with <code class="docutils literal notranslate"><span class="pre">args</span></code> obtained from
<code class="docutils literal notranslate"><span class="pre">mcmc_multilevel_args</span></code>.</p>
<p class="rubric">References</p>
<table class="docutils citation" frame="void" id="golden-section-search195" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="inference.html#id30">[golden-section-search195]</a></td><td>“Golden section search”,
<a class="reference external" href="https://en.wikipedia.org/wiki/Golden_section_search">https://en.wikipedia.org/wiki/Golden_section_search</a></td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="peixoto-efficient-2014195" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="inference.html#id31">[peixoto-efficient-2014195]</a></td><td>Tiago P. Peixoto, “Efficient Monte Carlo and
greedy heuristic for the inference of stochastic block models”, Phys.
Rev. E 89, 012804 (2014), <a class="reference external" href="https://dx.doi.org/10.1103/PhysRevE.89.012804">DOI: 10.1103/PhysRevE.89.012804</a> [<a class="reference external" href="https://sci-hub.tw/10.1103/PhysRevE.89.012804">sci-hub</a>, <a class="reference external" href="https://scihub22266oqcxt.onion.link/10.1103/PhysRevE.89.012804">&#64;tor</a>],
<a class="reference external" href="https://arxiv.org/abs/1310.4378">arXiv: 1310.4378</a></td></tr>
</tbody>
</table>
</dd></dl>

<span class="target" id="module-graph_tool.inference.minimize"></span><dl class="function">
<dt id="graph_tool.inference.minimize.minimize_blockmodel_dl">
<code class="descclassname">graph_tool.inference.minimize.</code><code class="descname">minimize_blockmodel_dl</code><span class="sig-paren">(</span><em>g</em>, <em>B_min=None</em>, <em>B_max=None</em>, <em>b_min=None</em>, <em>b_max=None</em>, <em>deg_corr=True</em>, <em>overlap=False</em>, <em>nonoverlap_init=True</em>, <em>layers=False</em>, <em>state_args={}</em>, <em>bisection_args={}</em>, <em>mcmc_args={}</em>, <em>anneal_args={}</em>, <em>mcmc_equilibrate_args={}</em>, <em>shrink_args={}</em>, <em>mcmc_multilevel_args={}</em>, <em>verbose=False</em><span class="sig-paren">)</span><a class="reference internal" href="http://graph-tool.skewed.de/static/doc/_modules/graph_tool/inference/minimize.html#minimize_blockmodel_dl"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="inference.html#graph_tool.inference.minimize.minimize_blockmodel_dl" title="Permalink to this definition">¶</a></dt>
<dd><p>Fit the stochastic block model, by minimizing its description length using an
agglomerative heuristic.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>g</strong> : <a class="reference internal" href="graph_tool.html#graph_tool.Graph" title="graph_tool.Graph"><code class="xref py py-class docutils literal notranslate"><span class="pre">Graph</span></code></a></p>
<blockquote>
<div><p>The graph.</p>
</div></blockquote>
<p><strong>B_min</strong> : <code class="docutils literal notranslate"><span class="pre">int</span></code> (optional, default: <code class="docutils literal notranslate"><span class="pre">None</span></code>)</p>
<blockquote>
<div><p>The minimum number of blocks.</p>
</div></blockquote>
<p><strong>B_max</strong> : <code class="docutils literal notranslate"><span class="pre">int</span></code> (optional, default: <code class="docutils literal notranslate"><span class="pre">None</span></code>)</p>
<blockquote>
<div><p>The maximum number of blocks.</p>
</div></blockquote>
<p><strong>b_min</strong> : <a class="reference internal" href="graph_tool.html#graph_tool.PropertyMap" title="graph_tool.PropertyMap"><code class="xref py py-class docutils literal notranslate"><span class="pre">PropertyMap</span></code></a> (optional, default: <code class="docutils literal notranslate"><span class="pre">None</span></code>)</p>
<blockquote>
<div><p>The partition to be used with the minimum number of blocks.</p>
</div></blockquote>
<p><strong>b_max</strong> : <a class="reference internal" href="graph_tool.html#graph_tool.PropertyMap" title="graph_tool.PropertyMap"><code class="xref py py-class docutils literal notranslate"><span class="pre">PropertyMap</span></code></a> (optional, default: <code class="docutils literal notranslate"><span class="pre">None</span></code>)</p>
<blockquote>
<div><p>The partition to be used with the maximum number of blocks.</p>
</div></blockquote>
<p><strong>deg_corr</strong> : <code class="docutils literal notranslate"><span class="pre">bool</span></code> (optional, default: <code class="docutils literal notranslate"><span class="pre">True</span></code>)</p>
<blockquote>
<div><p>If <code class="docutils literal notranslate"><span class="pre">True</span></code>, the degree-corrected version of the model will be used.</p>
</div></blockquote>
<p><strong>overlap</strong> : <code class="docutils literal notranslate"><span class="pre">bool</span></code> (optional, default: <code class="docutils literal notranslate"><span class="pre">False</span></code>)</p>
<blockquote>
<div><p>If <code class="docutils literal notranslate"><span class="pre">True</span></code>, the overlapping version of the model will be used.</p>
</div></blockquote>
<p><strong>nonoverlap_init</strong> : <code class="docutils literal notranslate"><span class="pre">bool</span></code> (optional, default: <code class="docutils literal notranslate"><span class="pre">True</span></code>)</p>
<blockquote>
<div><p>If <code class="docutils literal notranslate"><span class="pre">True</span></code>, and <code class="docutils literal notranslate"><span class="pre">overlap</span> <span class="pre">==</span> <span class="pre">True</span></code> a non-overlapping initial state
will be used.</p>
</div></blockquote>
<p><strong>layers</strong> : <code class="docutils literal notranslate"><span class="pre">bool</span></code> (optional, default: <code class="docutils literal notranslate"><span class="pre">False</span></code>)</p>
<blockquote>
<div><p>If <code class="docutils literal notranslate"><span class="pre">True</span></code>, the layered version of the model will be used.</p>
</div></blockquote>
<p><strong>state_args</strong> : <code class="docutils literal notranslate"><span class="pre">dict</span></code> (optional, default: <code class="docutils literal notranslate"><span class="pre">{}</span></code>)</p>
<blockquote>
<div><p>Arguments to be passed to appropriate state constructor (e.g.
<a class="reference internal" href="inference.html#graph_tool.inference.blockmodel.BlockState" title="graph_tool.inference.blockmodel.BlockState"><code class="xref py py-class docutils literal notranslate"><span class="pre">BlockState</span></code></a>,
<a class="reference internal" href="inference.html#graph_tool.inference.overlap_blockmodel.OverlapBlockState" title="graph_tool.inference.overlap_blockmodel.OverlapBlockState"><code class="xref py py-class docutils literal notranslate"><span class="pre">OverlapBlockState</span></code></a> or
<a class="reference internal" href="inference.html#graph_tool.inference.layered_blockmodel.LayeredBlockState" title="graph_tool.inference.layered_blockmodel.LayeredBlockState"><code class="xref py py-class docutils literal notranslate"><span class="pre">LayeredBlockState</span></code></a>)</p>
</div></blockquote>
<p><strong>bisection_args</strong> : <code class="docutils literal notranslate"><span class="pre">dict</span></code> (optional, default: <code class="docutils literal notranslate"><span class="pre">{}</span></code>)</p>
<blockquote>
<div><p>Arguments to be passed to <a class="reference internal" href="inference.html#graph_tool.inference.bisection.bisection_minimize" title="graph_tool.inference.bisection.bisection_minimize"><code class="xref py py-func docutils literal notranslate"><span class="pre">bisection_minimize()</span></code></a>.</p>
</div></blockquote>
<p><strong>mcmc_args</strong> : <code class="docutils literal notranslate"><span class="pre">dict</span></code> (optional, default: <code class="docutils literal notranslate"><span class="pre">{}</span></code>)</p>
<blockquote>
<div><p>Arguments to be passed to <a class="reference internal" href="inference.html#graph_tool.inference.blockmodel.BlockState.mcmc_sweep" title="graph_tool.inference.blockmodel.BlockState.mcmc_sweep"><code class="xref py py-meth docutils literal notranslate"><span class="pre">graph_tool.inference.blockmodel.BlockState.mcmc_sweep()</span></code></a>,
<a class="reference internal" href="inference.html#graph_tool.inference.overlap_blockmodel.OverlapBlockState.mcmc_sweep" title="graph_tool.inference.overlap_blockmodel.OverlapBlockState.mcmc_sweep"><code class="xref py py-meth docutils literal notranslate"><span class="pre">graph_tool.inference.overlap_blockmodel.OverlapBlockState.mcmc_sweep()</span></code></a> or
<a class="reference internal" href="inference.html#graph_tool.inference.layered_blockmodel.LayeredBlockState.mcmc_sweep" title="graph_tool.inference.layered_blockmodel.LayeredBlockState.mcmc_sweep"><code class="xref py py-meth docutils literal notranslate"><span class="pre">graph_tool.inference.layered_blockmodel.LayeredBlockState.mcmc_sweep()</span></code></a>.</p>
</div></blockquote>
<p><strong>mcmc_equilibrate_args</strong> : <code class="docutils literal notranslate"><span class="pre">dict</span></code> (optional, default: <code class="docutils literal notranslate"><span class="pre">{}</span></code>)</p>
<blockquote>
<div><p>Arguments to be passed to <a class="reference internal" href="inference.html#graph_tool.inference.mcmc.mcmc_equilibrate" title="graph_tool.inference.mcmc.mcmc_equilibrate"><code class="xref py py-func docutils literal notranslate"><span class="pre">mcmc_equilibrate()</span></code></a>.</p>
</div></blockquote>
<p><strong>shrink_args</strong> : <code class="docutils literal notranslate"><span class="pre">dict</span></code> (optional, default: <code class="docutils literal notranslate"><span class="pre">{}</span></code>)</p>
<blockquote>
<div><p>Arguments to be passed to <a class="reference internal" href="inference.html#graph_tool.inference.blockmodel.BlockState.shrink" title="graph_tool.inference.blockmodel.BlockState.shrink"><code class="xref py py-meth docutils literal notranslate"><span class="pre">graph_tool.inference.blockmodel.BlockState.shrink()</span></code></a>,
<a class="reference internal" href="inference.html#graph_tool.inference.overlap_blockmodel.OverlapBlockState.shrink" title="graph_tool.inference.overlap_blockmodel.OverlapBlockState.shrink"><code class="xref py py-meth docutils literal notranslate"><span class="pre">graph_tool.inference.overlap_blockmodel.OverlapBlockState.shrink()</span></code></a> or
<a class="reference internal" href="inference.html#graph_tool.inference.layered_blockmodel.LayeredBlockState.shrink" title="graph_tool.inference.layered_blockmodel.LayeredBlockState.shrink"><code class="xref py py-meth docutils literal notranslate"><span class="pre">graph_tool.inference.layered_blockmodel.LayeredBlockState.shrink()</span></code></a>.</p>
</div></blockquote>
<p><strong>mcmc_multilevel_args</strong> : <code class="docutils literal notranslate"><span class="pre">dict</span></code> (optional, default: <code class="docutils literal notranslate"><span class="pre">{}</span></code>)</p>
<blockquote>
<div><p>Arguments to be passed to <a class="reference internal" href="inference.html#graph_tool.inference.mcmc.mcmc_multilevel" title="graph_tool.inference.mcmc.mcmc_multilevel"><code class="xref py py-func docutils literal notranslate"><span class="pre">mcmc_multilevel()</span></code></a>.</p>
</div></blockquote>
<p><strong>verbose</strong> : <code class="docutils literal notranslate"><span class="pre">bool</span></code> or <code class="docutils literal notranslate"><span class="pre">tuple</span></code> (optional, default: <code class="docutils literal notranslate"><span class="pre">False</span></code>)</p>
<blockquote>
<div><p>If <code class="docutils literal notranslate"><span class="pre">True</span></code>, progress information will be shown. Optionally, this
accepts arguments of the type <code class="docutils literal notranslate"><span class="pre">tuple</span></code> of the form <code class="docutils literal notranslate"><span class="pre">(level,</span> <span class="pre">prefix)</span></code>
where <code class="docutils literal notranslate"><span class="pre">level</span></code> is a positive integer that specifies the level of
detail, and <code class="docutils literal notranslate"><span class="pre">prefix</span></code> is a string that is prepended to the all output
messages.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>min_state</strong> : <a class="reference internal" href="inference.html#graph_tool.inference.blockmodel.BlockState" title="graph_tool.inference.blockmodel.BlockState"><code class="xref py py-class docutils literal notranslate"><span class="pre">BlockState</span></code></a> or  <a class="reference internal" href="inference.html#graph_tool.inference.overlap_blockmodel.OverlapBlockState" title="graph_tool.inference.overlap_blockmodel.OverlapBlockState"><code class="xref py py-class docutils literal notranslate"><span class="pre">OverlapBlockState</span></code></a> or  <a class="reference internal" href="inference.html#graph_tool.inference.layered_blockmodel.LayeredBlockState" title="graph_tool.inference.layered_blockmodel.LayeredBlockState"><code class="xref py py-class docutils literal notranslate"><span class="pre">LayeredBlockState</span></code></a></p>
<blockquote class="last">
<div><p>State with minimal description length.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>This function is a convenience wrapper around
<a class="reference internal" href="inference.html#graph_tool.inference.bisection.bisection_minimize" title="graph_tool.inference.bisection.bisection_minimize"><code class="xref py py-func docutils literal notranslate"><span class="pre">bisection_minimize()</span></code></a>.</p>
<p>See <a class="reference internal" href="inference.html#peixoto-efficient-2014197" id="id32">[peixoto-efficient-2014197]</a> for details on the algorithm.</p>
<p>This algorithm has a complexity of <span class="math">\(O(V \ln^2 V)\)</span>, where <span class="math">\(V\)</span> is
the number of nodes in the network.</p>
<p class="rubric">References</p>
<table class="docutils citation" frame="void" id="holland-stochastic-1983197" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="inference.html#id33">[holland-stochastic-1983197]</a></td><td>Paul W. Holland, Kathryn Blackmond Laskey,
Samuel Leinhardt, “Stochastic blockmodels: First steps”,
Carnegie-Mellon University, Pittsburgh, PA 15213, U.S.A.,
<a class="reference external" href="https://dx.doi.org/10.1016/0378-8733(83)90021-7">DOI: 10.1016/0378-8733(83)90021-7</a> [<a class="reference external" href="https://sci-hub.tw/10.1016/0378-8733(83)90021-7">sci-hub</a>, <a class="reference external" href="https://scihub22266oqcxt.onion.link/10.1016/0378-8733(83)90021-7">&#64;tor</a>].</td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="faust-blockmodels-1992197" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="inference.html#id34">[faust-blockmodels-1992197]</a></td><td>Katherine Faust, and Stanley
Wasserman. “Blockmodels: Interpretation and Evaluation.” Social Networks
14, no. 1-2 (1992): 5-61, <a class="reference external" href="https://dx.doi.org/10.1016/0378-8733(92)90013-W">DOI: 10.1016/0378-8733(92)90013-W</a> [<a class="reference external" href="https://sci-hub.tw/10.1016/0378-8733(92)90013-W">sci-hub</a>, <a class="reference external" href="https://scihub22266oqcxt.onion.link/10.1016/0378-8733(92)90013-W">&#64;tor</a>].</td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="karrer-stochastic-2011197" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="inference.html#id35">[karrer-stochastic-2011197]</a></td><td>Brian Karrer, and M. E. J. Newman. “Stochastic
Blockmodels and Community Structure in Networks.” Physical Review E 83,
no. 1 (2011): 016107, <a class="reference external" href="https://dx.doi.org/10.1103/PhysRevE.83.016107">DOI: 10.1103/PhysRevE.83.016107</a> [<a class="reference external" href="https://sci-hub.tw/10.1103/PhysRevE.83.016107">sci-hub</a>, <a class="reference external" href="https://scihub22266oqcxt.onion.link/10.1103/PhysRevE.83.016107">&#64;tor</a>].</td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="peixoto-entropy-2012197" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="inference.html#id36">[peixoto-entropy-2012197]</a></td><td>Tiago P. Peixoto “Entropy of Stochastic Blockmodel
Ensembles.” Physical Review E 85, no. 5 (2012): 056122,
<a class="reference external" href="https://dx.doi.org/10.1103/PhysRevE.85.056122">DOI: 10.1103/PhysRevE.85.056122</a> [<a class="reference external" href="https://sci-hub.tw/10.1103/PhysRevE.85.056122">sci-hub</a>, <a class="reference external" href="https://scihub22266oqcxt.onion.link/10.1103/PhysRevE.85.056122">&#64;tor</a>], <a class="reference external" href="https://arxiv.org/abs/1112.6028">arXiv: 1112.6028</a>.</td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="peixoto-parsimonious-2013197" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="inference.html#id37">[peixoto-parsimonious-2013197]</a></td><td>Tiago P. Peixoto, “Parsimonious module
inference in large networks”, Phys. Rev. Lett. 110, 148701 (2013),
<a class="reference external" href="https://dx.doi.org/10.1103/PhysRevLett.110.148701">DOI: 10.1103/PhysRevLett.110.148701</a> [<a class="reference external" href="https://sci-hub.tw/10.1103/PhysRevLett.110.148701">sci-hub</a>, <a class="reference external" href="https://scihub22266oqcxt.onion.link/10.1103/PhysRevLett.110.148701">&#64;tor</a>], <a class="reference external" href="https://arxiv.org/abs/1212.4794">arXiv: 1212.4794</a>.</td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="peixoto-efficient-2014197" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[peixoto-efficient-2014197]</td><td><em>(<a class="fn-backref" href="inference.html#id32">1</a>, <a class="fn-backref" href="inference.html#id38">2</a>)</em> Tiago P. Peixoto, “Efficient Monte Carlo and greedy
heuristic for the inference of stochastic block models”, Phys. Rev. E 89,
012804 (2014), <a class="reference external" href="https://dx.doi.org/10.1103/PhysRevE.89.012804">DOI: 10.1103/PhysRevE.89.012804</a> [<a class="reference external" href="https://sci-hub.tw/10.1103/PhysRevE.89.012804">sci-hub</a>, <a class="reference external" href="https://scihub22266oqcxt.onion.link/10.1103/PhysRevE.89.012804">&#64;tor</a>], <a class="reference external" href="https://arxiv.org/abs/1310.4378">arXiv: 1310.4378</a>.</td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="peixoto-model-2016197" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="inference.html#id39">[peixoto-model-2016197]</a></td><td>Tiago P. Peixoto, “Model selection and hypothesis
testing for large-scale network models with overlapping groups”,
Phys. Rev. X 5, 011033 (2016), <a class="reference external" href="https://dx.doi.org/10.1103/PhysRevX.5.011033">DOI: 10.1103/PhysRevX.5.011033</a> [<a class="reference external" href="https://sci-hub.tw/10.1103/PhysRevX.5.011033">sci-hub</a>, <a class="reference external" href="https://scihub22266oqcxt.onion.link/10.1103/PhysRevX.5.011033">&#64;tor</a>],
<a class="reference external" href="https://arxiv.org/abs/1409.3059">arXiv: 1409.3059</a>.</td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="peixoto-inferring-2016197" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="inference.html#id40">[peixoto-inferring-2016197]</a></td><td>Tiago P. Peixoto, “Inferring the mesoscale
structure of layered, edge-valued and time-varying networks”,
Phys. Rev. E 92, 042807 (2015), <a class="reference external" href="https://dx.doi.org/10.1103/PhysRevE.92.042807">DOI: 10.1103/PhysRevE.92.042807</a> [<a class="reference external" href="https://sci-hub.tw/10.1103/PhysRevE.92.042807">sci-hub</a>, <a class="reference external" href="https://scihub22266oqcxt.onion.link/10.1103/PhysRevE.92.042807">&#64;tor</a>],
<a class="reference external" href="https://arxiv.org/abs/1504.02381">arXiv: 1504.02381</a>.</td></tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">g</span> <span class="o">=</span> <span class="n">gt</span><span class="o">.</span><span class="n">collection</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;polbooks&quot;</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">state</span> <span class="o">=</span> <span class="n">gt</span><span class="o">.</span><span class="n">minimize_blockmodel_dl</span><span class="p">(</span><span class="n">g</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">state</span><span class="o">.</span><span class="n">draw</span><span class="p">(</span><span class="n">pos</span><span class="o">=</span><span class="n">g</span><span class="o">.</span><span class="n">vp</span><span class="p">[</span><span class="s2">&quot;pos&quot;</span><span class="p">],</span> <span class="n">vertex_shape</span><span class="o">=</span><span class="n">state</span><span class="o">.</span><span class="n">get_blocks</span><span class="p">(),</span>
<span class="gp">... </span>           <span class="n">output</span><span class="o">=</span><span class="s2">&quot;polbooks_blocks_mdl.pdf&quot;</span><span class="p">)</span>
<span class="go">&lt;...&gt;</span>
</pre></div>
</div>
<div class="figure align-center" id="id53">
<img alt="_images/polbooks_blocks_mdl.png" src="_images/polbooks_blocks_mdl.png" />
<p class="caption"><span class="caption-text">Block partition of a political books network, which minimizes the
description length of the network according to the degree-corrected
stochastic blockmodel.</span></p>
</div>
<div class="highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">g</span> <span class="o">=</span> <span class="n">gt</span><span class="o">.</span><span class="n">collection</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;polbooks&quot;</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">state</span> <span class="o">=</span> <span class="n">gt</span><span class="o">.</span><span class="n">minimize_blockmodel_dl</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">overlap</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">state</span><span class="o">.</span><span class="n">draw</span><span class="p">(</span><span class="n">pos</span><span class="o">=</span><span class="n">g</span><span class="o">.</span><span class="n">vp</span><span class="p">[</span><span class="s2">&quot;pos&quot;</span><span class="p">],</span> <span class="n">output</span><span class="o">=</span><span class="s2">&quot;polbooks_overlap_blocks_mdl.pdf&quot;</span><span class="p">)</span>
<span class="go">&lt;...&gt;</span>
</pre></div>
</div>
<div class="figure align-center" id="id54">
<img alt="_images/polbooks_overlap_blocks_mdl.png" src="_images/polbooks_overlap_blocks_mdl.png" />
<p class="caption"><span class="caption-text">Overlapping partition of a political books network, which minimizes the
description length of the network according to the overlapping
degree-corrected stochastic blockmodel.</span></p>
</div>
</dd></dl>

<dl class="function">
<dt id="graph_tool.inference.minimize.minimize_nested_blockmodel_dl">
<code class="descclassname">graph_tool.inference.minimize.</code><code class="descname">minimize_nested_blockmodel_dl</code><span class="sig-paren">(</span><em>g</em>, <em>B_min=None</em>, <em>B_max=None</em>, <em>b_min=None</em>, <em>b_max=None</em>, <em>Bs=None</em>, <em>bs=None</em>, <em>deg_corr=True</em>, <em>overlap=False</em>, <em>nonoverlap_init=True</em>, <em>layers=False</em>, <em>hierarchy_minimize_args={}</em>, <em>state_args={}</em>, <em>bisection_args={}</em>, <em>mcmc_args={}</em>, <em>anneal_args={}</em>, <em>mcmc_equilibrate_args={}</em>, <em>shrink_args={}</em>, <em>mcmc_multilevel_args={}</em>, <em>verbose=False</em><span class="sig-paren">)</span><a class="reference internal" href="http://graph-tool.skewed.de/static/doc/_modules/graph_tool/inference/minimize.html#minimize_nested_blockmodel_dl"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="inference.html#graph_tool.inference.minimize.minimize_nested_blockmodel_dl" title="Permalink to this definition">¶</a></dt>
<dd><p>Fit the nested stochastic block model, by minimizing its description length
using an agglomerative heuristic.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>g</strong> : <a class="reference internal" href="graph_tool.html#graph_tool.Graph" title="graph_tool.Graph"><code class="xref py py-class docutils literal notranslate"><span class="pre">Graph</span></code></a></p>
<blockquote>
<div><p>The graph.</p>
</div></blockquote>
<p><strong>B_min</strong> : <code class="docutils literal notranslate"><span class="pre">int</span></code> (optional, default: <code class="docutils literal notranslate"><span class="pre">None</span></code>)</p>
<blockquote>
<div><p>The minimum number of blocks.</p>
</div></blockquote>
<p><strong>B_max</strong> : <code class="docutils literal notranslate"><span class="pre">int</span></code> (optional, default: <code class="docutils literal notranslate"><span class="pre">None</span></code>)</p>
<blockquote>
<div><p>The maximum number of blocks.</p>
</div></blockquote>
<p><strong>b_min</strong> : <a class="reference internal" href="graph_tool.html#graph_tool.PropertyMap" title="graph_tool.PropertyMap"><code class="xref py py-class docutils literal notranslate"><span class="pre">PropertyMap</span></code></a> (optional, default: <code class="docutils literal notranslate"><span class="pre">None</span></code>)</p>
<blockquote>
<div><p>The partition to be used with the minimum number of blocks.</p>
</div></blockquote>
<p><strong>b_max</strong> : <a class="reference internal" href="graph_tool.html#graph_tool.PropertyMap" title="graph_tool.PropertyMap"><code class="xref py py-class docutils literal notranslate"><span class="pre">PropertyMap</span></code></a> (optional, default: <code class="docutils literal notranslate"><span class="pre">None</span></code>)</p>
<blockquote>
<div><p>The partition to be used with the maximum number of blocks.</p>
</div></blockquote>
<p><strong>Bs</strong> : <code class="docutils literal notranslate"><span class="pre">list</span></code> of ints (optional, default: <code class="docutils literal notranslate"><span class="pre">None</span></code>)</p>
<blockquote>
<div><p>If provided, it will correspond to the sizes of the initial hierarchy.</p>
</div></blockquote>
<p><strong>bs</strong> : <code class="docutils literal notranslate"><span class="pre">list</span></code> of integer-valued <a class="reference external" href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v1.14)"><code class="xref py py-class docutils literal notranslate"><span class="pre">numpy.ndarray</span></code></a> objects (optional, default: <code class="docutils literal notranslate"><span class="pre">None</span></code>)</p>
<blockquote>
<div><p>If provided, it will correspond to the initial hierarchical partition.</p>
</div></blockquote>
<p><strong>deg_corr</strong> : <code class="docutils literal notranslate"><span class="pre">bool</span></code> (optional, default: <code class="docutils literal notranslate"><span class="pre">True</span></code>)</p>
<blockquote>
<div><p>If <code class="docutils literal notranslate"><span class="pre">True</span></code>, the degree-corrected version of the model will be used.</p>
</div></blockquote>
<p><strong>overlap</strong> : <code class="docutils literal notranslate"><span class="pre">bool</span></code> (optional, default: <code class="docutils literal notranslate"><span class="pre">False</span></code>)</p>
<blockquote>
<div><p>If <code class="docutils literal notranslate"><span class="pre">True</span></code>, the overlapping version of the model will be used.</p>
</div></blockquote>
<p><strong>nonoverlap_init</strong> : <code class="docutils literal notranslate"><span class="pre">bool</span></code> (optional, default: <code class="docutils literal notranslate"><span class="pre">True</span></code>)</p>
<blockquote>
<div><p>If <code class="docutils literal notranslate"><span class="pre">True</span></code>, and <code class="docutils literal notranslate"><span class="pre">overlap</span> <span class="pre">==</span> <span class="pre">True</span></code> a non-overlapping initial state
will be used.</p>
</div></blockquote>
<p><strong>layers</strong> : <code class="docutils literal notranslate"><span class="pre">bool</span></code> (optional, default: <code class="docutils literal notranslate"><span class="pre">False</span></code>)</p>
<blockquote>
<div><p>If <code class="docutils literal notranslate"><span class="pre">True</span></code>, the layered version of the model will be used.</p>
</div></blockquote>
<p><strong>hierarchy_minimize_args</strong> : <code class="docutils literal notranslate"><span class="pre">dict</span></code> (optional, default: <code class="docutils literal notranslate"><span class="pre">{}</span></code>)</p>
<blockquote>
<div><p>Arguments to be passed to <a class="reference internal" href="inference.html#graph_tool.inference.nested_blockmodel.hierarchy_minimize" title="graph_tool.inference.nested_blockmodel.hierarchy_minimize"><code class="xref py py-func docutils literal notranslate"><span class="pre">hierarchy_minimize()</span></code></a>.</p>
</div></blockquote>
<p><strong>state_args</strong> : <code class="docutils literal notranslate"><span class="pre">dict</span></code> (optional, default: <code class="docutils literal notranslate"><span class="pre">{}</span></code>)</p>
<blockquote>
<div><p>Arguments to be passed to appropriate state constructor (e.g.
<a class="reference internal" href="inference.html#graph_tool.inference.blockmodel.BlockState" title="graph_tool.inference.blockmodel.BlockState"><code class="xref py py-class docutils literal notranslate"><span class="pre">BlockState</span></code></a>,
<a class="reference internal" href="inference.html#graph_tool.inference.overlap_blockmodel.OverlapBlockState" title="graph_tool.inference.overlap_blockmodel.OverlapBlockState"><code class="xref py py-class docutils literal notranslate"><span class="pre">OverlapBlockState</span></code></a> or
<a class="reference internal" href="inference.html#graph_tool.inference.layered_blockmodel.LayeredBlockState" title="graph_tool.inference.layered_blockmodel.LayeredBlockState"><code class="xref py py-class docutils literal notranslate"><span class="pre">LayeredBlockState</span></code></a>)</p>
</div></blockquote>
<p><strong>bisection_args</strong> : <code class="docutils literal notranslate"><span class="pre">dict</span></code> (optional, default: <code class="docutils literal notranslate"><span class="pre">{}</span></code>)</p>
<blockquote>
<div><p>Arguments to be passed to <a class="reference internal" href="inference.html#graph_tool.inference.bisection.bisection_minimize" title="graph_tool.inference.bisection.bisection_minimize"><code class="xref py py-func docutils literal notranslate"><span class="pre">bisection_minimize()</span></code></a>.</p>
</div></blockquote>
<p><strong>mcmc_args</strong> : <code class="docutils literal notranslate"><span class="pre">dict</span></code> (optional, default: <code class="docutils literal notranslate"><span class="pre">{}</span></code>)</p>
<blockquote>
<div><p>Arguments to be passed to <a class="reference internal" href="inference.html#graph_tool.inference.blockmodel.BlockState.mcmc_sweep" title="graph_tool.inference.blockmodel.BlockState.mcmc_sweep"><code class="xref py py-meth docutils literal notranslate"><span class="pre">graph_tool.inference.blockmodel.BlockState.mcmc_sweep()</span></code></a>,
<a class="reference internal" href="inference.html#graph_tool.inference.overlap_blockmodel.OverlapBlockState.mcmc_sweep" title="graph_tool.inference.overlap_blockmodel.OverlapBlockState.mcmc_sweep"><code class="xref py py-meth docutils literal notranslate"><span class="pre">graph_tool.inference.overlap_blockmodel.OverlapBlockState.mcmc_sweep()</span></code></a> or
<a class="reference internal" href="inference.html#graph_tool.inference.layered_blockmodel.LayeredBlockState.mcmc_sweep" title="graph_tool.inference.layered_blockmodel.LayeredBlockState.mcmc_sweep"><code class="xref py py-meth docutils literal notranslate"><span class="pre">graph_tool.inference.layered_blockmodel.LayeredBlockState.mcmc_sweep()</span></code></a>.</p>
</div></blockquote>
<p><strong>mcmc_equilibrate_args</strong> : <code class="docutils literal notranslate"><span class="pre">dict</span></code> (optional, default: <code class="docutils literal notranslate"><span class="pre">{}</span></code>)</p>
<blockquote>
<div><p>Arguments to be passed to <a class="reference internal" href="inference.html#graph_tool.inference.mcmc.mcmc_equilibrate" title="graph_tool.inference.mcmc.mcmc_equilibrate"><code class="xref py py-func docutils literal notranslate"><span class="pre">mcmc_equilibrate()</span></code></a>.</p>
</div></blockquote>
<p><strong>shrink_args</strong> : <code class="docutils literal notranslate"><span class="pre">dict</span></code> (optional, default: <code class="docutils literal notranslate"><span class="pre">{}</span></code>)</p>
<blockquote>
<div><p>Arguments to be passed to <a class="reference internal" href="inference.html#graph_tool.inference.blockmodel.BlockState.shrink" title="graph_tool.inference.blockmodel.BlockState.shrink"><code class="xref py py-meth docutils literal notranslate"><span class="pre">graph_tool.inference.blockmodel.BlockState.shrink()</span></code></a>,
<a class="reference internal" href="inference.html#graph_tool.inference.overlap_blockmodel.OverlapBlockState.shrink" title="graph_tool.inference.overlap_blockmodel.OverlapBlockState.shrink"><code class="xref py py-meth docutils literal notranslate"><span class="pre">graph_tool.inference.overlap_blockmodel.OverlapBlockState.shrink()</span></code></a> or
<a class="reference internal" href="inference.html#graph_tool.inference.layered_blockmodel.LayeredBlockState.shrink" title="graph_tool.inference.layered_blockmodel.LayeredBlockState.shrink"><code class="xref py py-meth docutils literal notranslate"><span class="pre">graph_tool.inference.layered_blockmodel.LayeredBlockState.shrink()</span></code></a>.</p>
</div></blockquote>
<p><strong>mcmc_multilevel_args</strong> : <code class="docutils literal notranslate"><span class="pre">dict</span></code> (optional, default: <code class="docutils literal notranslate"><span class="pre">{}</span></code>)</p>
<blockquote>
<div><p>Arguments to be passed to <a class="reference internal" href="inference.html#graph_tool.inference.mcmc.mcmc_multilevel" title="graph_tool.inference.mcmc.mcmc_multilevel"><code class="xref py py-func docutils literal notranslate"><span class="pre">mcmc_multilevel()</span></code></a>.</p>
</div></blockquote>
<p><strong>verbose</strong> : <code class="docutils literal notranslate"><span class="pre">bool</span></code> or <code class="docutils literal notranslate"><span class="pre">tuple</span></code> (optional, default: <code class="docutils literal notranslate"><span class="pre">False</span></code>)</p>
<blockquote>
<div><p>If <code class="docutils literal notranslate"><span class="pre">True</span></code>, progress information will be shown. Optionally, this
accepts arguments of the type <code class="docutils literal notranslate"><span class="pre">tuple</span></code> of the form <code class="docutils literal notranslate"><span class="pre">(level,</span> <span class="pre">prefix)</span></code>
where <code class="docutils literal notranslate"><span class="pre">level</span></code> is a positive integer that specifies the level of
detail, and <code class="docutils literal notranslate"><span class="pre">prefix</span></code> is a string that is prepended to the all output
messages.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>min_state</strong> : <a class="reference internal" href="inference.html#graph_tool.inference.nested_blockmodel.NestedBlockState" title="graph_tool.inference.nested_blockmodel.NestedBlockState"><code class="xref py py-class docutils literal notranslate"><span class="pre">NestedBlockState</span></code></a></p>
<blockquote class="last">
<div><p>Nested state with minimal description length.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>This function is a convenience wrapper around
<a class="reference internal" href="inference.html#graph_tool.inference.nested_blockmodel.hierarchy_minimize" title="graph_tool.inference.nested_blockmodel.hierarchy_minimize"><code class="xref py py-func docutils literal notranslate"><span class="pre">hierarchy_minimize()</span></code></a>.</p>
<p>See <a class="reference internal" href="inference.html#peixoto-hierarchical-2014205" id="id41">[peixoto-hierarchical-2014205]</a> for details on the algorithm.</p>
<p>This algorithm has a complexity of <span class="math">\(O(V \ln^2 V)\)</span>, where <span class="math">\(V\)</span> is
the number of nodes in the network.</p>
<p class="rubric">References</p>
<table class="docutils citation" frame="void" id="peixoto-hierarchical-2014205" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[peixoto-hierarchical-2014205]</td><td><em>(<a class="fn-backref" href="inference.html#id41">1</a>, <a class="fn-backref" href="inference.html#id42">2</a>)</em> Tiago P. Peixoto, “Hierarchical block
structures and high-resolution model selection in large networks “,
Phys. Rev. X 4, 011047 (2014), <a class="reference external" href="https://dx.doi.org/10.1103/PhysRevX.4.011047">DOI: 10.1103/PhysRevX.4.011047</a> [<a class="reference external" href="https://sci-hub.tw/10.1103/PhysRevX.4.011047">sci-hub</a>, <a class="reference external" href="https://scihub22266oqcxt.onion.link/10.1103/PhysRevX.4.011047">&#64;tor</a>],
<a class="reference external" href="https://arxiv.org/abs/1310.4377">arXiv: 1310.4377</a>.</td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="peixoto-efficient-2014205" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="inference.html#id43">[peixoto-efficient-2014205]</a></td><td>Tiago P. Peixoto, “Efficient Monte Carlo and
greedy heuristic for the inference of stochastic block models”,
Phys. Rev. E 89, 012804 (2014), <a class="reference external" href="https://dx.doi.org/10.1103/PhysRevE.89.012804">DOI: 10.1103/PhysRevE.89.012804</a> [<a class="reference external" href="https://sci-hub.tw/10.1103/PhysRevE.89.012804">sci-hub</a>, <a class="reference external" href="https://scihub22266oqcxt.onion.link/10.1103/PhysRevE.89.012804">&#64;tor</a>],
<a class="reference external" href="https://arxiv.org/abs/1310.4378">arXiv: 1310.4378</a>.</td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="peixoto-model-2016205" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="inference.html#id44">[peixoto-model-2016205]</a></td><td>Tiago P. Peixoto, “Model selection and hypothesis
testing for large-scale network models with overlapping groups”,
Phys. Rev. X 5, 011033 (2016), <a class="reference external" href="https://dx.doi.org/10.1103/PhysRevX.5.011033">DOI: 10.1103/PhysRevX.5.011033</a> [<a class="reference external" href="https://sci-hub.tw/10.1103/PhysRevX.5.011033">sci-hub</a>, <a class="reference external" href="https://scihub22266oqcxt.onion.link/10.1103/PhysRevX.5.011033">&#64;tor</a>],
<a class="reference external" href="https://arxiv.org/abs/1409.3059">arXiv: 1409.3059</a>.</td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="peixoto-inferring-2016205" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="inference.html#id45">[peixoto-inferring-2016205]</a></td><td>Tiago P. Peixoto, “Inferring the mesoscale
structure of layered, edge-valued and time-varying networks”,
Phys. Rev. E 92, 042807 (2015), <a class="reference external" href="https://dx.doi.org/10.1103/PhysRevE.92.042807">DOI: 10.1103/PhysRevE.92.042807</a> [<a class="reference external" href="https://sci-hub.tw/10.1103/PhysRevE.92.042807">sci-hub</a>, <a class="reference external" href="https://scihub22266oqcxt.onion.link/10.1103/PhysRevE.92.042807">&#64;tor</a>],
<a class="reference external" href="https://arxiv.org/abs/1504.02381">arXiv: 1504.02381</a>.</td></tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">g</span> <span class="o">=</span> <span class="n">gt</span><span class="o">.</span><span class="n">collection</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;power&quot;</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">state</span> <span class="o">=</span> <span class="n">gt</span><span class="o">.</span><span class="n">minimize_nested_blockmodel_dl</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">deg_corr</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">state</span><span class="o">.</span><span class="n">draw</span><span class="p">(</span><span class="n">output</span><span class="o">=</span><span class="s2">&quot;power_nested_mdl.pdf&quot;</span><span class="p">)</span>
<span class="go">(...)</span>
</pre></div>
</div>
<div class="figure align-center" id="id55">
<img alt="_images/power_nested_mdl.png" src="_images/power_nested_mdl.png" />
<p class="caption"><span class="caption-text">Hierarchical Block partition of a power-grid network, which minimizes
the description length of the network according to the nested
(degree-corrected) stochastic blockmodel.</span></p>
</div>
<div class="highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">g</span> <span class="o">=</span> <span class="n">gt</span><span class="o">.</span><span class="n">collection</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;celegansneural&quot;</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">state</span> <span class="o">=</span> <span class="n">gt</span><span class="o">.</span><span class="n">minimize_nested_blockmodel_dl</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">deg_corr</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">overlap</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">state</span><span class="o">.</span><span class="n">draw</span><span class="p">(</span><span class="n">output</span><span class="o">=</span><span class="s2">&quot;celegans_nested_mdl_overlap.pdf&quot;</span><span class="p">)</span>
<span class="go">(...)</span>
</pre></div>
</div>
<div class="figure align-center" id="id56">
<img alt="_images/celegans_nested_mdl_overlap.png" src="_images/celegans_nested_mdl_overlap.png" />
<p class="caption"><span class="caption-text">Overlapping block partition of the <em>C. elegans</em> neural network, which
minimizes the description length of the network according to the nested
overlapping degree-corrected stochastic blockmodel.</span></p>
</div>
</dd></dl>

<span class="target" id="module-graph_tool.inference.blockmodel_em"></span><dl class="class">
<dt id="graph_tool.inference.blockmodel_em.EMBlockState">
<em class="property">class </em><code class="descclassname">graph_tool.inference.blockmodel_em.</code><code class="descname">EMBlockState</code><span class="sig-paren">(</span><em>g</em>, <em>B</em>, <em>init_state=None</em><span class="sig-paren">)</span><a class="reference internal" href="http://graph-tool.skewed.de/static/doc/_modules/graph_tool/inference/blockmodel_em.html#EMBlockState"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="inference.html#graph_tool.inference.blockmodel_em.EMBlockState" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference external" href="https://docs.python.org/3/library/functions.html#object" title="(in Python v3.7)"><code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></a></p>
<p>The parametric, undirected stochastic block model state of a given graph.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>g</strong> : <a class="reference internal" href="graph_tool.html#graph_tool.Graph" title="graph_tool.Graph"><code class="xref py py-class docutils literal notranslate"><span class="pre">Graph</span></code></a></p>
<blockquote>
<div><p>Graph to be modelled.</p>
</div></blockquote>
<p><strong>B</strong> : <code class="docutils literal notranslate"><span class="pre">int</span></code></p>
<blockquote>
<div><p>Number of blocks (or vertex groups).</p>
</div></blockquote>
<p><strong>init_state</strong> : <a class="reference internal" href="inference.html#graph_tool.inference.blockmodel.BlockState" title="graph_tool.inference.blockmodel.BlockState"><code class="xref py py-class docutils literal notranslate"><span class="pre">BlockState</span></code></a> (optional, default: <code class="docutils literal notranslate"><span class="pre">None</span></code>)</p>
<blockquote class="last">
<div><p>Optional block state used for initialization.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>This class is intended to be used with <a class="reference internal" href="inference.html#graph_tool.inference.blockmodel_em.em_infer" title="graph_tool.inference.blockmodel_em.em_infer"><code class="xref py py-func docutils literal notranslate"><span class="pre">em_infer()</span></code></a> to perform
expectation maximization with belief propagation. See
<a class="reference internal" href="inference.html#decelle-asymptotic-2011209" id="id46">[decelle_asymptotic_2011209]</a> for more details.</p>
<p class="rubric">References</p>
<table class="docutils citation" frame="void" id="decelle-asymptotic-2011209" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[decelle_asymptotic_2011209]</td><td><em>(<a class="fn-backref" href="inference.html#id46">1</a>, <a class="fn-backref" href="inference.html#id47">2</a>)</em> Aurelien Decelle, Florent Krzakala, Cristopher
Moore, and Lenka Zdeborová, “Asymptotic analysis of the stochastic block
model for modular networks and its algorithmic applications”,
Phys. Rev. E 84, 066106 (2011), <a class="reference external" href="https://dx.doi.org/10.1103/PhysRevE.84.066106">DOI: 10.1103/PhysRevE.84.066106</a> [<a class="reference external" href="https://sci-hub.tw/10.1103/PhysRevE.84.066106">sci-hub</a>, <a class="reference external" href="https://scihub22266oqcxt.onion.link/10.1103/PhysRevE.84.066106">&#64;tor</a>],
<a class="reference external" href="https://arxiv.org/abs/1109.3041">arXiv: 1109.3041</a></td></tr>
</tbody>
</table>
<dl class="method">
<dt id="graph_tool.inference.blockmodel_em.EMBlockState.get_vertex_marginals">
<code class="descname">get_vertex_marginals</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="http://graph-tool.skewed.de/static/doc/_modules/graph_tool/inference/blockmodel_em.html#EMBlockState.get_vertex_marginals"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="inference.html#graph_tool.inference.blockmodel_em.EMBlockState.get_vertex_marginals" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the vertex marginals.</p>
</dd></dl>

<dl class="method">
<dt id="graph_tool.inference.blockmodel_em.EMBlockState.get_group_sizes">
<code class="descname">get_group_sizes</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="http://graph-tool.skewed.de/static/doc/_modules/graph_tool/inference/blockmodel_em.html#EMBlockState.get_group_sizes"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="inference.html#graph_tool.inference.blockmodel_em.EMBlockState.get_group_sizes" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the group sizes.</p>
</dd></dl>

<dl class="method">
<dt id="graph_tool.inference.blockmodel_em.EMBlockState.get_matrix">
<code class="descname">get_matrix</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="http://graph-tool.skewed.de/static/doc/_modules/graph_tool/inference/blockmodel_em.html#EMBlockState.get_matrix"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="inference.html#graph_tool.inference.blockmodel_em.EMBlockState.get_matrix" title="Permalink to this definition">¶</a></dt>
<dd><p>Return probability matrix.</p>
</dd></dl>

<dl class="method">
<dt id="graph_tool.inference.blockmodel_em.EMBlockState.get_MAP">
<code class="descname">get_MAP</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="http://graph-tool.skewed.de/static/doc/_modules/graph_tool/inference/blockmodel_em.html#EMBlockState.get_MAP"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="inference.html#graph_tool.inference.blockmodel_em.EMBlockState.get_MAP" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the maximum a posteriori (MAP) estimate of the node partition.</p>
</dd></dl>

<dl class="method">
<dt id="graph_tool.inference.blockmodel_em.EMBlockState.get_fe">
<code class="descname">get_fe</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="http://graph-tool.skewed.de/static/doc/_modules/graph_tool/inference/blockmodel_em.html#EMBlockState.get_fe"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="inference.html#graph_tool.inference.blockmodel_em.EMBlockState.get_fe" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the Bethe free energy.</p>
</dd></dl>

<dl class="method">
<dt id="graph_tool.inference.blockmodel_em.EMBlockState.get_ak">
<code class="descname">get_ak</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="http://graph-tool.skewed.de/static/doc/_modules/graph_tool/inference/blockmodel_em.html#EMBlockState.get_ak"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="inference.html#graph_tool.inference.blockmodel_em.EMBlockState.get_ak" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the model’s average degree.</p>
</dd></dl>

<dl class="method">
<dt id="graph_tool.inference.blockmodel_em.EMBlockState.e_iter">
<code class="descname">e_iter</code><span class="sig-paren">(</span><em>max_iter=1000</em>, <em>epsilon=0.001</em>, <em>verbose=False</em><span class="sig-paren">)</span><a class="reference internal" href="http://graph-tool.skewed.de/static/doc/_modules/graph_tool/inference/blockmodel_em.html#EMBlockState.e_iter"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="inference.html#graph_tool.inference.blockmodel_em.EMBlockState.e_iter" title="Permalink to this definition">¶</a></dt>
<dd><p>Perform ‘expectation’ iterations, using belief propagation, where the vertex
marginals and edge messages are updated, until convergence according to
<code class="docutils literal notranslate"><span class="pre">epsilon</span></code> or the maximum number of iterations given by
<code class="docutils literal notranslate"><span class="pre">max_iter</span></code>. If <code class="docutils literal notranslate"><span class="pre">verbose</span> <span class="pre">==</span> <span class="pre">True</span></code>, convergence information is
displayed.</p>
<p>The last update delta is returned.</p>
</dd></dl>

<dl class="method">
<dt id="graph_tool.inference.blockmodel_em.EMBlockState.m_iter">
<code class="descname">m_iter</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="http://graph-tool.skewed.de/static/doc/_modules/graph_tool/inference/blockmodel_em.html#EMBlockState.m_iter"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="inference.html#graph_tool.inference.blockmodel_em.EMBlockState.m_iter" title="Permalink to this definition">¶</a></dt>
<dd><p>Perform a single ‘maximization’ iteration, where the group sizes and
connection probability matrix are updated.</p>
<p>The update delta is returned.</p>
</dd></dl>

<dl class="method">
<dt id="graph_tool.inference.blockmodel_em.EMBlockState.learn">
<code class="descname">learn</code><span class="sig-paren">(</span><em>epsilon=0.001</em><span class="sig-paren">)</span><a class="reference internal" href="http://graph-tool.skewed.de/static/doc/_modules/graph_tool/inference/blockmodel_em.html#EMBlockState.learn"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="inference.html#graph_tool.inference.blockmodel_em.EMBlockState.learn" title="Permalink to this definition">¶</a></dt>
<dd><p>Perform ‘maximization’ iterations until convergence according to <code class="docutils literal notranslate"><span class="pre">epsilon</span></code>.</p>
<p>The last update delta is returned.</p>
</dd></dl>

<dl class="method">
<dt id="graph_tool.inference.blockmodel_em.EMBlockState.draw">
<code class="descname">draw</code><span class="sig-paren">(</span><em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="http://graph-tool.skewed.de/static/doc/_modules/graph_tool/inference/blockmodel_em.html#EMBlockState.draw"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="inference.html#graph_tool.inference.blockmodel_em.EMBlockState.draw" title="Permalink to this definition">¶</a></dt>
<dd><p>Convenience wrapper to <a class="reference internal" href="draw.html#graph_tool.draw.graph_draw" title="graph_tool.draw.graph_draw"><code class="xref py py-func docutils literal notranslate"><span class="pre">graph_draw()</span></code></a> that
draws the state of the graph as colors on the vertices and edges.</p>
</dd></dl>

</dd></dl>

<dl class="function">
<dt id="graph_tool.inference.blockmodel_em.em_infer">
<code class="descclassname">graph_tool.inference.blockmodel_em.</code><code class="descname">em_infer</code><span class="sig-paren">(</span><em>state</em>, <em>max_iter=1000</em>, <em>max_e_iter=1</em>, <em>epsilon=0.001</em>, <em>learn_first=False</em>, <em>verbose=False</em><span class="sig-paren">)</span><a class="reference internal" href="http://graph-tool.skewed.de/static/doc/_modules/graph_tool/inference/blockmodel_em.html#em_infer"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="inference.html#graph_tool.inference.blockmodel_em.em_infer" title="Permalink to this definition">¶</a></dt>
<dd><p>Infer the model parameters and latent variables using the
expectation-maximization (EM) algorithm with initial state given by
<code class="docutils literal notranslate"><span class="pre">state</span></code>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>state</strong> : model state</p>
<blockquote>
<div><p>State object, e.g. of type <a class="reference internal" href="inference.html#graph_tool.inference.blockmodel_em.EMBlockState" title="graph_tool.inference.blockmodel_em.EMBlockState"><code class="xref py py-class docutils literal notranslate"><span class="pre">graph_tool.inference.blockmodel_em.EMBlockState</span></code></a>.</p>
</div></blockquote>
<p><strong>max_iter</strong> : <code class="docutils literal notranslate"><span class="pre">int</span></code> (optional, default: <code class="docutils literal notranslate"><span class="pre">1000</span></code>)</p>
<blockquote>
<div><p>Maximum number of iterations.</p>
</div></blockquote>
<p><strong>max_e_iter</strong> : <code class="docutils literal notranslate"><span class="pre">int</span></code> (optional, default: <code class="docutils literal notranslate"><span class="pre">1</span></code>)</p>
<blockquote>
<div><p>Maximum number of ‘expectation’ iterations inside the main loop.</p>
</div></blockquote>
<p><strong>epsilon</strong> : <code class="docutils literal notranslate"><span class="pre">float</span></code> (optional, default: <code class="docutils literal notranslate"><span class="pre">1e-3</span></code>)</p>
<blockquote>
<div><p>Convergence criterion.</p>
</div></blockquote>
<p><strong>learn_first</strong> : <code class="docutils literal notranslate"><span class="pre">bool</span></code> (optional, default: <code class="docutils literal notranslate"><span class="pre">False</span></code>)</p>
<blockquote>
<div><p>If <code class="docutils literal notranslate"><span class="pre">True</span></code>, the maximization (a.k.a parameter learning) is converged
before the main loop is run.</p>
</div></blockquote>
<p><strong>verbose</strong> : <code class="docutils literal notranslate"><span class="pre">bool</span></code> (optional, default: <code class="docutils literal notranslate"><span class="pre">True</span></code>)</p>
<blockquote>
<div><p>If <code class="docutils literal notranslate"><span class="pre">True</span></code>, convergence information is displayed.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>delta</strong> : <code class="docutils literal notranslate"><span class="pre">float</span></code></p>
<blockquote>
<div><p>The last update delta.</p>
</div></blockquote>
<p><strong>niter</strong> : <code class="docutils literal notranslate"><span class="pre">int</span></code></p>
<blockquote class="last">
<div><p>The total number of iterations.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">References</p>
<table class="docutils citation" frame="void" id="wiki-em210" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="inference.html#id48">[wiki-EM210]</a></td><td>“Expectation–maximization algorithm”,
<a class="reference external" href="https://en.wikipedia.org/wiki/Expectation%E2%80%93maximization_algorithm">https://en.wikipedia.org/wiki/Expectation%E2%80%93maximization_algorithm</a></td></tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">g</span> <span class="o">=</span> <span class="n">gt</span><span class="o">.</span><span class="n">collection</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;polbooks&quot;</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">state</span> <span class="o">=</span> <span class="n">gt</span><span class="o">.</span><span class="n">EMBlockState</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">B</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">delta</span><span class="p">,</span> <span class="n">niter</span> <span class="o">=</span> <span class="n">gt</span><span class="o">.</span><span class="n">em_infer</span><span class="p">(</span><span class="n">state</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">state</span><span class="o">.</span><span class="n">draw</span><span class="p">(</span><span class="n">pos</span><span class="o">=</span><span class="n">g</span><span class="o">.</span><span class="n">vp</span><span class="p">[</span><span class="s2">&quot;pos&quot;</span><span class="p">],</span> <span class="n">output</span><span class="o">=</span><span class="s2">&quot;polbooks_EM_B3.pdf&quot;</span><span class="p">)</span>
<span class="go">&lt;...&gt;</span>
</pre></div>
</div>
<div class="figure align-center" id="id57">
<img alt="_images/polbooks_EM_B3.png" src="_images/polbooks_EM_B3.png" />
<p class="caption"><span class="caption-text">“Soft” block partition of a political books network with <span class="math">\(B=3\)</span>.</span></p>
</div>
</dd></dl>

<span class="target" id="module-graph_tool.inference.util"></span><dl class="class">
<dt id="graph_tool.inference.util.DictState">
<em class="property">class </em><code class="descclassname">graph_tool.inference.util.</code><code class="descname">DictState</code><span class="sig-paren">(</span><em>d</em><span class="sig-paren">)</span><a class="reference internal" href="http://graph-tool.skewed.de/static/doc/_modules/graph_tool/inference/util.html#DictState"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="inference.html#graph_tool.inference.util.DictState" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#dict" title="(in Python v3.7)"><code class="xref py py-class docutils literal notranslate"><span class="pre">dict</span></code></a></p>
<p>Dictionary with (key,value) pairs accessible via attributes.</p>
</dd></dl>

<dl class="function">
<dt id="graph_tool.inference.util.dmask">
<code class="descclassname">graph_tool.inference.util.</code><code class="descname">dmask</code><span class="sig-paren">(</span><em>d</em>, <em>ks</em><span class="sig-paren">)</span><a class="reference internal" href="http://graph-tool.skewed.de/static/doc/_modules/graph_tool/inference/util.html#dmask"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="inference.html#graph_tool.inference.util.dmask" title="Permalink to this definition">¶</a></dt>
<dd><p>Copy dictionary <code class="docutils literal notranslate"><span class="pre">d</span></code> and remove key list <code class="docutils literal notranslate"><span class="pre">ks</span></code>.</p>
</dd></dl>

<dl class="function">
<dt id="graph_tool.inference.util.lbinom">
<code class="descclassname">graph_tool.inference.util.</code><code class="descname">lbinom</code><span class="sig-paren">(</span><em>n</em>, <em>k</em><span class="sig-paren">)</span><a class="reference internal" href="http://graph-tool.skewed.de/static/doc/_modules/graph_tool/inference/util.html#lbinom"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="inference.html#graph_tool.inference.util.lbinom" title="Permalink to this definition">¶</a></dt>
<dd><p>Return log of binom(n, k).</p>
</dd></dl>

<dl class="function">
<dt id="graph_tool.inference.util.pmap">
<code class="descclassname">graph_tool.inference.util.</code><code class="descname">pmap</code><span class="sig-paren">(</span><em>prop</em>, <em>value_map</em><span class="sig-paren">)</span><a class="reference internal" href="http://graph-tool.skewed.de/static/doc/_modules/graph_tool/inference/util.html#pmap"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="inference.html#graph_tool.inference.util.pmap" title="Permalink to this definition">¶</a></dt>
<dd><p>Maps all the values of <cite>prop</cite> to the values given by <cite>value_map</cite>, which
is indexed by the values of <cite>prop</cite>.</p>
</dd></dl>

<dl class="function">
<dt id="graph_tool.inference.util.reverse_map">
<code class="descclassname">graph_tool.inference.util.</code><code class="descname">reverse_map</code><span class="sig-paren">(</span><em>prop</em>, <em>value_map</em><span class="sig-paren">)</span><a class="reference internal" href="http://graph-tool.skewed.de/static/doc/_modules/graph_tool/inference/util.html#reverse_map"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="inference.html#graph_tool.inference.util.reverse_map" title="Permalink to this definition">¶</a></dt>
<dd><p>Modify <cite>value_map</cite> such that the positions indexed by the values in <cite>prop</cite>
correspond to their index in <cite>prop</cite>.</p>
</dd></dl>

<dl class="function">
<dt id="graph_tool.inference.util.continuous_map">
<code class="descclassname">graph_tool.inference.util.</code><code class="descname">continuous_map</code><span class="sig-paren">(</span><em>prop</em><span class="sig-paren">)</span><a class="reference internal" href="http://graph-tool.skewed.de/static/doc/_modules/graph_tool/inference/util.html#continuous_map"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="inference.html#graph_tool.inference.util.continuous_map" title="Permalink to this definition">¶</a></dt>
<dd><p>Remap the values of <code class="docutils literal notranslate"><span class="pre">prop</span></code> in the continuous range <span class="math">\([0, N-1]\)</span>.</p>
</dd></dl>

<span class="target" id="module-graph_tool.inference.modularity"></span><dl class="function">
<dt id="graph_tool.inference.modularity.modularity">
<code class="descclassname">graph_tool.inference.modularity.</code><code class="descname">modularity</code><span class="sig-paren">(</span><em>g</em>, <em>b</em>, <em>weight=None</em><span class="sig-paren">)</span><a class="reference internal" href="http://graph-tool.skewed.de/static/doc/_modules/graph_tool/inference/modularity.html#modularity"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="inference.html#graph_tool.inference.modularity.modularity" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate Newman’s modularity of a network partition.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>g</strong> : <a class="reference internal" href="graph_tool.html#graph_tool.Graph" title="graph_tool.Graph"><code class="xref py py-class docutils literal notranslate"><span class="pre">Graph</span></code></a></p>
<blockquote>
<div><p>Graph to be used.</p>
</div></blockquote>
<p><strong>b</strong> : <a class="reference internal" href="graph_tool.html#graph_tool.PropertyMap" title="graph_tool.PropertyMap"><code class="xref py py-class docutils literal notranslate"><span class="pre">PropertyMap</span></code></a></p>
<blockquote>
<div><p>Vertex property map with the community partition.</p>
</div></blockquote>
<p><strong>weight</strong> : <a class="reference internal" href="graph_tool.html#graph_tool.PropertyMap" title="graph_tool.PropertyMap"><code class="xref py py-class docutils literal notranslate"><span class="pre">PropertyMap</span></code></a> (optional, default: None)</p>
<blockquote>
<div><p>Edge property map with the optional edge weights.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>Q</strong> : float</p>
<blockquote class="last">
<div><p>Newman’s modularity.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>Given a specific graph partition specified by <cite>prop</cite>, Newman’s modularity
<a class="reference internal" href="inference.html#newman-modularity-2006211" id="id49">[newman-modularity-2006211]</a> is defined as:</p>
<div class="math">
\[Q = \frac{1}{2E} \sum_r e_{rr}- \frac{e_r^2}{2E}\]</div>
<p>where <span class="math">\(e_{rs}\)</span> is the number of edges which fall between
vertices in communities s and r, or twice that number if <span class="math">\(r = s\)</span>, and
<span class="math">\(e_r = \sum_s e_{rs}\)</span>.</p>
<p>If weights are provided, the matrix <span class="math">\(e_{rs}\)</span> corresponds to the sum
of edge weights instead of number of edges, and the value of <span class="math">\(E\)</span>
becomes the total sum of edge weights.</p>
<p class="rubric">References</p>
<table class="docutils citation" frame="void" id="newman-modularity-2006211" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[newman-modularity-2006211]</td><td><em>(<a class="fn-backref" href="inference.html#id49">1</a>, <a class="fn-backref" href="inference.html#id50">2</a>)</em> M. E. J. Newman, “Modularity and community
structure in networks”, Proc. Natl. Acad. Sci. USA 103, 8577-8582 (2006),
<a class="reference external" href="https://dx.doi.org/10.1073/pnas.0601602103">DOI: 10.1073/pnas.0601602103</a> [<a class="reference external" href="https://sci-hub.tw/10.1073/pnas.0601602103">sci-hub</a>, <a class="reference external" href="https://scihub22266oqcxt.onion.link/10.1073/pnas.0601602103">&#64;tor</a>], <a class="reference external" href="https://arxiv.org/abs/physics/0602124">arXiv: physics/0602124</a></td></tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">g</span> <span class="o">=</span> <span class="n">gt</span><span class="o">.</span><span class="n">collection</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;football&quot;</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">gt</span><span class="o">.</span><span class="n">modularity</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">g</span><span class="o">.</span><span class="n">vp</span><span class="o">.</span><span class="n">value_tsevans</span><span class="p">)</span>
<span class="go">0.5744393497...</span>
</pre></div>
</div>
</dd></dl>



          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="inference.html#"><code class="docutils literal notranslate"><span class="pre">graph_tool.inference</span></code> - Statistical inference of generative network models</a><ul>
<li><a class="reference internal" href="inference.html#nonparametric-stochastic-block-model-inference">Nonparametric stochastic block model inference</a><ul>
<li><a class="reference internal" href="inference.html#high-level-functions">High-level functions</a></li>
<li><a class="reference internal" href="inference.html#state-classes">State classes</a></li>
<li><a class="reference internal" href="inference.html#sampling-and-minimization">Sampling and minimization</a></li>
<li><a class="reference internal" href="inference.html#auxiliary-functions">Auxiliary functions</a></li>
<li><a class="reference internal" href="inference.html#auxiliary-classes">Auxiliary classes</a></li>
</ul>
</li>
<li><a class="reference internal" href="inference.html#nonparametric-network-reconstruction">Nonparametric network reconstruction</a><ul>
<li><a class="reference internal" href="inference.html#id1">State classes</a></li>
</ul>
</li>
<li><a class="reference internal" href="inference.html#semiparametric-stochastic-block-model-inference">Semiparametric stochastic block model inference</a><ul>
<li><a class="reference internal" href="inference.html#id2">State classes</a></li>
<li><a class="reference internal" href="inference.html#expectation-maximization-inference">Expectation-maximization Inference</a></li>
</ul>
</li>
<li><a class="reference internal" href="inference.html#large-scale-descriptors">Large-scale descriptors</a></li>
<li><a class="reference internal" href="inference.html#contents">Contents</a></li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="http://graph-tool.skewed.de/static/doc/generation.html"
                        title="previous chapter"><code class="docutils literal notranslate"><span class="pre">graph_tool.generation</span></code> - Random graph generation</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="http://graph-tool.skewed.de/static/doc/search_module.html"
                        title="next chapter"><code class="docutils literal notranslate"><span class="pre">graph_tool.search</span></code> - Search algorithms</a></p>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="http://graph-tool.skewed.de/static/doc/_sources/inference.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    </div>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="http://graph-tool.skewed.de/static/doc/search_module.html" title="graph_tool.search - Search algorithms"
             >next</a> |</li>
        <li class="right" >
          <a href="http://graph-tool.skewed.de/static/doc/generation.html" title="graph_tool.generation - Random graph generation"
             >previous</a> |</li>
    <li><img src="../../img/graph-icon.png" alt="logo" style="margin-right: 5px; margin-bottom:-2px;" /><a href="../../index.html">Project Homepage</a> &raquo;</li>
    
        <li class="nav-item nav-item-0"><a href="index.html">graph-tool 2.27 documentation</a> &#187;</li>

          <li class="nav-item nav-item-1"><a href="http://graph-tool.skewed.de/static/doc/modules.html" >Module documentation</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="graph_tool.html" >graph_tool - efficient graph analysis and manipulation</a> &#187;</li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright 2018, Tiago de Paula Peixoto &lt;tiago@skewed.de&gt;.
      Last updated on Jun 28, 2018.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.7.5.
    </div>
  </body>
</html>