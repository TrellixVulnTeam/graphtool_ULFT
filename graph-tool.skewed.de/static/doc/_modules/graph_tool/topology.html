
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="X-UA-Compatible" content="IE=Edge" />
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>graph_tool.topology &#8212; graph-tool 2.27 documentation</title>
    <link rel="stylesheet" href="https://graph-tool.skewed.de/static/doc/_static/gt_style.css" type="text/css" />
    <link rel="stylesheet" href="https://graph-tool.skewed.de/static/doc/_static/pygments.css" type="text/css" />
    <script type="text/javascript" id="documentation_options" data-url_root="../../" src="https://graph-tool.skewed.de/static/doc/_static/documentation_options.js"></script>
    <script type="text/javascript" src="https://graph-tool.skewed.de/static/doc/_static/jquery.js"></script>
    <script type="text/javascript" src="https://graph-tool.skewed.de/static/doc/_static/underscore.js"></script>
    <script type="text/javascript" src="https://graph-tool.skewed.de/static/doc/_static/doctools.js"></script>
    <script type="text/javascript" src="https://graph-tool.skewed.de/static/doc/_static/MathJax/MathJax.js?config=default"></script>
    <link rel="search" type="application/opensearchdescription+xml"
          title="Search within graph-tool 2.27 documentation"
          href="https://graph-tool.skewed.de/static/doc/_static/opensearch.xml"/>
    <link rel="shortcut icon" href="https://graph-tool.skewed.de/static/doc/_static/graph-icon.ico"/>
    <link rel="index" title="Index" href="https://graph-tool.skewed.de/static/doc/genindex.html" />
    <link rel="search" title="Search" href="https://graph-tool.skewed.de/static/doc/search.html" />
    <script type="text/javascript">
      var _gaq = _gaq || [];
      var pluginUrl =
        '//www.google-analytics.com/plugins/ga/inpage_linkid.js';
      _gaq.push(['_require', 'inpage_linkid', pluginUrl]);
      _gaq.push(['_setAccount', 'UA-248813-2']);
      _gaq.push(['_setDomainName', '.skewed.de']);
      _gaq.push(['_trackPageview']);
      (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
      })();
    </script>
     

  </head><body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="https://graph-tool.skewed.de/static/doc/genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="https://graph-tool.skewed.de/static/doc/py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
    <li><img src="../../../../img/graph-icon.png" alt="logo" style="margin-right: 5px; margin-bottom:-2px;" /><a href="https://graph-tool.skewed.de/">Project Homepage</a> &raquo;</li>
    
        <li class="nav-item nav-item-0"><a href="../../../../doc">graph-tool 2.27 documentation</a> &#187;</li>

          <li class="nav-item nav-item-1"><a href="../index.html" >Module code</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="../graph_tool.html" accesskey="U">graph_tool</a> &#187;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <h1>Source code for graph_tool.topology</h1><div class="highlight"><pre>
<span></span><span class="ch">#! /usr/bin/env python</span>
<span class="c1"># -*- coding: utf-8 -*-</span>
<span class="c1">#</span>
<span class="c1"># graph_tool -- a general graph manipulation python module</span>
<span class="c1">#</span>
<span class="c1"># Copyright (C) 2006-2018 Tiago de Paula Peixoto &lt;tiago@skewed.de&gt;</span>
<span class="c1">#</span>
<span class="c1"># This program is free software: you can redistribute it and/or modify</span>
<span class="c1"># it under the terms of the GNU General Public License as published by</span>
<span class="c1"># the Free Software Foundation, either version 3 of the License, or</span>
<span class="c1"># (at your option) any later version.</span>
<span class="c1">#</span>
<span class="c1"># This program is distributed in the hope that it will be useful,</span>
<span class="c1"># but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="c1"># MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
<span class="c1"># GNU General Public License for more details.</span>
<span class="c1">#</span>
<span class="c1"># You should have received a copy of the GNU General Public License</span>
<span class="c1"># along with this program.  If not, see &lt;http://www.gnu.org/licenses/&gt;.</span>

<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">``graph_tool.topology`` - Assessing graph topology</span>
<span class="sd">--------------------------------------------------</span>

<span class="sd">Summary</span>
<span class="sd">+++++++</span>

<span class="sd">.. autosummary::</span>
<span class="sd">   :nosignatures:</span>

<span class="sd">   shortest_distance</span>
<span class="sd">   shortest_path</span>
<span class="sd">   all_shortest_paths</span>
<span class="sd">   all_predecessors</span>
<span class="sd">   all_paths</span>
<span class="sd">   all_circuits</span>
<span class="sd">   pseudo_diameter</span>
<span class="sd">   similarity</span>
<span class="sd">   vertex_similarity</span>
<span class="sd">   isomorphism</span>
<span class="sd">   subgraph_isomorphism</span>
<span class="sd">   mark_subgraph</span>
<span class="sd">   max_cardinality_matching</span>
<span class="sd">   max_independent_vertex_set</span>
<span class="sd">   min_spanning_tree</span>
<span class="sd">   random_spanning_tree</span>
<span class="sd">   dominator_tree</span>
<span class="sd">   topological_sort</span>
<span class="sd">   transitive_closure</span>
<span class="sd">   tsp_tour</span>
<span class="sd">   sequential_vertex_coloring</span>
<span class="sd">   label_components</span>
<span class="sd">   label_biconnected_components</span>
<span class="sd">   label_largest_component</span>
<span class="sd">   label_out_component</span>
<span class="sd">   vertex_percolation</span>
<span class="sd">   edge_percolation</span>
<span class="sd">   kcore_decomposition</span>
<span class="sd">   is_bipartite</span>
<span class="sd">   is_DAG</span>
<span class="sd">   is_planar</span>
<span class="sd">   make_maximal_planar</span>
<span class="sd">   edge_reciprocity</span>

<span class="sd">Contents</span>
<span class="sd">++++++++</span>

<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">from</span> <span class="nn">__future__</span> <span class="k">import</span> <span class="n">division</span><span class="p">,</span> <span class="n">absolute_import</span><span class="p">,</span> <span class="n">print_function</span>

<span class="kn">from</span> <span class="nn">..</span> <span class="n">dl_import</span> <span class="kn">import</span> <span class="nn">dl_import</span>
<span class="n">dl_import</span><span class="p">(</span><span class="s2">&quot;from . import libgraph_tool_topology&quot;</span><span class="p">)</span>

<span class="kn">from</span> <span class="nn">..</span> <span class="k">import</span> <span class="n">_prop</span><span class="p">,</span> <span class="n">Vector_int32_t</span><span class="p">,</span> <span class="n">_check_prop_writable</span><span class="p">,</span> \
     <span class="n">_check_prop_scalar</span><span class="p">,</span> <span class="n">_check_prop_vector</span><span class="p">,</span> <span class="n">Graph</span><span class="p">,</span> <span class="n">PropertyMap</span><span class="p">,</span> <span class="n">GraphView</span><span class="p">,</span>\
     <span class="n">libcore</span><span class="p">,</span> <span class="n">_get_rng</span><span class="p">,</span> <span class="n">_degree</span><span class="p">,</span> <span class="n">perfect_prop_hash</span><span class="p">,</span> <span class="n">_limit_args</span>
<span class="kn">from</span> <span class="nn">..</span> <span class="n">stats</span> <span class="kn">import</span> <span class="nn">label_self_loops</span>
<span class="kn">import</span> <span class="nn">random</span><span class="o">,</span> <span class="nn">sys</span><span class="o">,</span> <span class="nn">numpy</span><span class="o">,</span> <span class="nn">collections</span>

<span class="n">__all__</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;isomorphism&quot;</span><span class="p">,</span> <span class="s2">&quot;subgraph_isomorphism&quot;</span><span class="p">,</span> <span class="s2">&quot;mark_subgraph&quot;</span><span class="p">,</span>
           <span class="s2">&quot;max_cardinality_matching&quot;</span><span class="p">,</span> <span class="s2">&quot;max_independent_vertex_set&quot;</span><span class="p">,</span>
           <span class="s2">&quot;min_spanning_tree&quot;</span><span class="p">,</span> <span class="s2">&quot;random_spanning_tree&quot;</span><span class="p">,</span> <span class="s2">&quot;dominator_tree&quot;</span><span class="p">,</span>
           <span class="s2">&quot;topological_sort&quot;</span><span class="p">,</span> <span class="s2">&quot;transitive_closure&quot;</span><span class="p">,</span> <span class="s2">&quot;tsp_tour&quot;</span><span class="p">,</span>
           <span class="s2">&quot;sequential_vertex_coloring&quot;</span><span class="p">,</span> <span class="s2">&quot;label_components&quot;</span><span class="p">,</span>
           <span class="s2">&quot;label_largest_component&quot;</span><span class="p">,</span> <span class="s2">&quot;label_biconnected_components&quot;</span><span class="p">,</span>
           <span class="s2">&quot;label_out_component&quot;</span><span class="p">,</span> <span class="s2">&quot;vertex_percolation&quot;</span><span class="p">,</span> <span class="s2">&quot;edge_percolation&quot;</span><span class="p">,</span>
           <span class="s2">&quot;kcore_decomposition&quot;</span><span class="p">,</span> <span class="s2">&quot;shortest_distance&quot;</span><span class="p">,</span> <span class="s2">&quot;shortest_path&quot;</span><span class="p">,</span>
           <span class="s2">&quot;all_shortest_paths&quot;</span><span class="p">,</span> <span class="s2">&quot;all_predecessors&quot;</span><span class="p">,</span> <span class="s2">&quot;all_paths&quot;</span><span class="p">,</span>
           <span class="s2">&quot;all_circuits&quot;</span><span class="p">,</span> <span class="s2">&quot;pseudo_diameter&quot;</span><span class="p">,</span> <span class="s2">&quot;is_bipartite&quot;</span><span class="p">,</span> <span class="s2">&quot;is_DAG&quot;</span><span class="p">,</span>
           <span class="s2">&quot;is_planar&quot;</span><span class="p">,</span> <span class="s2">&quot;make_maximal_planar&quot;</span><span class="p">,</span> <span class="s2">&quot;similarity&quot;</span><span class="p">,</span> <span class="s2">&quot;vertex_similarity&quot;</span><span class="p">,</span>
           <span class="s2">&quot;edge_reciprocity&quot;</span><span class="p">]</span>

<div class="viewcode-block" id="similarity"><a class="viewcode-back" href="../../../../doc/topology.html#graph_tool.topology.similarity">[docs]</a><span class="k">def</span> <span class="nf">similarity</span><span class="p">(</span><span class="n">g1</span><span class="p">,</span> <span class="n">g2</span><span class="p">,</span> <span class="n">eweight1</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">eweight2</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">label1</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">label2</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
               <span class="n">norm</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">p</span><span class="o">=</span><span class="mf">1.</span><span class="p">,</span> <span class="n">distance</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">asymmetric</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;Return the adjacency similarity between the two graphs.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    g1 : :class:`~graph_tool.Graph`</span>
<span class="sd">        First graph to be compared.</span>
<span class="sd">    g2 : :class:`~graph_tool.Graph`</span>
<span class="sd">        Second graph to be compared.</span>
<span class="sd">    eweight1 : :class:`~graph_tool.PropertyMap` (optional, default: ``None``)</span>
<span class="sd">        Edge weights for the first graph to be used in comparison.</span>
<span class="sd">    eweight2 : :class:`~graph_tool.PropertyMap` (optional, default: ``None``)</span>
<span class="sd">        Edge weights for the second graph to be used in comparison.</span>
<span class="sd">    label1 : :class:`~graph_tool.PropertyMap` (optional, default: ``None``)</span>
<span class="sd">        Vertex labels for the first graph to be used in comparison. If not</span>
<span class="sd">        supplied, the vertex indexes are used.</span>
<span class="sd">    label2 : :class:`~graph_tool.PropertyMap` (optional, default: ``None``)</span>
<span class="sd">        Vertex labels for the second graph to be used in comparison. If not</span>
<span class="sd">        supplied, the vertex indexes are used.</span>
<span class="sd">    norm : bool (optional, default: ``True``)</span>
<span class="sd">        If ``True``, the returned value is normalized by the total number of</span>
<span class="sd">        edges.</span>
<span class="sd">    p : float (optional, default: ``1.``)</span>
<span class="sd">        Exponent of the :math:`L^p` distance function.</span>
<span class="sd">    distance : bool (optional, default: ``False``)</span>
<span class="sd">        If ``True``, the complementary value is returned, i.e. the distance</span>
<span class="sd">        between the two graphs.</span>
<span class="sd">    asymmetric : bool (optional, default: ``False``)</span>
<span class="sd">        If ``True``, the asymmetric similarity of ``g1`` to ``g2`` will be</span>
<span class="sd">        computed.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    similarity : float</span>
<span class="sd">        Adjacency similarity value.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    In its default parametrization, the adjacency similarity is the sum of equal</span>
<span class="sd">    non-zero entries in the adjacency matrix, given a vertex ordering determined</span>
<span class="sd">    by the vertex labels. In other words, it counts the number of edges which</span>
<span class="sd">    have the same source and target labels in both graphs. This function also</span>
<span class="sd">    allows for generalized similarities according to an :math:`L^p` norm, for</span>
<span class="sd">    arbitrary :math:`p`.</span>

<span class="sd">    More specifically, it is defined as:</span>

<span class="sd">    .. math::</span>

<span class="sd">       S(\boldsymbol A_1, \boldsymbol A_2) = E - d(\boldsymbol A_1, \boldsymbol A_2)</span>

<span class="sd">    where</span>

<span class="sd">    .. math::</span>

<span class="sd">       d(\boldsymbol A_1, \boldsymbol A_2) = \left(\sum_{i\le j} \left|A_{ij}^{(1)} - A_{ij}^{(2)}\right|^p\right)^{1/p}</span>

<span class="sd">    is the distance between graphs, and :math:`E=(\sum_{i\le j}|A_{ij}^{(1)}|^p +</span>
<span class="sd">    |A_{ij}^{(2)}|^p)^{1/p}`. Unless otherwise stated via the parameter ``p``,</span>
<span class="sd">    the exponent used is :math:`p=1`. This definition holds for undirected</span>
<span class="sd">    graphs, otherwise the sums go over all directed pairs. If weights are</span>
<span class="sd">    provided, the weighted adjacency matrix is used.</span>

<span class="sd">    If ``norm == True`` the value returned is :math:`S(\boldsymbol A_1,</span>
<span class="sd">    \boldsymbol A_2) / E`, which lies in the interval :math:`[0,1]`.</span>

<span class="sd">    If ``asymmetric == True``, the above is changed so that the comparison is</span>
<span class="sd">    made only for entries in :math:`\boldsymbol A_1` that are larger than in :math:`\boldsymbol A_2`, i.e.</span>

<span class="sd">    .. math::</span>

<span class="sd">       d(\boldsymbol A_1, \boldsymbol A_2) = \left(\sum_{i\le j} \left(A_{ij}^{(1)} - A_{ij}^{(2)}\right)^p H(A_{ij}^{(1)} - A_{ij}^{(2)})\right)^{1/p},</span>

<span class="sd">    where :math:`H(x)` is the unit step function, and the total sum is changed</span>
<span class="sd">    accordingly to :math:`E=\left(\sum_{i\le j}|A_{ij}^{(1)}|^p\right)^{1/p}`.</span>

<span class="sd">    The algorithm runs with complexity :math:`O(E_1 + V_1 + E_2 + V_2)`.</span>

<span class="sd">    If enabled during compilation, and the vertex labels are integers bounded by</span>
<span class="sd">    the sizes of the graphs, this algorithm runs in parallel.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    .. testcode::</span>
<span class="sd">       :hide:</span>

<span class="sd">       import numpy.random</span>
<span class="sd">       numpy.random.seed(42)</span>
<span class="sd">       gt.seed_rng(42)</span>

<span class="sd">    &gt;&gt;&gt; g = gt.random_graph(100, lambda: (3,3))</span>
<span class="sd">    &gt;&gt;&gt; u = g.copy()</span>
<span class="sd">    &gt;&gt;&gt; gt.similarity(u, g)</span>
<span class="sd">    1.0</span>
<span class="sd">    &gt;&gt;&gt; gt.random_rewire(u)</span>
<span class="sd">    22</span>
<span class="sd">    &gt;&gt;&gt; gt.similarity(u, g)</span>
<span class="sd">    0.04666666666666667</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="n">label1</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">label1</span> <span class="o">=</span> <span class="n">g1</span><span class="o">.</span><span class="n">vertex_index</span>
    <span class="k">if</span> <span class="n">label2</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">label2</span> <span class="o">=</span> <span class="n">g2</span><span class="o">.</span><span class="n">vertex_index</span>

    <span class="n">_check_prop_scalar</span><span class="p">(</span><span class="n">label1</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;label1&quot;</span><span class="p">)</span>
    <span class="n">_check_prop_scalar</span><span class="p">(</span><span class="n">label2</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;label2&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">label1</span><span class="o">.</span><span class="n">value_type</span><span class="p">()</span> <span class="o">!=</span> <span class="n">label2</span><span class="o">.</span><span class="n">value_type</span><span class="p">():</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">label2</span> <span class="o">=</span> <span class="n">label2</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">label1</span><span class="o">.</span><span class="n">value_type</span><span class="p">())</span>
        <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
            <span class="n">label1</span> <span class="o">=</span> <span class="n">label1</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">label2</span><span class="o">.</span><span class="n">value_type</span><span class="p">())</span>

    <span class="k">if</span> <span class="n">eweight1</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">eweight2</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">ew1</span> <span class="o">=</span> <span class="n">ew2</span> <span class="o">=</span> <span class="n">libcore</span><span class="o">.</span><span class="n">any</span><span class="p">()</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">eweight1</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">eweight1</span> <span class="o">=</span> <span class="n">g1</span><span class="o">.</span><span class="n">new_ep</span><span class="p">(</span><span class="n">eweight2</span><span class="o">.</span><span class="n">value_type</span><span class="p">(),</span> <span class="mi">1</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">eweight2</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">eweight2</span> <span class="o">=</span> <span class="n">g2</span><span class="o">.</span><span class="n">new_ep</span><span class="p">(</span><span class="n">eweight1</span><span class="o">.</span><span class="n">value_type</span><span class="p">(),</span> <span class="mi">1</span><span class="p">)</span>

        <span class="n">_check_prop_scalar</span><span class="p">(</span><span class="n">eweight1</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;eweight1&quot;</span><span class="p">)</span>
        <span class="n">_check_prop_scalar</span><span class="p">(</span><span class="n">eweight2</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;eweight2&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">eweight1</span><span class="o">.</span><span class="n">value_type</span><span class="p">()</span> <span class="o">!=</span> <span class="n">eweight2</span><span class="o">.</span><span class="n">value_type</span><span class="p">():</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">eweight2</span> <span class="o">=</span> <span class="n">eweight2</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">eweight1</span><span class="o">.</span><span class="n">value_type</span><span class="p">())</span>
            <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
                <span class="n">eweight1</span> <span class="o">=</span> <span class="n">eweight1</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">eweight2</span><span class="o">.</span><span class="n">value_type</span><span class="p">())</span>

        <span class="n">ew1</span> <span class="o">=</span> <span class="n">_prop</span><span class="p">(</span><span class="s2">&quot;e&quot;</span><span class="p">,</span> <span class="n">g1</span><span class="p">,</span> <span class="n">eweight1</span><span class="p">)</span>
        <span class="n">ew2</span> <span class="o">=</span> <span class="n">_prop</span><span class="p">(</span><span class="s2">&quot;e&quot;</span><span class="p">,</span> <span class="n">g2</span><span class="p">,</span> <span class="n">eweight2</span><span class="p">)</span>

    <span class="k">if</span> <span class="p">((</span><span class="n">label1</span><span class="o">.</span><span class="n">is_writable</span><span class="p">()</span> <span class="ow">and</span> <span class="n">label1</span><span class="o">.</span><span class="n">fa</span><span class="o">.</span><span class="n">max</span><span class="p">()</span> <span class="o">&gt;</span> <span class="n">g1</span><span class="o">.</span><span class="n">num_vertices</span><span class="p">())</span> <span class="ow">or</span>
        <span class="p">(</span><span class="n">label2</span><span class="o">.</span><span class="n">is_writable</span><span class="p">()</span> <span class="ow">and</span> <span class="n">label2</span><span class="o">.</span><span class="n">fa</span><span class="o">.</span><span class="n">max</span><span class="p">()</span> <span class="o">&gt;</span> <span class="n">g2</span><span class="o">.</span><span class="n">num_vertices</span><span class="p">())):</span>
        <span class="n">s</span> <span class="o">=</span> <span class="n">libgraph_tool_topology</span><span class="o">.</span>\
               <span class="n">similarity</span><span class="p">(</span><span class="n">g1</span><span class="o">.</span><span class="n">_Graph__graph</span><span class="p">,</span> <span class="n">g2</span><span class="o">.</span><span class="n">_Graph__graph</span><span class="p">,</span>
                          <span class="n">ew1</span><span class="p">,</span> <span class="n">ew2</span><span class="p">,</span> <span class="n">_prop</span><span class="p">(</span><span class="s2">&quot;v&quot;</span><span class="p">,</span> <span class="n">g1</span><span class="p">,</span> <span class="n">label1</span><span class="p">),</span>
                          <span class="n">_prop</span><span class="p">(</span><span class="s2">&quot;v&quot;</span><span class="p">,</span> <span class="n">g2</span><span class="p">,</span> <span class="n">label2</span><span class="p">),</span> <span class="n">p</span><span class="p">,</span> <span class="n">asymmetric</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">s</span> <span class="o">=</span> <span class="n">libgraph_tool_topology</span><span class="o">.</span>\
               <span class="n">similarity_fast</span><span class="p">(</span><span class="n">g1</span><span class="o">.</span><span class="n">_Graph__graph</span><span class="p">,</span> <span class="n">g2</span><span class="o">.</span><span class="n">_Graph__graph</span><span class="p">,</span>
                               <span class="n">ew1</span><span class="p">,</span> <span class="n">ew2</span><span class="p">,</span> <span class="n">_prop</span><span class="p">(</span><span class="s2">&quot;v&quot;</span><span class="p">,</span> <span class="n">g1</span><span class="p">,</span> <span class="n">label1</span><span class="p">),</span>
                               <span class="n">_prop</span><span class="p">(</span><span class="s2">&quot;v&quot;</span><span class="p">,</span> <span class="n">g2</span><span class="p">,</span> <span class="n">label2</span><span class="p">),</span> <span class="n">p</span><span class="p">,</span> <span class="n">asymmetric</span><span class="p">)</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">g1</span><span class="o">.</span><span class="n">is_directed</span><span class="p">()</span> <span class="ow">or</span> <span class="ow">not</span> <span class="n">g2</span><span class="o">.</span><span class="n">is_directed</span><span class="p">():</span>
        <span class="n">s</span> <span class="o">//=</span> <span class="mi">2</span>

    <span class="n">s</span> <span class="o">**=</span> <span class="mf">1.</span><span class="o">/</span><span class="n">p</span>

    <span class="k">if</span> <span class="n">eweight1</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">eweight1</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">asymmetric</span><span class="p">:</span>
            <span class="n">E</span> <span class="o">=</span> <span class="n">g1</span><span class="o">.</span><span class="n">num_edges</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">E</span> <span class="o">=</span> <span class="n">g1</span><span class="o">.</span><span class="n">num_edges</span><span class="p">()</span> <span class="o">+</span> <span class="n">g2</span><span class="o">.</span><span class="n">num_edges</span><span class="p">()</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">asymmetric</span><span class="p">:</span>
            <span class="n">E</span> <span class="o">=</span> <span class="nb">float</span><span class="p">((</span><span class="nb">abs</span><span class="p">(</span><span class="n">eweight1</span><span class="o">.</span><span class="n">fa</span><span class="p">)</span><span class="o">**</span><span class="n">p</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">())</span> <span class="o">**</span> <span class="p">(</span><span class="mf">1.</span><span class="o">/</span><span class="n">p</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">E</span> <span class="o">=</span> <span class="nb">float</span><span class="p">((</span><span class="nb">abs</span><span class="p">(</span><span class="n">eweight1</span><span class="o">.</span><span class="n">fa</span><span class="p">)</span><span class="o">**</span><span class="n">p</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span> <span class="o">+</span>
                      <span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">eweight2</span><span class="o">.</span><span class="n">fa</span><span class="p">)</span><span class="o">**</span><span class="n">p</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">())</span> <span class="o">**</span> <span class="p">(</span><span class="mf">1.</span><span class="o">/</span><span class="n">p</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">distance</span><span class="p">:</span>
        <span class="n">s</span> <span class="o">=</span> <span class="n">E</span> <span class="o">-</span> <span class="n">s</span>
    <span class="k">if</span> <span class="n">norm</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">s</span> <span class="o">/</span> <span class="n">E</span>
    <span class="k">return</span> <span class="n">s</span></div>

<div class="viewcode-block" id="vertex_similarity"><a class="viewcode-back" href="../../../../doc/topology.html#graph_tool.topology.vertex_similarity">[docs]</a><span class="nd">@_limit_args</span><span class="p">({</span><span class="s2">&quot;sim_type&quot;</span><span class="p">:</span> <span class="p">[</span><span class="s2">&quot;dice&quot;</span><span class="p">,</span> <span class="s2">&quot;jaccard&quot;</span><span class="p">,</span> <span class="s2">&quot;inv-log-weight&quot;</span><span class="p">]})</span>
<span class="k">def</span> <span class="nf">vertex_similarity</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">sim_type</span><span class="o">=</span><span class="s2">&quot;jaccard&quot;</span><span class="p">,</span> <span class="n">vertex_pairs</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">self_loops</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                      <span class="n">sim_map</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;Return the similarity between pairs of vertices.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    g : :class:`~graph_tool.Graph`</span>
<span class="sd">        The graph to be used.</span>
<span class="sd">    sim_type : ``str`` (optional, default: ``&quot;jaccard&quot;``)</span>
<span class="sd">        Type of similarity to use. This must be one of ``&quot;dice&quot;``, ``&quot;jaccard&quot;``</span>
<span class="sd">        or ``&quot;inv-log-weight&quot;``.</span>
<span class="sd">    vertex_pairs : iterable of pairs of integers (optional, default: ``None``)</span>
<span class="sd">        Pairs of vertices to compute the similarity. If omitted, all pairs will</span>
<span class="sd">        be considered.</span>
<span class="sd">    self_loops : bool (optional, default: ``True``)</span>
<span class="sd">        If ``True``, vertices will be considered adjacent to themselves for the</span>
<span class="sd">        purpose of the similarity computation.</span>
<span class="sd">    sim_map : :class:`~graph_tool.PropertyMap` (optional, default: ``None``)</span>
<span class="sd">        If provided, and ``vertex_pairs is None``, the vertex similarities will</span>
<span class="sd">        be stored in this vector-valued property. Otherwise, a new one will be</span>
<span class="sd">        created.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    similarities : :class:`numpy.ndarray` or :class:`~graph_tool.PropertyMap`</span>
<span class="sd">        If ``vertex_pairs`` was supplied, this will be a :class:`numpy.ndarray`</span>
<span class="sd">        with the corresponding similarities, otherwise it will be a</span>
<span class="sd">        vector-valued vertex :class:`~graph_tool.PropertyMap`, with the</span>
<span class="sd">        similarities to all other vertices.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    According to ``sim_type``, this function computes the following similarities:</span>

<span class="sd">    ``sim_type == &quot;dice&quot;``</span>

<span class="sd">       The Sørensen–Dice similarity [sorensen-dice]_ is twice the number of</span>
<span class="sd">       common neighbors between two vertices divided by the sum of their</span>
<span class="sd">       degrees.</span>

<span class="sd">    ``sim_type == &quot;jaccard&quot;``</span>

<span class="sd">       The Jaccard similarity [jaccard]_ is the number of common neighbors</span>
<span class="sd">       between two vertices divided by the size of the set of all neighbors to</span>
<span class="sd">       both vertices.</span>

<span class="sd">    ``sim_type == &quot;inv-log-weight&quot;``</span>

<span class="sd">       The inverse log weighted similarity [adamic-friends-2003]_ is the sum of</span>
<span class="sd">       the weights of common neighbors between two vertices, where the weights</span>
<span class="sd">       are computed as :math:`1/\log(k)`, with :math:`k` being the degree of the</span>
<span class="sd">       vertex.</span>


<span class="sd">    For directed graphs, only out-neighbors are considered in the above</span>
<span class="sd">    algorthms (for &quot;inv-log-weight&quot;, the in-degrees are used to compute the</span>
<span class="sd">    weights). To use the in-neighbors instead, a :class:`~graph_tool.GraphView`</span>
<span class="sd">    should be used to reverse the graph, e.g. ``vertex_similarity(GraphView(g,</span>
<span class="sd">    reversed=True))``.</span>

<span class="sd">    The algorithm runs with complexity :math:`O(\left&lt;k\right&gt;N^2)` if</span>
<span class="sd">    ``vertex_pairs is None``, otherwise with :math:`O(\left&lt;k\right&gt;P)` where</span>
<span class="sd">    :math:`P` is the length of ``vertex_pairs``.</span>

<span class="sd">    If enabled during compilation, this algorithm runs in parallel.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    .. testcode::</span>
<span class="sd">       :hide:</span>

<span class="sd">       import matplotlib</span>

<span class="sd">    &gt;&gt;&gt; g = gt.collection.data[&quot;polbooks&quot;]</span>
<span class="sd">    &gt;&gt;&gt; s = gt.vertex_similarity(g, &quot;jaccard&quot;)</span>
<span class="sd">    &gt;&gt;&gt; color = g.new_vp(&quot;double&quot;)</span>
<span class="sd">    &gt;&gt;&gt; color.a = s[0].a</span>
<span class="sd">    &gt;&gt;&gt; gt.graph_draw(g, pos=g.vp.pos, vertex_text=g.vertex_index,</span>
<span class="sd">    ...               vertex_color=color, vertex_fill_color=color,</span>
<span class="sd">    ...               vcmap=matplotlib.cm.inferno,</span>
<span class="sd">    ...               output=&quot;polbooks-jaccard.pdf&quot;)</span>
<span class="sd">    &lt;...&gt;</span>

<span class="sd">    .. testcode::</span>
<span class="sd">       :hide:</span>

<span class="sd">       gt.graph_draw(g, pos=g.vp.pos, vertex_text=g.vertex_index,</span>
<span class="sd">                     vertex_color=color, vertex_fill_color=color,</span>
<span class="sd">                     vcmap=matplotlib.cm.inferno,</span>
<span class="sd">                     output=&quot;polbooks-jaccard.png&quot;)</span>

<span class="sd">    .. figure:: polbooks-jaccard.*</span>
<span class="sd">       :align: center</span>

<span class="sd">       Jaccard similarities to vertex ``0`` in a political books network.</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    .. [sorensen-dice] https://en.wikipedia.org/wiki/S%C3%B8rensen%E2%80%93Dice_coefficient</span>
<span class="sd">    .. [jaccard] https://en.wikipedia.org/wiki/Jaccard_index</span>
<span class="sd">    .. [adamic-friends-2003] Lada A. Adamic and Eytan Adar, &quot;Friends and neighbors</span>
<span class="sd">       on the Web&quot;, Social Networks Volume 25, Issue 3, Pages 211–230 (2003)</span>
<span class="sd">       :doi:`10.1016/S0378-8733(03)00009-1`</span>
<span class="sd">    .. [liben-nowell-link-prediction-2007] David Liben-Nowell and Jon Kleinberg,</span>
<span class="sd">       &quot;The link-prediction problem for social networks&quot;, Journal of the</span>
<span class="sd">       American Society for Information Science and Technology, Volume 58, Issue</span>
<span class="sd">       7, pages 1019–1031 (2007), :doi:`10.1002/asi.20591`</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="n">vertex_pairs</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">sim_map</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">s</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">new_vp</span><span class="p">(</span><span class="s2">&quot;vector&lt;double&gt;&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">s</span> <span class="o">=</span> <span class="n">sim_map</span>
        <span class="k">if</span> <span class="n">sim_type</span> <span class="o">==</span> <span class="s2">&quot;dice&quot;</span><span class="p">:</span>
            <span class="n">libgraph_tool_topology</span><span class="o">.</span><span class="n">dice_similarity</span><span class="p">(</span><span class="n">g</span><span class="o">.</span><span class="n">_Graph__graph</span><span class="p">,</span>
                                                   <span class="n">_prop</span><span class="p">(</span><span class="s2">&quot;v&quot;</span><span class="p">,</span> <span class="n">g</span><span class="p">,</span> <span class="n">s</span><span class="p">),</span>
                                                   <span class="n">self_loops</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">sim_type</span> <span class="o">==</span> <span class="s2">&quot;jaccard&quot;</span><span class="p">:</span>
            <span class="n">libgraph_tool_topology</span><span class="o">.</span><span class="n">jaccard_similarity</span><span class="p">(</span><span class="n">g</span><span class="o">.</span><span class="n">_Graph__graph</span><span class="p">,</span>
                                                      <span class="n">_prop</span><span class="p">(</span><span class="s2">&quot;v&quot;</span><span class="p">,</span> <span class="n">g</span><span class="p">,</span> <span class="n">s</span><span class="p">),</span>
                                                      <span class="n">self_loops</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">sim_type</span> <span class="o">==</span> <span class="s2">&quot;inv-log-weight&quot;</span><span class="p">:</span>
            <span class="n">libgraph_tool_topology</span><span class="o">.</span><span class="n">inv_log_weight_similarity</span><span class="p">(</span><span class="n">g</span><span class="o">.</span><span class="n">_Graph__graph</span><span class="p">,</span>
                                                             <span class="n">_prop</span><span class="p">(</span><span class="s2">&quot;v&quot;</span><span class="p">,</span> <span class="n">g</span><span class="p">,</span> <span class="n">s</span><span class="p">))</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">vertex_pairs</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">vertex_pairs</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="s2">&quot;int64&quot;</span><span class="p">)</span>
        <span class="n">s</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">vertex_pairs</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="s2">&quot;double&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">sim_type</span> <span class="o">==</span> <span class="s2">&quot;dice&quot;</span><span class="p">:</span>
            <span class="n">libgraph_tool_topology</span><span class="o">.</span><span class="n">dice_similarity_pairs</span><span class="p">(</span><span class="n">g</span><span class="o">.</span><span class="n">_Graph__graph</span><span class="p">,</span>
                                                         <span class="n">vertex_pairs</span><span class="p">,</span>
                                                         <span class="n">s</span><span class="p">,</span> <span class="n">self_loops</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">sim_type</span> <span class="o">==</span> <span class="s2">&quot;jaccard&quot;</span><span class="p">:</span>
            <span class="n">libgraph_tool_topology</span><span class="o">.</span><span class="n">jaccard_similarity_pairs</span><span class="p">(</span><span class="n">g</span><span class="o">.</span><span class="n">_Graph__graph</span><span class="p">,</span>
                                                            <span class="n">vertex_pairs</span><span class="p">,</span>
                                                            <span class="n">s</span><span class="p">,</span> <span class="n">self_loops</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">sim_type</span> <span class="o">==</span> <span class="s2">&quot;inv-log-weight&quot;</span><span class="p">:</span>
            <span class="n">libgraph_tool_topology</span><span class="o">.</span>\
                <span class="n">inv_log_weight_similarity_pairs</span><span class="p">(</span><span class="n">g</span><span class="o">.</span><span class="n">_Graph__graph</span><span class="p">,</span> <span class="n">vertex_pairs</span><span class="p">,</span>
                                                <span class="n">s</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">s</span></div>


<div class="viewcode-block" id="isomorphism"><a class="viewcode-back" href="../../../../doc/topology.html#graph_tool.topology.isomorphism">[docs]</a><span class="k">def</span> <span class="nf">isomorphism</span><span class="p">(</span><span class="n">g1</span><span class="p">,</span> <span class="n">g2</span><span class="p">,</span> <span class="n">vertex_inv1</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">vertex_inv2</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">isomap</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;Check whether two graphs are isomorphic.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    g1 : :class:`~graph_tool.Graph`</span>
<span class="sd">        First graph.</span>
<span class="sd">    g2 : :class:`~graph_tool.Graph`</span>
<span class="sd">        Second graph.</span>
<span class="sd">    vertex_inv1 : :class:`~graph_tool.PropertyMap` (optional, default: `None`)</span>
<span class="sd">        Vertex invariant of the first graph. Only vertices with with the same</span>
<span class="sd">        invariants are considered in the isomorphism.</span>
<span class="sd">    vertex_inv2 : :class:`~graph_tool.PropertyMap` (optional, default: `None`)</span>
<span class="sd">        Vertex invariant of the second graph. Only vertices with with the same</span>
<span class="sd">        invariants are considered in the isomorphism.</span>
<span class="sd">    isomap : ``bool`` (optional, default: ``False``)</span>
<span class="sd">        If ``True``, a vertex :class:`~graph_tool.PropertyMap` with the</span>
<span class="sd">        isomorphism mapping is returned as well.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    is_isomorphism : ``bool``</span>
<span class="sd">        ``True`` if both graphs are isomorphic, otherwise ``False``.</span>
<span class="sd">    isomap : :class:`~graph_tool.PropertyMap`</span>
<span class="sd">         Isomorphism mapping corresponding to a property map belonging to the</span>
<span class="sd">         first graph which maps its vertices to their corresponding vertices of</span>
<span class="sd">         the second graph.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    .. testcode::</span>
<span class="sd">       :hide:</span>

<span class="sd">       import numpy.random</span>
<span class="sd">       numpy.random.seed(42)</span>
<span class="sd">       gt.seed_rng(42)</span>

<span class="sd">    &gt;&gt;&gt; g = gt.random_graph(100, lambda: (3,3))</span>
<span class="sd">    &gt;&gt;&gt; g2 = gt.Graph(g)</span>
<span class="sd">    &gt;&gt;&gt; gt.isomorphism(g, g2)</span>
<span class="sd">    True</span>
<span class="sd">    &gt;&gt;&gt; g.add_edge(g.vertex(0), g.vertex(1))</span>
<span class="sd">    &lt;...&gt;</span>
<span class="sd">    &gt;&gt;&gt; gt.isomorphism(g, g2)</span>
<span class="sd">    False</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">imap</span> <span class="o">=</span> <span class="n">g1</span><span class="o">.</span><span class="n">new_vertex_property</span><span class="p">(</span><span class="s2">&quot;int32_t&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">vertex_inv1</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">vertex_inv1</span> <span class="o">=</span> <span class="n">g1</span><span class="o">.</span><span class="n">degree_property_map</span><span class="p">(</span><span class="s2">&quot;total&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="s2">&quot;int64_t&quot;</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">vertex_inv1</span> <span class="o">=</span> <span class="n">vertex_inv1</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="s2">&quot;int64_t&quot;</span><span class="p">)</span>
        <span class="n">d</span> <span class="o">=</span> <span class="n">g1</span><span class="o">.</span><span class="n">degree_property_map</span><span class="p">(</span><span class="s2">&quot;total&quot;</span><span class="p">)</span>
        <span class="n">vertex_inv1</span><span class="o">.</span><span class="n">fa</span> <span class="o">+=</span> <span class="p">(</span><span class="n">vertex_inv1</span><span class="o">.</span><span class="n">fa</span><span class="o">.</span><span class="n">max</span><span class="p">()</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">d</span><span class="o">.</span><span class="n">a</span>
    <span class="k">if</span> <span class="n">vertex_inv2</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">vertex_inv2</span> <span class="o">=</span> <span class="n">g2</span><span class="o">.</span><span class="n">degree_property_map</span><span class="p">(</span><span class="s2">&quot;total&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="s2">&quot;int64_t&quot;</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">vertex_inv2</span> <span class="o">=</span> <span class="n">vertex_inv2</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="s2">&quot;int64_t&quot;</span><span class="p">)</span>
        <span class="n">d</span> <span class="o">=</span> <span class="n">g2</span><span class="o">.</span><span class="n">degree_property_map</span><span class="p">(</span><span class="s2">&quot;total&quot;</span><span class="p">)</span>
        <span class="n">vertex_inv2</span><span class="o">.</span><span class="n">fa</span> <span class="o">+=</span> <span class="p">(</span><span class="n">vertex_inv2</span><span class="o">.</span><span class="n">fa</span><span class="o">.</span><span class="n">max</span><span class="p">()</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">d</span><span class="o">.</span><span class="n">a</span>

    <span class="n">inv_max</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">vertex_inv1</span><span class="o">.</span><span class="n">fa</span><span class="o">.</span><span class="n">max</span><span class="p">(),</span><span class="n">vertex_inv2</span><span class="o">.</span><span class="n">fa</span><span class="o">.</span><span class="n">max</span><span class="p">())</span> <span class="o">+</span> <span class="mi">1</span>

    <span class="n">l1</span> <span class="o">=</span> <span class="n">label_self_loops</span><span class="p">(</span><span class="n">g1</span><span class="p">,</span> <span class="n">mark_only</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">l1</span><span class="o">.</span><span class="n">fa</span><span class="o">.</span><span class="n">max</span><span class="p">()</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">g1</span> <span class="o">=</span> <span class="n">GraphView</span><span class="p">(</span><span class="n">g1</span><span class="p">,</span> <span class="n">efilt</span><span class="o">=</span><span class="mi">1</span> <span class="o">-</span> <span class="n">l1</span><span class="o">.</span><span class="n">fa</span><span class="p">)</span>

    <span class="n">l2</span> <span class="o">=</span> <span class="n">label_self_loops</span><span class="p">(</span><span class="n">g2</span><span class="p">,</span> <span class="n">mark_only</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">l2</span><span class="o">.</span><span class="n">fa</span><span class="o">.</span><span class="n">max</span><span class="p">()</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">g2</span> <span class="o">=</span> <span class="n">GraphView</span><span class="p">(</span><span class="n">g2</span><span class="p">,</span> <span class="n">efilt</span><span class="o">=</span><span class="mi">1</span> <span class="o">-</span> <span class="n">l2</span><span class="o">.</span><span class="n">fa</span><span class="p">)</span>

    <span class="n">iso</span> <span class="o">=</span> <span class="n">libgraph_tool_topology</span><span class="o">.</span>\
           <span class="n">check_isomorphism</span><span class="p">(</span><span class="n">g1</span><span class="o">.</span><span class="n">_Graph__graph</span><span class="p">,</span> <span class="n">g2</span><span class="o">.</span><span class="n">_Graph__graph</span><span class="p">,</span>
                             <span class="n">_prop</span><span class="p">(</span><span class="s2">&quot;v&quot;</span><span class="p">,</span> <span class="n">g1</span><span class="p">,</span> <span class="n">vertex_inv1</span><span class="p">),</span>
                             <span class="n">_prop</span><span class="p">(</span><span class="s2">&quot;v&quot;</span><span class="p">,</span> <span class="n">g2</span><span class="p">,</span> <span class="n">vertex_inv2</span><span class="p">),</span>
                             <span class="n">inv_max</span><span class="p">,</span>
                             <span class="n">_prop</span><span class="p">(</span><span class="s2">&quot;v&quot;</span><span class="p">,</span> <span class="n">g1</span><span class="p">,</span> <span class="n">imap</span><span class="p">))</span>
    <span class="k">if</span> <span class="n">isomap</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">iso</span><span class="p">,</span> <span class="n">imap</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">iso</span></div>


<div class="viewcode-block" id="subgraph_isomorphism"><a class="viewcode-back" href="../../../../doc/topology.html#graph_tool.topology.subgraph_isomorphism">[docs]</a><span class="k">def</span> <span class="nf">subgraph_isomorphism</span><span class="p">(</span><span class="n">sub</span><span class="p">,</span> <span class="n">g</span><span class="p">,</span> <span class="n">max_n</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">vertex_label</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">edge_label</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                         <span class="n">induced</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">subgraph</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">generator</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;Obtain all subgraph isomorphisms of `sub` in `g` (or at most `max_n` subgraphs, if `max_n &gt; 0`).</span>


<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    sub : :class:`~graph_tool.Graph`</span>
<span class="sd">        Subgraph for which to be searched.</span>
<span class="sd">    g : :class:`~graph_tool.Graph`</span>
<span class="sd">        Graph in which the search is performed.</span>
<span class="sd">    max_n : int (optional, default: ``0``)</span>
<span class="sd">        Maximum number of matches to find. If `max_n == 0`, all matches are</span>
<span class="sd">        found.</span>
<span class="sd">    vertex_label : pair of :class:`~graph_tool.PropertyMap` (optional, default: ``None``)</span>
<span class="sd">        If provided, this should be a pair of :class:`~graph_tool.PropertyMap`</span>
<span class="sd">        objects, belonging to ``sub`` and ``g`` (in this order), which specify</span>
<span class="sd">        vertex labels which should match, in addition to the topological</span>
<span class="sd">        isomorphism.</span>
<span class="sd">    edge_label : pair of :class:`~graph_tool.PropertyMap` (optional, default: ``None``)</span>
<span class="sd">        If provided, this should be a pair of :class:`~graph_tool.PropertyMap`</span>
<span class="sd">        objects, belonging to ``sub`` and ``g`` (in this order), which specify</span>
<span class="sd">        edge labels which should match, in addition to the topological</span>
<span class="sd">        isomorphism.</span>
<span class="sd">    induced : bool (optional, default: ``False``)</span>
<span class="sd">        If ``True``, only node-induced subgraphs are found.</span>
<span class="sd">    subgraph : bool (optional, default: ``True``)</span>
<span class="sd">        If ``False``, all non-subgraph isomorphisms between `sub` and `g` are</span>
<span class="sd">        found.</span>
<span class="sd">    generator : bool (optional, default: ``False``)</span>
<span class="sd">        If ``True``, a generator will be returned, instead of a list. This is</span>
<span class="sd">        useful if the number of isomorphisms is too large to store in memory. If</span>
<span class="sd">        ``generator == True``, the option ``max_n`` is ignored.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    vertex_maps : list (or generator) of :class:`~graph_tool.PropertyMap` objects</span>
<span class="sd">        List (or generator) containing vertex property map objects which</span>
<span class="sd">        indicate different isomorphism mappings. The property maps vertices in</span>
<span class="sd">        `sub` to the corresponding vertex index in `g`.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    The implementation is based on the VF2 algorithm, introduced by Cordella et al.</span>
<span class="sd">    [cordella-improved-2001]_ [cordella-subgraph-2004]_. The spatial complexity</span>
<span class="sd">    is of order :math:`O(V)`, where :math:`V` is the (maximum) number of vertices</span>
<span class="sd">    of the two graphs. Time complexity is :math:`O(V^2)` in the best case and</span>
<span class="sd">    :math:`O(V!\times V)` in the worst case.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; from numpy.random import poisson</span>
<span class="sd">    &gt;&gt;&gt; g = gt.complete_graph(30)</span>
<span class="sd">    &gt;&gt;&gt; sub = gt.complete_graph(10)</span>
<span class="sd">    &gt;&gt;&gt; vm = gt.subgraph_isomorphism(sub, g, max_n=100)</span>
<span class="sd">    &gt;&gt;&gt; print(len(vm))</span>
<span class="sd">    100</span>
<span class="sd">    &gt;&gt;&gt; for i in range(len(vm)):</span>
<span class="sd">    ...   g.set_vertex_filter(None)</span>
<span class="sd">    ...   g.set_edge_filter(None)</span>
<span class="sd">    ...   vmask, emask = gt.mark_subgraph(g, sub, vm[i])</span>
<span class="sd">    ...   g.set_vertex_filter(vmask)</span>
<span class="sd">    ...   g.set_edge_filter(emask)</span>
<span class="sd">    ...   assert gt.isomorphism(g, sub)</span>
<span class="sd">    &gt;&gt;&gt; g.set_vertex_filter(None)</span>
<span class="sd">    &gt;&gt;&gt; g.set_edge_filter(None)</span>
<span class="sd">    &gt;&gt;&gt; ewidth = g.copy_property(emask, value_type=&quot;double&quot;)</span>
<span class="sd">    &gt;&gt;&gt; ewidth.a += 0.5</span>
<span class="sd">    &gt;&gt;&gt; ewidth.a *= 2</span>
<span class="sd">    &gt;&gt;&gt; gt.graph_draw(g, vertex_fill_color=vmask, edge_color=emask,</span>
<span class="sd">    ...               edge_pen_width=ewidth, output_size=(200, 200),</span>
<span class="sd">    ...               output=&quot;subgraph-iso-embed.pdf&quot;)</span>
<span class="sd">    &lt;...&gt;</span>
<span class="sd">    &gt;&gt;&gt; gt.graph_draw(sub, output_size=(200, 200), output=&quot;subgraph-iso.pdf&quot;)</span>
<span class="sd">    &lt;...&gt;</span>

<span class="sd">    .. testcode::</span>
<span class="sd">       :hide:</span>

<span class="sd">       gt.graph_draw(g, vertex_fill_color=vmask, edge_color=emask,</span>
<span class="sd">                     edge_pen_width=ewidth, output_size=(200, 200),</span>
<span class="sd">                     output=&quot;subgraph-iso-embed.png&quot;)</span>
<span class="sd">       gt.graph_draw(sub, output_size=(200, 200), output=&quot;subgraph-iso.png&quot;)</span>

<span class="sd">    .. image:: subgraph-iso.*</span>
<span class="sd">    .. image:: subgraph-iso-embed.*</span>


<span class="sd">    **Left:** Subgraph searched, **Right:** One isomorphic subgraph found in main graph.</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    .. [cordella-improved-2001] L. P. Cordella, P. Foggia, C. Sansone, and M. Vento,</span>
<span class="sd">       &quot;An improved algorithm for matching large graphs.&quot;, 3rd IAPR-TC15 Workshop</span>
<span class="sd">       on Graph-based Representations in Pattern Recognition, pp. 149-159, Cuen, 2001.</span>
<span class="sd">       http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.101.5342</span>
<span class="sd">    .. [cordella-subgraph-2004] L. P. Cordella, P. Foggia, C. Sansone, and M. Vento,</span>
<span class="sd">       &quot;A (Sub)Graph Isomorphism Algorithm for Matching Large Graphs.&quot;,</span>
<span class="sd">       IEEE Trans. Pattern Anal. Mach. Intell., vol. 26, no. 10, pp. 1367-1372, 2004.</span>
<span class="sd">       :doi:`10.1109/TPAMI.2004.75`</span>
<span class="sd">    .. [boost-subgraph-iso] http://www.boost.org/libs/graph/doc/vf2_sub_graph_iso.html</span>
<span class="sd">    .. [subgraph-isormophism-wikipedia] http://en.wikipedia.org/wiki/Subgraph_isomorphism_problem</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">sub</span><span class="o">.</span><span class="n">num_vertices</span><span class="p">()</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Cannot search for an empty subgraph.&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">vertex_label</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">vertex_label</span> <span class="o">=</span> <span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">vertex_label</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">value_type</span><span class="p">()</span> <span class="o">!=</span> <span class="n">vertex_label</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">value_type</span><span class="p">():</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Both vertex label property maps must be of the same type!&quot;</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">vertex_label</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">value_type</span><span class="p">()</span> <span class="o">!=</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">:</span>
        <span class="n">vertex_label</span> <span class="o">=</span> <span class="n">perfect_prop_hash</span><span class="p">(</span><span class="n">vertex_label</span><span class="p">,</span> <span class="n">htype</span><span class="o">=</span><span class="s2">&quot;int64_t&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">edge_label</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">edge_label</span> <span class="o">=</span> <span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">edge_label</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">value_type</span><span class="p">()</span> <span class="o">!=</span> <span class="n">edge_label</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">value_type</span><span class="p">():</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Both edge label property maps must be of the same type!&quot;</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">edge_label</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">value_type</span><span class="p">()</span> <span class="o">!=</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">:</span>
        <span class="n">edge_label</span> <span class="o">=</span> <span class="n">perfect_prop_hash</span><span class="p">(</span><span class="n">edge_label</span><span class="p">,</span> <span class="n">htype</span><span class="o">=</span><span class="s2">&quot;int64_t&quot;</span><span class="p">)</span>

    <span class="n">vmaps</span> <span class="o">=</span> <span class="n">libgraph_tool_topology</span><span class="o">.</span>\
            <span class="n">subgraph_isomorphism</span><span class="p">(</span><span class="n">sub</span><span class="o">.</span><span class="n">_Graph__graph</span><span class="p">,</span> <span class="n">g</span><span class="o">.</span><span class="n">_Graph__graph</span><span class="p">,</span>
                                 <span class="n">_prop</span><span class="p">(</span><span class="s2">&quot;v&quot;</span><span class="p">,</span> <span class="n">sub</span><span class="p">,</span> <span class="n">vertex_label</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span>
                                 <span class="n">_prop</span><span class="p">(</span><span class="s2">&quot;v&quot;</span><span class="p">,</span> <span class="n">g</span><span class="p">,</span> <span class="n">vertex_label</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span>
                                 <span class="n">_prop</span><span class="p">(</span><span class="s2">&quot;e&quot;</span><span class="p">,</span> <span class="n">sub</span><span class="p">,</span> <span class="n">edge_label</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span>
                                 <span class="n">_prop</span><span class="p">(</span><span class="s2">&quot;e&quot;</span><span class="p">,</span> <span class="n">g</span><span class="p">,</span> <span class="n">edge_label</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span>
                                 <span class="n">max_n</span><span class="p">,</span> <span class="n">induced</span><span class="p">,</span> <span class="ow">not</span> <span class="n">subgraph</span><span class="p">,</span>
                                 <span class="n">generator</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">generator</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">PropertyMap</span><span class="p">(</span><span class="n">vmap</span><span class="p">,</span> <span class="n">sub</span><span class="p">,</span> <span class="s2">&quot;v&quot;</span><span class="p">)</span> <span class="k">for</span> <span class="n">vmap</span> <span class="ow">in</span> <span class="n">vmaps</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">PropertyMap</span><span class="p">(</span><span class="n">vmap</span><span class="p">,</span> <span class="n">sub</span><span class="p">,</span> <span class="s2">&quot;v&quot;</span><span class="p">)</span> <span class="k">for</span> <span class="n">vmap</span> <span class="ow">in</span> <span class="n">vmaps</span><span class="p">]</span></div>


<div class="viewcode-block" id="mark_subgraph"><a class="viewcode-back" href="../../../../doc/topology.html#graph_tool.topology.mark_subgraph">[docs]</a><span class="k">def</span> <span class="nf">mark_subgraph</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">sub</span><span class="p">,</span> <span class="n">vmap</span><span class="p">,</span> <span class="n">vmask</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">emask</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Mark a given subgraph `sub` on the graph `g`.</span>

<span class="sd">    The mapping must be provided by the `vmap` and `emap` parameters,</span>
<span class="sd">    which map vertices/edges of `sub` to indexes of the corresponding</span>
<span class="sd">    vertices/edges in `g`.</span>

<span class="sd">    This returns a vertex and an edge property map, with value type &#39;bool&#39;,</span>
<span class="sd">    indicating whether or not a vertex/edge in `g` corresponds to the subgraph</span>
<span class="sd">    `sub`.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">vmask</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">vmask</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">new_vertex_property</span><span class="p">(</span><span class="s2">&quot;bool&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">emask</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">emask</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">new_edge_property</span><span class="p">(</span><span class="s2">&quot;bool&quot;</span><span class="p">)</span>

    <span class="n">vmask</span><span class="o">.</span><span class="n">a</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="n">emask</span><span class="o">.</span><span class="n">a</span> <span class="o">=</span> <span class="kc">False</span>

    <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">sub</span><span class="o">.</span><span class="n">vertices</span><span class="p">():</span>
        <span class="n">w</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">vertex</span><span class="p">(</span><span class="n">vmap</span><span class="p">[</span><span class="n">v</span><span class="p">])</span>
        <span class="n">vmask</span><span class="p">[</span><span class="n">w</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="n">us</span> <span class="o">=</span> <span class="nb">set</span><span class="p">([</span><span class="n">g</span><span class="o">.</span><span class="n">vertex</span><span class="p">(</span><span class="n">vmap</span><span class="p">[</span><span class="n">x</span><span class="p">])</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">v</span><span class="o">.</span><span class="n">out_neighbors</span><span class="p">()])</span>

        <span class="k">for</span> <span class="n">ew</span> <span class="ow">in</span> <span class="n">w</span><span class="o">.</span><span class="n">out_edges</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">ew</span><span class="o">.</span><span class="n">target</span><span class="p">()</span> <span class="ow">in</span> <span class="n">us</span><span class="p">:</span>
                <span class="n">emask</span><span class="p">[</span><span class="n">ew</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>

    <span class="k">return</span> <span class="n">vmask</span><span class="p">,</span> <span class="n">emask</span></div>


<div class="viewcode-block" id="min_spanning_tree"><a class="viewcode-back" href="../../../../doc/topology.html#graph_tool.topology.min_spanning_tree">[docs]</a><span class="k">def</span> <span class="nf">min_spanning_tree</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">weights</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">root</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">tree_map</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return the minimum spanning tree of a given graph.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    g : :class:`~graph_tool.Graph`</span>
<span class="sd">        Graph to be used.</span>
<span class="sd">    weights : :class:`~graph_tool.PropertyMap` (optional, default: `None`)</span>
<span class="sd">        The edge weights. If provided, the minimum spanning tree will minimize</span>
<span class="sd">        the edge weights.</span>
<span class="sd">    root : :class:`~graph_tool.Vertex` (optional, default: `None`)</span>
<span class="sd">        Root of the minimum spanning tree. If this is provided, Prim&#39;s algorithm</span>
<span class="sd">        is used. Otherwise, Kruskal&#39;s algorithm is used.</span>
<span class="sd">    tree_map : :class:`~graph_tool.PropertyMap` (optional, default: `None`)</span>
<span class="sd">        If provided, the edge tree map will be written in this property map.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    tree_map : :class:`~graph_tool.PropertyMap`</span>
<span class="sd">        Edge property map with mark the tree edges: 1 for tree edge, 0</span>
<span class="sd">        otherwise.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    The algorithm runs with :math:`O(E\log E)` complexity, or :math:`O(E\log V)`</span>
<span class="sd">    if `root` is specified.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    .. testcode::</span>
<span class="sd">       :hide:</span>

<span class="sd">       import numpy.random</span>
<span class="sd">       numpy.random.seed(42)</span>
<span class="sd">       gt.seed_rng(42)</span>

<span class="sd">    &gt;&gt;&gt; from numpy.random import random</span>
<span class="sd">    &gt;&gt;&gt; g, pos = gt.triangulation(random((400, 2)) * 10, type=&quot;delaunay&quot;)</span>
<span class="sd">    &gt;&gt;&gt; weight = g.new_edge_property(&quot;double&quot;)</span>
<span class="sd">    &gt;&gt;&gt; for e in g.edges():</span>
<span class="sd">    ...    weight[e] = linalg.norm(pos[e.target()].a - pos[e.source()].a)</span>
<span class="sd">    &gt;&gt;&gt; tree = gt.min_spanning_tree(g, weights=weight)</span>
<span class="sd">    &gt;&gt;&gt; gt.graph_draw(g, pos=pos, output=&quot;triang_orig.pdf&quot;)</span>
<span class="sd">    &lt;...&gt;</span>
<span class="sd">    &gt;&gt;&gt; u = gt.GraphView(g, efilt=tree)</span>
<span class="sd">    &gt;&gt;&gt; gt.graph_draw(u, pos=pos, output=&quot;triang_min_span_tree.pdf&quot;)</span>
<span class="sd">    &lt;...&gt;</span>

<span class="sd">    .. testcode::</span>
<span class="sd">       :hide:</span>

<span class="sd">       gt.graph_draw(g, pos=pos, output=&quot;triang_orig.png&quot;)</span>
<span class="sd">       gt.graph_draw(u, pos=pos, output=&quot;triang_min_span_tree.png&quot;)</span>

<span class="sd">    .. image:: triang_orig.*</span>
<span class="sd">        :width: 400px</span>
<span class="sd">    .. image:: triang_min_span_tree.*</span>
<span class="sd">        :width: 400px</span>

<span class="sd">    *Left:* Original graph, *Right:* The minimum spanning tree.</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    .. [kruskal-shortest-1956] J. B. Kruskal.  &quot;On the shortest spanning subtree</span>
<span class="sd">       of a graph and the traveling salesman problem&quot;,  In Proceedings of the</span>
<span class="sd">       American Mathematical Society, volume 7, pages 48-50, 1956.</span>
<span class="sd">       :doi:`10.1090/S0002-9939-1956-0078686-7`</span>
<span class="sd">    .. [prim-shortest-1957] R. Prim.  &quot;Shortest connection networks and some</span>
<span class="sd">       generalizations&quot;,  Bell System Technical Journal, 36:1389-1401, 1957.</span>
<span class="sd">    .. [boost-mst] http://www.boost.org/libs/graph/doc/graph_theory_review.html#sec:minimum-spanning-tree</span>
<span class="sd">    .. [mst-wiki] http://en.wikipedia.org/wiki/Minimum_spanning_tree</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">tree_map</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">tree_map</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">new_edge_property</span><span class="p">(</span><span class="s2">&quot;bool&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">tree_map</span><span class="o">.</span><span class="n">value_type</span><span class="p">()</span> <span class="o">!=</span> <span class="s2">&quot;bool&quot;</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;edge property &#39;tree_map&#39; must be of value type bool.&quot;</span><span class="p">)</span>

    <span class="n">u</span> <span class="o">=</span> <span class="n">GraphView</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">directed</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">root</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">libgraph_tool_topology</span><span class="o">.</span>\
               <span class="n">get_kruskal_spanning_tree</span><span class="p">(</span><span class="n">u</span><span class="o">.</span><span class="n">_Graph__graph</span><span class="p">,</span>
                                         <span class="n">_prop</span><span class="p">(</span><span class="s2">&quot;e&quot;</span><span class="p">,</span> <span class="n">g</span><span class="p">,</span> <span class="n">weights</span><span class="p">),</span>
                                         <span class="n">_prop</span><span class="p">(</span><span class="s2">&quot;e&quot;</span><span class="p">,</span> <span class="n">g</span><span class="p">,</span> <span class="n">tree_map</span><span class="p">))</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">libgraph_tool_topology</span><span class="o">.</span>\
               <span class="n">get_prim_spanning_tree</span><span class="p">(</span><span class="n">u</span><span class="o">.</span><span class="n">_Graph__graph</span><span class="p">,</span> <span class="nb">int</span><span class="p">(</span><span class="n">root</span><span class="p">),</span>
                                      <span class="n">_prop</span><span class="p">(</span><span class="s2">&quot;e&quot;</span><span class="p">,</span> <span class="n">g</span><span class="p">,</span> <span class="n">weights</span><span class="p">),</span>
                                      <span class="n">_prop</span><span class="p">(</span><span class="s2">&quot;e&quot;</span><span class="p">,</span> <span class="n">g</span><span class="p">,</span> <span class="n">tree_map</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">tree_map</span></div>


<div class="viewcode-block" id="random_spanning_tree"><a class="viewcode-back" href="../../../../doc/topology.html#graph_tool.topology.random_spanning_tree">[docs]</a><span class="k">def</span> <span class="nf">random_spanning_tree</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">weights</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">root</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">tree_map</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;Return a random spanning tree of a given graph, which can be directed or</span>
<span class="sd">    undirected.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    g : :class:`~graph_tool.Graph`</span>
<span class="sd">        Graph to be used.</span>
<span class="sd">    weights : :class:`~graph_tool.PropertyMap` (optional, default: `None`)</span>
<span class="sd">        The edge weights. If provided, the probability of a particular spanning</span>
<span class="sd">        tree being selected is the product of its edge weights.</span>
<span class="sd">    root : :class:`~graph_tool.Vertex` (optional, default: `None`)</span>
<span class="sd">        Root of the spanning tree. If not provided, it will be selected randomly.</span>
<span class="sd">    tree_map : :class:`~graph_tool.PropertyMap` (optional, default: `None`)</span>
<span class="sd">        If provided, the edge tree map will be written in this property map.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    tree_map : :class:`~graph_tool.PropertyMap`</span>
<span class="sd">        Edge property map with mark the tree edges: 1 for tree edge, 0</span>
<span class="sd">        otherwise.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>

<span class="sd">    The running time for this algorithm is :math:`O(\tau)`, with :math:`\tau`</span>
<span class="sd">    being the mean hitting time of a random walk on the graph. In the worse case,</span>
<span class="sd">    we have :math:`\tau \sim O(V^3)`, with :math:`V` being the number of</span>
<span class="sd">    vertices in the graph. However, in much more typical cases (e.g. sparse</span>
<span class="sd">    random graphs) the running time is simply :math:`O(V)`.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    .. testcode::</span>
<span class="sd">       :hide:</span>

<span class="sd">       import numpy.random</span>
<span class="sd">       numpy.random.seed(42)</span>
<span class="sd">       gt.seed_rng(42)</span>

<span class="sd">    &gt;&gt;&gt; from numpy.random import random</span>
<span class="sd">    &gt;&gt;&gt; g, pos = gt.triangulation(random((400, 2)), type=&quot;delaunay&quot;)</span>
<span class="sd">    &gt;&gt;&gt; weight = g.new_edge_property(&quot;double&quot;)</span>
<span class="sd">    &gt;&gt;&gt; for e in g.edges():</span>
<span class="sd">    ...    weight[e] = linalg.norm(pos[e.target()].a - pos[e.source()].a)</span>
<span class="sd">    &gt;&gt;&gt; tree = gt.random_spanning_tree(g, weights=weight)</span>
<span class="sd">    &gt;&gt;&gt; tree2 = gt.random_spanning_tree(g, weights=weight)</span>
<span class="sd">    &gt;&gt;&gt; gt.graph_draw(g, pos=pos, output=&quot;rtriang_orig.pdf&quot;)</span>
<span class="sd">    &lt;...&gt;</span>
<span class="sd">    &gt;&gt;&gt; u = gt.GraphView(g, efilt=tree)</span>
<span class="sd">    &gt;&gt;&gt; gt.graph_draw(u, pos=pos, output=&quot;triang_random_span_tree.pdf&quot;)</span>
<span class="sd">    &lt;...&gt;</span>
<span class="sd">    &gt;&gt;&gt; u2 = gt.GraphView(g, efilt=tree2)</span>
<span class="sd">    &gt;&gt;&gt; gt.graph_draw(u2, pos=pos, output=&quot;triang_random_span_tree2.pdf&quot;)</span>
<span class="sd">    &lt;...&gt;</span>

<span class="sd">    .. testcode::</span>
<span class="sd">       :hide:</span>

<span class="sd">       gt.graph_draw(g, pos=pos, output=&quot;rtriang_orig.png&quot;)</span>
<span class="sd">       gt.graph_draw(u, pos=pos, output=&quot;triang_random_span_tree.png&quot;)</span>
<span class="sd">       gt.graph_draw(u2, pos=pos, output=&quot;triang_random_span_tree2.png&quot;)</span>

<span class="sd">    .. image:: rtriang_orig.*</span>
<span class="sd">        :width: 300px</span>
<span class="sd">    .. image:: triang_random_span_tree.*</span>
<span class="sd">        :width: 300px</span>
<span class="sd">    .. image:: triang_random_span_tree2.*</span>
<span class="sd">        :width: 300px</span>

<span class="sd">    *Left:* Original graph, *Middle:* A random spanning tree, *Right:* Another</span>
<span class="sd">    random spanning tree</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>

<span class="sd">    .. [wilson-generating-1996] David Bruce Wilson, &quot;Generating random spanning</span>
<span class="sd">       trees more quickly than the cover time&quot;, Proceedings of the twenty-eighth</span>
<span class="sd">       annual ACM symposium on Theory of computing, Pages 296-303, ACM New York,</span>
<span class="sd">       1996, :doi:`10.1145/237814.237880`</span>
<span class="sd">    .. [boost-rst] http://www.boost.org/libs/graph/doc/random_spanning_tree.html</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">tree_map</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">tree_map</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">new_edge_property</span><span class="p">(</span><span class="s2">&quot;bool&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">tree_map</span><span class="o">.</span><span class="n">value_type</span><span class="p">()</span> <span class="o">!=</span> <span class="s2">&quot;bool&quot;</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;edge property &#39;tree_map&#39; must be of value type bool.&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">root</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">root</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">vertex</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">g</span><span class="o">.</span><span class="n">num_vertices</span><span class="p">()),</span>
                        <span class="n">use_index</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

    <span class="c1"># we need to restrict ourselves to the in-component of root</span>
    <span class="n">l</span> <span class="o">=</span> <span class="n">label_out_component</span><span class="p">(</span><span class="n">GraphView</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="nb">reversed</span><span class="o">=</span><span class="kc">True</span><span class="p">),</span> <span class="n">root</span><span class="p">)</span>
    <span class="n">u</span> <span class="o">=</span> <span class="n">GraphView</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">vfilt</span><span class="o">=</span><span class="n">l</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">u</span><span class="o">.</span><span class="n">num_vertices</span><span class="p">()</span> <span class="o">!=</span> <span class="n">g</span><span class="o">.</span><span class="n">num_vertices</span><span class="p">():</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;There must be a path from all vertices to the root vertex: </span><span class="si">%d</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="nb">int</span><span class="p">(</span><span class="n">root</span><span class="p">)</span> <span class="p">)</span>

    <span class="n">libgraph_tool_topology</span><span class="o">.</span>\
        <span class="n">random_spanning_tree</span><span class="p">(</span><span class="n">g</span><span class="o">.</span><span class="n">_Graph__graph</span><span class="p">,</span> <span class="nb">int</span><span class="p">(</span><span class="n">root</span><span class="p">),</span>
                             <span class="n">_prop</span><span class="p">(</span><span class="s2">&quot;e&quot;</span><span class="p">,</span> <span class="n">g</span><span class="p">,</span> <span class="n">weights</span><span class="p">),</span>
                             <span class="n">_prop</span><span class="p">(</span><span class="s2">&quot;e&quot;</span><span class="p">,</span> <span class="n">g</span><span class="p">,</span> <span class="n">tree_map</span><span class="p">),</span> <span class="n">_get_rng</span><span class="p">())</span>
    <span class="k">return</span> <span class="n">tree_map</span></div>


<div class="viewcode-block" id="dominator_tree"><a class="viewcode-back" href="../../../../doc/topology.html#graph_tool.topology.dominator_tree">[docs]</a><span class="k">def</span> <span class="nf">dominator_tree</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span> <span class="n">dom_map</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Return a vertex property map the dominator vertices for each vertex.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    g : :class:`~graph_tool.Graph`</span>
<span class="sd">        Graph to be used.</span>
<span class="sd">    root : :class:`~graph_tool.Vertex`</span>
<span class="sd">        The root vertex.</span>
<span class="sd">    dom_map : :class:`~graph_tool.PropertyMap` (optional, default: None)</span>
<span class="sd">        If provided, the dominator map will be written in this property map.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    dom_map : :class:`~graph_tool.PropertyMap`</span>
<span class="sd">        The dominator map. It contains for each vertex, the index of its</span>
<span class="sd">        dominator vertex.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    A vertex u dominates a vertex v, if every path of directed graph from the</span>
<span class="sd">    entry to v must go through u.</span>

<span class="sd">    The algorithm runs with :math:`O((V+E)\log (V+E))` complexity.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    .. testcode::</span>
<span class="sd">       :hide:</span>

<span class="sd">       import numpy.random</span>
<span class="sd">       numpy.random.seed(42)</span>
<span class="sd">       gt.seed_rng(42)</span>

<span class="sd">    &gt;&gt;&gt; g = gt.random_graph(100, lambda: (2, 2))</span>
<span class="sd">    &gt;&gt;&gt; tree = gt.min_spanning_tree(g)</span>
<span class="sd">    &gt;&gt;&gt; g.set_edge_filter(tree)</span>
<span class="sd">    &gt;&gt;&gt; root = [v for v in g.vertices() if v.in_degree() == 0]</span>
<span class="sd">    &gt;&gt;&gt; dom = gt.dominator_tree(g, root[0])</span>
<span class="sd">    &gt;&gt;&gt; print(dom.a)</span>
<span class="sd">    [ 0  0  0  0  0  0  0 74  0  0  0 97  0  0  0  0  0  0  0  0  0  0  0  0</span>
<span class="sd">      0  0  0  0  0 97  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0</span>
<span class="sd">      0  0  0  0  0  0  0  0  0  0  0  0 64 67  0  0 67  0  0 74  0  0  0  0</span>
<span class="sd">     23  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0</span>
<span class="sd">      0  7  0  0]</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    .. [dominator-bgl] http://www.boost.org/libs/graph/doc/lengauer_tarjan_dominator.htm</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">dom_map</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">dom_map</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">new_vertex_property</span><span class="p">(</span><span class="s2">&quot;int32_t&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">dom_map</span><span class="o">.</span><span class="n">value_type</span><span class="p">()</span> <span class="o">!=</span> <span class="s2">&quot;int32_t&quot;</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;vertex property &#39;dom_map&#39; must be of value type&quot;</span> <span class="o">+</span>
                         <span class="s2">&quot; int32_t.&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">g</span><span class="o">.</span><span class="n">is_directed</span><span class="p">():</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;dominator tree requires a directed graph.&quot;</span><span class="p">)</span>
    <span class="n">libgraph_tool_topology</span><span class="o">.</span>\
               <span class="n">dominator_tree</span><span class="p">(</span><span class="n">g</span><span class="o">.</span><span class="n">_Graph__graph</span><span class="p">,</span> <span class="nb">int</span><span class="p">(</span><span class="n">root</span><span class="p">),</span>
                              <span class="n">_prop</span><span class="p">(</span><span class="s2">&quot;v&quot;</span><span class="p">,</span> <span class="n">g</span><span class="p">,</span> <span class="n">dom_map</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">dom_map</span></div>


<div class="viewcode-block" id="topological_sort"><a class="viewcode-back" href="../../../../doc/topology.html#graph_tool.topology.topological_sort">[docs]</a><span class="k">def</span> <span class="nf">topological_sort</span><span class="p">(</span><span class="n">g</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return the topological sort of the given graph. It is returned as an array</span>
<span class="sd">    of vertex indexes, in the sort order.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    The topological sort algorithm creates a linear ordering of the vertices</span>
<span class="sd">    such that if edge (u,v) appears in the graph, then u comes before v in the</span>
<span class="sd">    ordering. The graph must be a directed acyclic graph (DAG).</span>

<span class="sd">    The time complexity is :math:`O(V + E)`.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    .. testcode::</span>
<span class="sd">       :hide:</span>

<span class="sd">       import numpy.random</span>
<span class="sd">       numpy.random.seed(42)</span>
<span class="sd">       gt.seed_rng(42)</span>

<span class="sd">    &gt;&gt;&gt; g = gt.random_graph(30, lambda: (3, 3))</span>
<span class="sd">    &gt;&gt;&gt; tree = gt.min_spanning_tree(g)</span>
<span class="sd">    &gt;&gt;&gt; g.set_edge_filter(tree)</span>
<span class="sd">    &gt;&gt;&gt; sort = gt.topological_sort(g)</span>
<span class="sd">    &gt;&gt;&gt; print(sort)</span>
<span class="sd">    [28 26 29 27 23 22 18 17 16 20 21 15 12 11 10 25 14  9  8  7  5  3  2 24</span>
<span class="sd">      4  6  1  0 19 13]</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    .. [topological-boost] http://www.boost.org/libs/graph/doc/topological_sort.html</span>
<span class="sd">    .. [topological-wiki] http://en.wikipedia.org/wiki/Topological_sorting</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">topological_order</span> <span class="o">=</span> <span class="n">Vector_int32_t</span><span class="p">()</span>
    <span class="n">is_DAG</span> <span class="o">=</span> <span class="n">libgraph_tool_topology</span><span class="o">.</span>\
        <span class="n">topological_sort</span><span class="p">(</span><span class="n">g</span><span class="o">.</span><span class="n">_Graph__graph</span><span class="p">,</span> <span class="n">topological_order</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">is_DAG</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Graph is not a directed acylic graph (DAG).&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">topological_order</span><span class="o">.</span><span class="n">a</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span></div>


<div class="viewcode-block" id="transitive_closure"><a class="viewcode-back" href="../../../../doc/topology.html#graph_tool.topology.transitive_closure">[docs]</a><span class="k">def</span> <span class="nf">transitive_closure</span><span class="p">(</span><span class="n">g</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Return the transitive closure graph of g.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    The transitive closure of a graph G = (V,E) is a graph G* = (V,E*) such that</span>
<span class="sd">    E* contains an edge (u,v) if and only if G contains a path (of at least one</span>
<span class="sd">    edge) from u to v. The transitive_closure() function transforms the input</span>
<span class="sd">    graph g into the transitive closure graph tc.</span>

<span class="sd">    The time complexity (worst-case) is :math:`O(VE)`.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    .. testcode::</span>
<span class="sd">       :hide:</span>

<span class="sd">       import numpy.random</span>
<span class="sd">       numpy.random.seed(42)</span>
<span class="sd">       gt.seed_rng(42)</span>

<span class="sd">    &gt;&gt;&gt; g = gt.random_graph(30, lambda: (3, 3))</span>
<span class="sd">    &gt;&gt;&gt; tc = gt.transitive_closure(g)</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    .. [transitive-boost] http://www.boost.org/libs/graph/doc/transitive_closure.html</span>
<span class="sd">    .. [transitive-wiki] http://en.wikipedia.org/wiki/Transitive_closure</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">g</span><span class="o">.</span><span class="n">is_directed</span><span class="p">():</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;graph must be directed for transitive closure.&quot;</span><span class="p">)</span>
    <span class="n">tg</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">()</span>
    <span class="n">libgraph_tool_topology</span><span class="o">.</span><span class="n">transitive_closure</span><span class="p">(</span><span class="n">g</span><span class="o">.</span><span class="n">_Graph__graph</span><span class="p">,</span>
                                              <span class="n">tg</span><span class="o">.</span><span class="n">_Graph__graph</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">tg</span></div>


<div class="viewcode-block" id="label_components"><a class="viewcode-back" href="../../../../doc/topology.html#graph_tool.topology.label_components">[docs]</a><span class="k">def</span> <span class="nf">label_components</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">vprop</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">directed</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">attractors</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Label the components to which each vertex in the graph belongs. If the</span>
<span class="sd">    graph is directed, it finds the strongly connected components.</span>

<span class="sd">    A property map with the component labels is returned, together with an</span>
<span class="sd">    histogram of component labels.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    g : :class:`~graph_tool.Graph`</span>
<span class="sd">        Graph to be used.</span>
<span class="sd">    vprop : :class:`~graph_tool.PropertyMap` (optional, default: ``None``)</span>
<span class="sd">        Vertex property to store the component labels. If none is supplied, one</span>
<span class="sd">        is created.</span>
<span class="sd">    directed : bool (optional, default: ``None``)</span>
<span class="sd">        Treat graph as directed or not, independently of its actual</span>
<span class="sd">        directionality.</span>
<span class="sd">    attractors : bool (optional, default: ``False``)</span>
<span class="sd">        If ``True``, and the graph is directed, an additional array with Boolean</span>
<span class="sd">        values is returned, specifying if the strongly connected components are</span>
<span class="sd">        attractors or not.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    comp : :class:`~graph_tool.PropertyMap`</span>
<span class="sd">        Vertex property map with component labels.</span>
<span class="sd">    hist : :class:`~numpy.ndarray`</span>
<span class="sd">        Histogram of component labels.</span>
<span class="sd">    is_attractor : :class:`~numpy.ndarray`</span>
<span class="sd">        A Boolean array specifying if the strongly connected components are</span>
<span class="sd">        attractors or not. This returned only if ``attractors == True``, and the</span>
<span class="sd">        graph is directed.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    The components are arbitrarily labeled from 0 to N-1, where N is the total</span>
<span class="sd">    number of components.</span>

<span class="sd">    The algorithm runs in :math:`O(V + E)` time.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    .. testcode::</span>
<span class="sd">       :hide:</span>

<span class="sd">       numpy.random.seed(43)</span>
<span class="sd">       gt.seed_rng(43)</span>

<span class="sd">    &gt;&gt;&gt; g = gt.random_graph(100, lambda: (poisson(2), poisson(2)))</span>
<span class="sd">    &gt;&gt;&gt; comp, hist, is_attractor = gt.label_components(g, attractors=True)</span>
<span class="sd">    &gt;&gt;&gt; print(comp.a)</span>
<span class="sd">    [ 9  9  9  9 10  1  9 11 12  9  9  9  9  9  9 13  9  9  9  0  9  9 16  9</span>
<span class="sd">      9  3  9  9  4 17  9  9 18  9  9 19 20  9  9  9 14  5  9  9  6  9  9  9</span>
<span class="sd">     21  9  9  9  9  9  9  9  9  9  9  9  9  9  9  2  9  8  9 22 15  9  9  9</span>
<span class="sd">      9  9 23 25  9  9 26 27 28 29 30  9  9  9  9  9  9 31  9  9  9  9  9 32</span>
<span class="sd">      9  9  7 24]</span>
<span class="sd">    &gt;&gt;&gt; print(hist)</span>
<span class="sd">    [ 1  1  1  1  1  1  1  1  1 68  1  1  1  1  1  1  1  1  1  1  1  1  1  1</span>
<span class="sd">      1  1  1  1  1  1  1  1  1]</span>
<span class="sd">    &gt;&gt;&gt; print(is_attractor)</span>
<span class="sd">    [ True  True  True  True  True  True  True  True  True False  True False</span>
<span class="sd">     False False False False False False False False False False False False</span>
<span class="sd">     False False False False  True False  True False False]</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="n">vprop</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">vprop</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">new_vertex_property</span><span class="p">(</span><span class="s2">&quot;int32_t&quot;</span><span class="p">)</span>

    <span class="n">_check_prop_writable</span><span class="p">(</span><span class="n">vprop</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;vprop&quot;</span><span class="p">)</span>
    <span class="n">_check_prop_scalar</span><span class="p">(</span><span class="n">vprop</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;vprop&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">directed</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">g</span> <span class="o">=</span> <span class="n">GraphView</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">directed</span><span class="o">=</span><span class="n">directed</span><span class="p">)</span>

    <span class="n">hist</span> <span class="o">=</span> <span class="n">libgraph_tool_topology</span><span class="o">.</span>\
               <span class="n">label_components</span><span class="p">(</span><span class="n">g</span><span class="o">.</span><span class="n">_Graph__graph</span><span class="p">,</span> <span class="n">_prop</span><span class="p">(</span><span class="s2">&quot;v&quot;</span><span class="p">,</span> <span class="n">g</span><span class="p">,</span> <span class="n">vprop</span><span class="p">))</span>

    <span class="k">if</span> <span class="n">attractors</span> <span class="ow">and</span> <span class="n">g</span><span class="o">.</span><span class="n">is_directed</span><span class="p">()</span> <span class="ow">and</span> <span class="n">directed</span> <span class="o">!=</span> <span class="kc">False</span><span class="p">:</span>
        <span class="n">is_attractor</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">hist</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="s2">&quot;bool&quot;</span><span class="p">)</span>
        <span class="n">libgraph_tool_topology</span><span class="o">.</span>\
               <span class="n">label_attractors</span><span class="p">(</span><span class="n">g</span><span class="o">.</span><span class="n">_Graph__graph</span><span class="p">,</span> <span class="n">_prop</span><span class="p">(</span><span class="s2">&quot;v&quot;</span><span class="p">,</span> <span class="n">g</span><span class="p">,</span> <span class="n">vprop</span><span class="p">),</span>
                                <span class="n">is_attractor</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">vprop</span><span class="p">,</span> <span class="n">hist</span><span class="p">,</span> <span class="n">is_attractor</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">vprop</span><span class="p">,</span> <span class="n">hist</span></div>


<div class="viewcode-block" id="label_largest_component"><a class="viewcode-back" href="../../../../doc/topology.html#graph_tool.topology.label_largest_component">[docs]</a><span class="k">def</span> <span class="nf">label_largest_component</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">directed</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Label the largest component in the graph. If the graph is directed, then the</span>
<span class="sd">    largest strongly connected component is labelled.</span>

<span class="sd">    A property map with a boolean label is returned.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    g : :class:`~graph_tool.Graph`</span>
<span class="sd">        Graph to be used.</span>
<span class="sd">    directed : bool (optional, default:None)</span>
<span class="sd">        Treat graph as directed or not, independently of its actual</span>
<span class="sd">        directionality.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    comp : :class:`~graph_tool.PropertyMap`</span>
<span class="sd">         Boolean vertex property map which labels the largest component.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    The algorithm runs in :math:`O(V + E)` time.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    .. testcode::</span>
<span class="sd">       :hide:</span>

<span class="sd">       import numpy.random</span>
<span class="sd">       numpy.random.seed(42)</span>
<span class="sd">       gt.seed_rng(42)</span>

<span class="sd">    &gt;&gt;&gt; g = gt.random_graph(100, lambda: poisson(1), directed=False)</span>
<span class="sd">    &gt;&gt;&gt; l = gt.label_largest_component(g)</span>
<span class="sd">    &gt;&gt;&gt; print(l.a)</span>
<span class="sd">    [0 0 0 0 1 0 0 0 0 1 0 1 0 0 0 0 0 0 0 0 0 0 1 0 1 0 0 1 0 1 0 0 0 0 0 0 0</span>
<span class="sd">     0 0 0 0 1 0 0 0 1 0 0 0 1 0 0 1 0 0 0 1 0 1 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0</span>
<span class="sd">     0 0 0 0 0 0 0 0 1 0 0 1 0 1 0 0 0 0 0 0 0 0 0 1 0 0]</span>
<span class="sd">    &gt;&gt;&gt; u = gt.GraphView(g, vfilt=l)   # extract the largest component as a graph</span>
<span class="sd">    &gt;&gt;&gt; print(u.num_vertices())</span>
<span class="sd">    18</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">label</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">new_vertex_property</span><span class="p">(</span><span class="s2">&quot;bool&quot;</span><span class="p">)</span>
    <span class="n">c</span><span class="p">,</span> <span class="n">h</span> <span class="o">=</span> <span class="n">label_components</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">directed</span><span class="o">=</span><span class="n">directed</span><span class="p">)</span>
    <span class="n">vfilt</span><span class="p">,</span> <span class="n">inv</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">get_vertex_filter</span><span class="p">()</span>
    <span class="n">label</span><span class="o">.</span><span class="n">fa</span> <span class="o">=</span> <span class="n">c</span><span class="o">.</span><span class="n">fa</span> <span class="o">==</span> <span class="n">h</span><span class="o">.</span><span class="n">argmax</span><span class="p">()</span>
    <span class="k">return</span> <span class="n">label</span></div>


<div class="viewcode-block" id="label_out_component"><a class="viewcode-back" href="../../../../doc/topology.html#graph_tool.topology.label_out_component">[docs]</a><span class="k">def</span> <span class="nf">label_out_component</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Label the out-component (or simply the component for undirected graphs) of a</span>
<span class="sd">    root vertex.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    g : :class:`~graph_tool.Graph`</span>
<span class="sd">        Graph to be used.</span>
<span class="sd">    root : :class:`~graph_tool.Vertex`</span>
<span class="sd">        The root vertex.</span>
<span class="sd">    label : :class:`~graph_tool.PropertyMap` (optional, default: ``None``)</span>
<span class="sd">        If provided, this must be an initialized Boolean vertex property map</span>
<span class="sd">        where the out-component will be labeled.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    label : :class:`~graph_tool.PropertyMap`</span>
<span class="sd">         Boolean vertex property map which labels the out-component.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    The algorithm runs in :math:`O(V + E)` time.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    .. testcode::</span>
<span class="sd">       :hide:</span>

<span class="sd">       import numpy.random</span>
<span class="sd">       numpy.random.seed(42)</span>
<span class="sd">       gt.seed_rng(42)</span>

<span class="sd">    &gt;&gt;&gt; g = gt.random_graph(100, lambda: poisson(2.2), directed=False)</span>
<span class="sd">    &gt;&gt;&gt; l = gt.label_out_component(g, g.vertex(2))</span>
<span class="sd">    &gt;&gt;&gt; print(l.a)</span>
<span class="sd">    [1 1 1 1 1 1 0 1 1 1 0 0 1 1 1 1 1 1 0 1 1 1 0 1 1 1 1 1 1 1 0 0 0 1 1 1 1</span>
<span class="sd">     1 1 0 0 1 1 1 1 1 1 1 1 1 1 1 1 1 0 1 1 1 1 1 0 1 1 1 1 0 0 1 0 1 1 1 0 1</span>
<span class="sd">     1 1 0 0 1 1 1 1 1 1 1 1 1 0 1 1 1 0 1 1 1 0 1 1 1 0]</span>

<span class="sd">    The in-component can be obtained by reversing the graph.</span>

<span class="sd">    &gt;&gt;&gt; l = gt.label_out_component(gt.GraphView(g, reversed=True, directed=True),</span>
<span class="sd">    ...                            g.vertex(1))</span>
<span class="sd">    &gt;&gt;&gt; print(l.a)</span>
<span class="sd">    [0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0</span>
<span class="sd">     0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0</span>
<span class="sd">     0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0]</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="n">label</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">label</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">new_vertex_property</span><span class="p">(</span><span class="s2">&quot;bool&quot;</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">label</span><span class="o">.</span><span class="n">value_type</span><span class="p">()</span> <span class="o">!=</span> <span class="s2">&quot;bool&quot;</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;value type of `label` must be `bool`, not </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span>
                         <span class="n">label</span><span class="o">.</span><span class="n">value_type</span><span class="p">())</span>
    <span class="n">libgraph_tool_topology</span><span class="o">.</span>\
             <span class="n">label_out_component</span><span class="p">(</span><span class="n">g</span><span class="o">.</span><span class="n">_Graph__graph</span><span class="p">,</span> <span class="nb">int</span><span class="p">(</span><span class="n">root</span><span class="p">),</span>
                                 <span class="n">_prop</span><span class="p">(</span><span class="s2">&quot;v&quot;</span><span class="p">,</span> <span class="n">g</span><span class="p">,</span> <span class="n">label</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">label</span></div>


<div class="viewcode-block" id="label_biconnected_components"><a class="viewcode-back" href="../../../../doc/topology.html#graph_tool.topology.label_biconnected_components">[docs]</a><span class="k">def</span> <span class="nf">label_biconnected_components</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">eprop</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">vprop</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Label the edges of biconnected components, and the vertices which are</span>
<span class="sd">    articulation points.</span>

<span class="sd">    An edge property map with the component labels is returned, together a</span>
<span class="sd">    boolean vertex map marking the articulation points, and an histogram of</span>
<span class="sd">    component labels.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    g : :class:`~graph_tool.Graph`</span>
<span class="sd">        Graph to be used.</span>

<span class="sd">    eprop : :class:`~graph_tool.PropertyMap` (optional, default: None)</span>
<span class="sd">        Edge property to label the biconnected components.</span>

<span class="sd">    vprop : :class:`~graph_tool.PropertyMap` (optional, default: None)</span>
<span class="sd">        Vertex property to mark the articulation points. If none is supplied,</span>
<span class="sd">        one is created.</span>


<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    bicomp : :class:`~graph_tool.PropertyMap`</span>
<span class="sd">        Edge property map with the biconnected component labels.</span>
<span class="sd">    articulation : :class:`~graph_tool.PropertyMap`</span>
<span class="sd">        Boolean vertex property map which has value 1 for each vertex which is</span>
<span class="sd">        an articulation point, and zero otherwise.</span>
<span class="sd">    nc : int</span>
<span class="sd">        Number of biconnected components.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>

<span class="sd">    A connected graph is biconnected if the removal of any single vertex (and</span>
<span class="sd">    all edges incident on that vertex) can not disconnect the graph. More</span>
<span class="sd">    generally, the biconnected components of a graph are the maximal subsets of</span>
<span class="sd">    vertices such that the removal of a vertex from a particular component will</span>
<span class="sd">    not disconnect the component. Unlike connected components, vertices may</span>
<span class="sd">    belong to multiple biconnected components: those vertices that belong to</span>
<span class="sd">    more than one biconnected component are called &quot;articulation points&quot; or,</span>
<span class="sd">    equivalently, &quot;cut vertices&quot;. Articulation points are vertices whose removal</span>
<span class="sd">    would increase the number of connected components in the graph. Thus, a</span>
<span class="sd">    graph without articulation points is biconnected. Vertices can be present in</span>
<span class="sd">    multiple biconnected components, but each edge can only be contained in a</span>
<span class="sd">    single biconnected component.</span>

<span class="sd">    The algorithm runs in :math:`O(V + E)` time.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    .. testcode::</span>
<span class="sd">       :hide:</span>

<span class="sd">       import numpy.random</span>
<span class="sd">       numpy.random.seed(42)</span>
<span class="sd">       gt.seed_rng(42)</span>

<span class="sd">    &gt;&gt;&gt; g = gt.random_graph(100, lambda: poisson(2), directed=False)</span>
<span class="sd">    &gt;&gt;&gt; comp, art, hist = gt.label_biconnected_components(g)</span>
<span class="sd">    &gt;&gt;&gt; print(comp.a)</span>
<span class="sd">    [26 26 26 26 26 26 26 26 19 25 26 26 23 26 26 26 26  6 26 24 18 26 26 13</span>
<span class="sd">     26 26 26 26 26 26 26 26 26 26 26 16 29 26 26 26 26 26 26 15 26 26 26 26</span>
<span class="sd">     26  0 26 26 12  2 26 26 26 26 26 26 26 26  9  3 26 28 26 26  8 26  4 26</span>
<span class="sd">     26 26 14 26 26 26 26 30 11 26 26 26 20 26 26 27 26 33 26 22 17  7  5 32</span>
<span class="sd">     21 26  1 10 31]</span>
<span class="sd">    &gt;&gt;&gt; print(art.a)</span>
<span class="sd">    [1 0 1 1 0 0 0 0 0 0 0 0 1 0 0 1 1 0 0 0 0 0 0 0 0 0 0 0 1 1 0 0 0 0 1 1 0</span>
<span class="sd">     1 1 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 1 1 0 1 0 0 0 0 1 0 0 1 0 0 0 0 0 0 0 0</span>
<span class="sd">     1 0 0 1 0 0 0 1 1 0 0 1 0 0 1 1 0 0 0 1 0 0 1 0 0 0]</span>
<span class="sd">    &gt;&gt;&gt; print(hist)</span>
<span class="sd">    [ 1  1  1  1  1  1  1  1  1  1  1  1  1  1  1  1  1  1  1  1  1  1  1  1</span>
<span class="sd">      1  1 68  1  1  1  1  1  1  1]</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="n">vprop</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">vprop</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">new_vertex_property</span><span class="p">(</span><span class="s2">&quot;bool&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">eprop</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">eprop</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">new_edge_property</span><span class="p">(</span><span class="s2">&quot;int32_t&quot;</span><span class="p">)</span>

    <span class="n">_check_prop_writable</span><span class="p">(</span><span class="n">vprop</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;vprop&quot;</span><span class="p">)</span>
    <span class="n">_check_prop_scalar</span><span class="p">(</span><span class="n">vprop</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;vprop&quot;</span><span class="p">)</span>
    <span class="n">_check_prop_writable</span><span class="p">(</span><span class="n">eprop</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;eprop&quot;</span><span class="p">)</span>
    <span class="n">_check_prop_scalar</span><span class="p">(</span><span class="n">eprop</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;eprop&quot;</span><span class="p">)</span>

    <span class="n">g</span> <span class="o">=</span> <span class="n">GraphView</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">directed</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    <span class="n">hist</span> <span class="o">=</span> <span class="n">libgraph_tool_topology</span><span class="o">.</span>\
             <span class="n">label_biconnected_components</span><span class="p">(</span><span class="n">g</span><span class="o">.</span><span class="n">_Graph__graph</span><span class="p">,</span> <span class="n">_prop</span><span class="p">(</span><span class="s2">&quot;e&quot;</span><span class="p">,</span> <span class="n">g</span><span class="p">,</span> <span class="n">eprop</span><span class="p">),</span>
                                          <span class="n">_prop</span><span class="p">(</span><span class="s2">&quot;v&quot;</span><span class="p">,</span> <span class="n">g</span><span class="p">,</span> <span class="n">vprop</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">eprop</span><span class="p">,</span> <span class="n">vprop</span><span class="p">,</span> <span class="n">hist</span></div>

<div class="viewcode-block" id="vertex_percolation"><a class="viewcode-back" href="../../../../doc/topology.html#graph_tool.topology.vertex_percolation">[docs]</a><span class="k">def</span> <span class="nf">vertex_percolation</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">vertices</span><span class="p">,</span> <span class="n">second</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Compute the size of the largest or second-largest component as vertices</span>
<span class="sd">    are (virtually)</span>
<span class="sd">    removed from the graph.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    g : :class:`~graph_tool.Graph`</span>
<span class="sd">        Graph to be used.</span>
<span class="sd">    vertices : :class:`numpy.ndarray` or iterable of ints</span>
<span class="sd">        List of vertices in reversed order of removal.</span>
<span class="sd">    second : bool (optional, default: ``False``)</span>
<span class="sd">        If ``True``, the size of the second-largest component will be computed.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    size : :class:`numpy.ndarray`</span>
<span class="sd">        Size of the largest (or second-largest) component prior to removal of</span>
<span class="sd">        each vertex.</span>
<span class="sd">    comp : :class:`~graph_tool.PropertyMap`</span>
<span class="sd">        Vertex property map with component labels.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>

<span class="sd">    The algorithm runs in :math:`O(V + E)` time.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    .. testcode::</span>
<span class="sd">       :hide:</span>

<span class="sd">       import numpy.random</span>
<span class="sd">       numpy.random.seed(42)</span>
<span class="sd">       gt.seed_rng(42)</span>

<span class="sd">    &gt;&gt;&gt; g = gt.random_graph(10000, lambda: geometric(1./4) + 1, directed=False)</span>
<span class="sd">    &gt;&gt;&gt; vertices = sorted([v for v in g.vertices()], key=lambda v: v.out_degree())</span>
<span class="sd">    &gt;&gt;&gt; sizes, comp = gt.vertex_percolation(g, vertices)</span>
<span class="sd">    &gt;&gt;&gt; numpy.random.shuffle(vertices)</span>
<span class="sd">    &gt;&gt;&gt; sizes2, comp = gt.vertex_percolation(g, vertices)</span>
<span class="sd">    &gt;&gt;&gt; figure()</span>
<span class="sd">    &lt;...&gt;</span>
<span class="sd">    &gt;&gt;&gt; plot(sizes, label=&quot;Targeted&quot;)</span>
<span class="sd">    [...]</span>
<span class="sd">    &gt;&gt;&gt; plot(sizes2, label=&quot;Random&quot;)</span>
<span class="sd">    [...]</span>
<span class="sd">    &gt;&gt;&gt; xlabel(&quot;Vertices remaining&quot;)</span>
<span class="sd">    Text(...)</span>
<span class="sd">    &gt;&gt;&gt; ylabel(&quot;Size of largest component&quot;)</span>
<span class="sd">    Text(...)</span>
<span class="sd">    &gt;&gt;&gt; legend(loc=&quot;lower right&quot;)</span>
<span class="sd">    &lt;...&gt;</span>
<span class="sd">    &gt;&gt;&gt; savefig(&quot;vertex-percolation.svg&quot;)</span>

<span class="sd">    .. figure:: vertex-percolation.*</span>
<span class="sd">        :align: center</span>

<span class="sd">        Targeted and random vertex percolation of a random graph with an</span>
<span class="sd">        exponential degree distribution.</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    .. [newman-ziff] M. E. J. Newman, R. M. Ziff, &quot;A fast Monte Carlo algorithm</span>
<span class="sd">       for site or bond percolation&quot;, Phys. Rev. E 64, 016706 (2001)</span>
<span class="sd">       :doi:`10.1103/PhysRevE.64.016706`, :arxiv:`cond-mat/0101295`</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">vertices</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">vertices</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="s2">&quot;uint64&quot;</span><span class="p">)</span>

    <span class="n">tree</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">vertex_index</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="s2">&quot;int64_t&quot;</span><span class="p">)</span>
    <span class="n">size</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">new_vertex_property</span><span class="p">(</span><span class="s2">&quot;int64_t&quot;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
    <span class="n">visited</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">new_vertex_property</span><span class="p">(</span><span class="s2">&quot;bool&quot;</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>
    <span class="n">max_size</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">vertices</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="s2">&quot;uint64&quot;</span><span class="p">)</span>

    <span class="n">u</span> <span class="o">=</span> <span class="n">GraphView</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">directed</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

    <span class="n">libgraph_tool_topology</span><span class="o">.</span>\
        <span class="n">percolate_vertex</span><span class="p">(</span><span class="n">u</span><span class="o">.</span><span class="n">_Graph__graph</span><span class="p">,</span>
                         <span class="n">_prop</span><span class="p">(</span><span class="s2">&quot;v&quot;</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">tree</span><span class="p">),</span>
                         <span class="n">_prop</span><span class="p">(</span><span class="s2">&quot;v&quot;</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">size</span><span class="p">),</span>
                         <span class="n">_prop</span><span class="p">(</span><span class="s2">&quot;v&quot;</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">visited</span><span class="p">),</span>
                         <span class="n">vertices</span><span class="p">,</span> <span class="n">max_size</span><span class="p">,</span> <span class="n">second</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">max_size</span><span class="p">,</span> <span class="n">tree</span></div>

<div class="viewcode-block" id="edge_percolation"><a class="viewcode-back" href="../../../../doc/topology.html#graph_tool.topology.edge_percolation">[docs]</a><span class="k">def</span> <span class="nf">edge_percolation</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">edges</span><span class="p">,</span> <span class="n">second</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Compute the size of the largest or second-largest component as edges are</span>
<span class="sd">    (virtually) removed from the graph.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    g : :class:`~graph_tool.Graph`</span>
<span class="sd">        Graph to be used.</span>
<span class="sd">    edges : :class:`numpy.ndarray` or iterable of pairs of ints</span>
<span class="sd">        List of edges in reversed order of removal. If the type is</span>
<span class="sd">        :class:`numpy.ndarray`, it should have a shape ``(E, 2)``, where ``E``</span>
<span class="sd">        is the number of edges, such that ``edges[i,0]`` and ``edges[i,1]`` are</span>
<span class="sd">        the both endpoints of edge ``i``.</span>
<span class="sd">    second : bool (optional, default: ``False``)</span>
<span class="sd">        If ``True``, the size of the second-largest component will be computed.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    size : :class:`numpy.ndarray`</span>
<span class="sd">        Size of the largest (or second-largest) component prior to removal of</span>
<span class="sd">        each edge.</span>
<span class="sd">    comp : :class:`~graph_tool.PropertyMap`</span>
<span class="sd">        Vertex property map with component labels.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>

<span class="sd">    The algorithm runs in :math:`O(E)` time.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    .. testcode::</span>
<span class="sd">       :hide:</span>

<span class="sd">       import numpy.random</span>
<span class="sd">       numpy.random.seed(42)</span>
<span class="sd">       gt.seed_rng(42)</span>

<span class="sd">    &gt;&gt;&gt; g = gt.random_graph(10000, lambda: geometric(1./4) + 1, directed=False)</span>
<span class="sd">    &gt;&gt;&gt; edges = sorted([(e.source(), e.target()) for e in g.edges()],</span>
<span class="sd">    ...                key=lambda e: e[0].out_degree() * e[1].out_degree())</span>
<span class="sd">    &gt;&gt;&gt; sizes, comp = gt.edge_percolation(g, edges)</span>
<span class="sd">    &gt;&gt;&gt; numpy.random.shuffle(edges)</span>
<span class="sd">    &gt;&gt;&gt; sizes2, comp = gt.edge_percolation(g, edges)</span>
<span class="sd">    &gt;&gt;&gt; figure()</span>
<span class="sd">    &lt;...&gt;</span>
<span class="sd">    &gt;&gt;&gt; plot(sizes, label=&quot;Targeted&quot;)</span>
<span class="sd">    [...]</span>
<span class="sd">    &gt;&gt;&gt; plot(sizes2, label=&quot;Random&quot;)</span>
<span class="sd">    [...]</span>
<span class="sd">    &gt;&gt;&gt; xlabel(&quot;Edges remaining&quot;)</span>
<span class="sd">    Text(...)</span>
<span class="sd">    &gt;&gt;&gt; ylabel(&quot;Size of largest component&quot;)</span>
<span class="sd">    Text(...)</span>
<span class="sd">    &gt;&gt;&gt; legend(loc=&quot;lower right&quot;)</span>
<span class="sd">    &lt;...&gt;</span>
<span class="sd">    &gt;&gt;&gt; savefig(&quot;edge-percolation.svg&quot;)</span>

<span class="sd">    .. figure:: edge-percolation.*</span>
<span class="sd">        :align: center</span>

<span class="sd">        Targeted and random edge percolation of a random graph with an</span>
<span class="sd">        exponential degree distribution.</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    .. [newman-ziff] M. E. J. Newman, R. M. Ziff, &quot;A fast Monte Carlo algorithm</span>
<span class="sd">       for site or bond percolation&quot;, Phys. Rev. E 64, 016706 (2001)</span>
<span class="sd">       :doi:`10.1103/PhysRevE.64.016706`, :arxiv:`cond-mat/0101295`</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">edges</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">edges</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="s2">&quot;uint64&quot;</span><span class="p">)</span>

    <span class="n">tree</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">vertex_index</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="s2">&quot;int64_t&quot;</span><span class="p">)</span>
    <span class="n">size</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">new_vertex_property</span><span class="p">(</span><span class="s2">&quot;int64_t&quot;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
    <span class="n">max_size</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">edges</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="s2">&quot;uint64&quot;</span><span class="p">)</span>

    <span class="n">u</span> <span class="o">=</span> <span class="n">GraphView</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">directed</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

    <span class="n">libgraph_tool_topology</span><span class="o">.</span>\
        <span class="n">percolate_edge</span><span class="p">(</span><span class="n">u</span><span class="o">.</span><span class="n">_Graph__graph</span><span class="p">,</span>
                       <span class="n">_prop</span><span class="p">(</span><span class="s2">&quot;v&quot;</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">tree</span><span class="p">),</span>
                       <span class="n">_prop</span><span class="p">(</span><span class="s2">&quot;v&quot;</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">size</span><span class="p">),</span>
                       <span class="n">edges</span><span class="p">,</span> <span class="n">max_size</span><span class="p">,</span> <span class="n">second</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">max_size</span><span class="p">,</span> <span class="n">tree</span></div>

<div class="viewcode-block" id="kcore_decomposition"><a class="viewcode-back" href="../../../../doc/topology.html#graph_tool.topology.kcore_decomposition">[docs]</a><span class="k">def</span> <span class="nf">kcore_decomposition</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">vprop</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Perform a k-core decomposition of the given graph.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    g : :class:`~graph_tool.Graph`</span>
<span class="sd">        Graph to be used.</span>
<span class="sd">    vprop : :class:`~graph_tool.PropertyMap` (optional, default: ``None``)</span>
<span class="sd">        Vertex property to store the decomposition. If ``None`` is supplied,</span>
<span class="sd">        one is created.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    kval : :class:`~graph_tool.PropertyMap`</span>
<span class="sd">        Vertex property map with the k-core decomposition, i.e. a given vertex v</span>
<span class="sd">        belongs to the ``kval[v]``-core.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>

<span class="sd">    The k-core is a maximal set of vertices such that its induced subgraph only</span>
<span class="sd">    contains vertices with degree larger than or equal to k.</span>

<span class="sd">    For directed graphs, the degree is assumed to be the total (in + out)</span>
<span class="sd">    degree.</span>

<span class="sd">    The algorithm accepts graphs with parallel edges and self loops, in which</span>
<span class="sd">    case these edges contribute to the degree in the usual fashion.</span>

<span class="sd">    This algorithm is described in [batagelk-algorithm]_ and runs in :math:`O(V + E)`</span>
<span class="sd">    time.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>

<span class="sd">    &gt;&gt;&gt; g = gt.collection.data[&quot;netscience&quot;]</span>
<span class="sd">    &gt;&gt;&gt; g = gt.GraphView(g, vfilt=gt.label_largest_component(g))</span>
<span class="sd">    &gt;&gt;&gt; kcore = gt.kcore_decomposition(g)</span>
<span class="sd">    &gt;&gt;&gt; gt.graph_draw(g, pos=g.vp[&quot;pos&quot;], vertex_fill_color=kcore, vertex_text=kcore, output=&quot;netsci-kcore.pdf&quot;)</span>
<span class="sd">    &lt;...&gt;</span>

<span class="sd">    .. testcode::</span>
<span class="sd">       :hide:</span>

<span class="sd">       gt.graph_draw(g, pos=g.vp[&quot;pos&quot;], vertex_fill_color=kcore, vertex_text=kcore, output=&quot;netsci-kcore.png&quot;)</span>

<span class="sd">    .. figure:: netsci-kcore.*</span>
<span class="sd">        :align: center</span>

<span class="sd">        K-core decomposition of a network of network scientists.</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    .. [k-core] http://en.wikipedia.org/wiki/Degeneracy_%28graph_theory%29</span>
<span class="sd">    .. [batagelk-algorithm]  Vladimir Batagelj, Matjaž Zaveršnik, &quot;Fast</span>
<span class="sd">       algorithms for determining (generalized) core groups in social</span>
<span class="sd">       networks&quot;, Advances in Data Analysis and Classification</span>
<span class="sd">       Volume 5, Issue 2, pp 129-145 (2011), :DOI:`10.1007/s11634-010-0079-y`,</span>
<span class="sd">       :arxiv:`cs/0310049`</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="n">vprop</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">vprop</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">new_vertex_property</span><span class="p">(</span><span class="s2">&quot;int32_t&quot;</span><span class="p">)</span>

    <span class="n">_check_prop_writable</span><span class="p">(</span><span class="n">vprop</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;vprop&quot;</span><span class="p">)</span>
    <span class="n">_check_prop_scalar</span><span class="p">(</span><span class="n">vprop</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;vprop&quot;</span><span class="p">)</span>

    <span class="n">libgraph_tool_topology</span><span class="o">.</span>\
               <span class="n">kcore_decomposition</span><span class="p">(</span><span class="n">g</span><span class="o">.</span><span class="n">_Graph__graph</span><span class="p">,</span> <span class="n">_prop</span><span class="p">(</span><span class="s2">&quot;v&quot;</span><span class="p">,</span> <span class="n">g</span><span class="p">,</span> <span class="n">vprop</span><span class="p">))</span>

    <span class="k">return</span> <span class="n">vprop</span></div>


<div class="viewcode-block" id="shortest_distance"><a class="viewcode-back" href="../../../../doc/topology.html#graph_tool.topology.shortest_distance">[docs]</a><span class="k">def</span> <span class="nf">shortest_distance</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">source</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">target</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">weights</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                      <span class="n">negative_weights</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">max_dist</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">directed</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                      <span class="n">dense</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">dist_map</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">pred_map</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                      <span class="n">return_reached</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Calculate the distance from a source to a target vertex, or to of all</span>
<span class="sd">    vertices from a given source, or the all pairs shortest paths, if the source</span>
<span class="sd">    is not specified.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    g : :class:`~graph_tool.Graph`</span>
<span class="sd">        Graph to be used.</span>
<span class="sd">    source : :class:`~graph_tool.Vertex` (optional, default: ``None``)</span>
<span class="sd">        Source vertex of the search. If unspecified, the all pairs shortest</span>
<span class="sd">        distances are computed.</span>
<span class="sd">    target : :class:`~graph_tool.Vertex` or iterable of such objects (optional, default: ``None``)</span>
<span class="sd">        Target vertex (or vertices) of the search. If unspecified, the distance</span>
<span class="sd">        to all vertices from the source will be computed.</span>
<span class="sd">    weights : :class:`~graph_tool.PropertyMap` (optional, default: ``None``)</span>
<span class="sd">        The edge weights. If provided, the shortest path will correspond to the</span>
<span class="sd">        minimal sum of weights.</span>
<span class="sd">    negative_weights : ``bool`` (optional, default: ``False``)</span>
<span class="sd">        If `True`, this will trigger the use of the Bellman-Ford algorithm.</span>
<span class="sd">        Ignored if ``source`` is ``None``.</span>
<span class="sd">    max_dist : scalar value (optional, default: ``None``)</span>
<span class="sd">        If specified, this limits the maximum distance of the vertices</span>
<span class="sd">        searched. This parameter has no effect if source is ``None``, or if</span>
<span class="sd">        `negative_weights=True`.</span>
<span class="sd">    directed : ``bool`` (optional, default:``None``)</span>
<span class="sd">        Treat graph as directed or not, independently of its actual</span>
<span class="sd">        directionality.</span>
<span class="sd">    dense : ``bool`` (optional, default: ``False``)</span>
<span class="sd">        If ``True``, and source is ``None``, the Floyd-Warshall algorithm is used,</span>
<span class="sd">        otherwise the Johnson algorithm is used. If source is not ``None``, this option</span>
<span class="sd">        has no effect.</span>
<span class="sd">    dist_map : :class:`~graph_tool.PropertyMap` (optional, default: ``None``)</span>
<span class="sd">        Vertex property to store the distances. If none is supplied, one</span>
<span class="sd">        is created.</span>

<span class="sd">        .. warning::</span>

<span class="sd">            If this parameter is supplied, the user is responsible for</span>
<span class="sd">            initializing it to infinity. This can be done as:</span>

<span class="sd">            &gt;&gt;&gt; dist_map = g.new_vp(&quot;double&quot;, numpy.inf)</span>

<span class="sd">            or</span>

<span class="sd">            &gt;&gt;&gt; dist_map = g.new_vp(&quot;int32_t&quot;, numpy.iinfo(numpy.int32).max)</span>

<span class="sd">            depending on the distance type.</span>

<span class="sd">    pred_map : ``bool`` or :class:`~graph_tool.PropertyMap` (optional, default: ``False``)</span>
<span class="sd">        If ``True``, a vertex property map with the predecessors is returned.</span>
<span class="sd">        If a :class:`~graph_tool.PropertyMap` is passed, it must be of value</span>
<span class="sd">        ``int64_t`` and it will be used to store the predecessors.  Ignored if</span>
<span class="sd">        ``source`` is ``None``.</span>

<span class="sd">        .. warning::</span>

<span class="sd">            If a property map is supplied, the user is responsible for</span>
<span class="sd">            initializing to the identity map. This can be done as:</span>

<span class="sd">            &gt;&gt;&gt; pred_map = g.vertex_index.copy()</span>

<span class="sd">    return_reached : ``bool`` (optional, default: ``False``)</span>
<span class="sd">        If ``True``, return an array of visited vertices.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    dist_map : :class:`~graph_tool.PropertyMap` or :class:`numpy.ndarray`</span>
<span class="sd">        Vertex property map with the distances from source. If ``source`` is</span>
<span class="sd">        ``None``, it will have a vector value type, with the distances to every</span>
<span class="sd">        vertex. If ``target`` is an iterable, instead of</span>
<span class="sd">        :class:`~graph_tool.PropertyMap`, this will be of type</span>
<span class="sd">        :class:`numpy.ndarray`, and contain only the distances to those specific</span>
<span class="sd">        targets.</span>
<span class="sd">    pred_map : :class:`~graph_tool.PropertyMap` (optional, if ``pred_map == True``)</span>
<span class="sd">        Vertex property map with the predecessors in the search tree.</span>
<span class="sd">    pred_map : :class:`numpy.ndarray` (optional, if ``return_reached == True``)</span>
<span class="sd">        Array containing vertices visited during the search.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>

<span class="sd">    If a source is given, the distances are calculated with a breadth-first</span>
<span class="sd">    search (BFS) or Dijkstra&#39;s algorithm [dijkstra]_, if weights are given. If</span>
<span class="sd">    ``negative_weights == True``, the Bellman-Ford algorithm is used</span>
<span class="sd">    [bellman-ford]_, which accepts negative weights, as long as there are no</span>
<span class="sd">    negative loops. If source is not given, the distances are calculated with</span>
<span class="sd">    Johnson&#39;s algorithm [johnson-apsp]_. If dense=True, the Floyd-Warshall</span>
<span class="sd">    algorithm [floyd-warshall-apsp]_ is used instead.</span>

<span class="sd">    If there is no path between two vertices, the computed distance will</span>
<span class="sd">    correspond to the maximum value allowed by the value type of ``dist_map``,</span>
<span class="sd">    or ``inf`` in case of floating point types.</span>

<span class="sd">    If source is specified, the algorithm runs in :math:`O(V + E)` time, or</span>
<span class="sd">    :math:`O(V \log V)` if weights are given. If ``negative_weights == True``,</span>
<span class="sd">    the complexity is :math:`O(VE)`. If source is not specified, it runs in</span>
<span class="sd">    :math:`O(VE\log V)` time, or :math:`O(V^3)` if dense == True.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    .. testcode::</span>
<span class="sd">       :hide:</span>

<span class="sd">       import numpy.random</span>
<span class="sd">       numpy.random.seed(42)</span>
<span class="sd">       gt.seed_rng(42)</span>

<span class="sd">    &gt;&gt;&gt; from numpy.random import poisson</span>
<span class="sd">    &gt;&gt;&gt; g = gt.random_graph(100, lambda: (poisson(3), poisson(3)))</span>
<span class="sd">    &gt;&gt;&gt; dist = gt.shortest_distance(g, source=g.vertex(0))</span>
<span class="sd">    &gt;&gt;&gt; print(dist.a)</span>
<span class="sd">    [         0          4          5          6 2147483647          5</span>
<span class="sd">              4          3 2147483647          4          4          6</span>
<span class="sd">              6          5          5          4          4          2</span>
<span class="sd">              5          1 2147483647          6          5          5</span>
<span class="sd">              5          7          5          4          6          5</span>
<span class="sd">              5          4          1          4          4          3</span>
<span class="sd">              5 2147483647          5          1 2147483647          2</span>
<span class="sd">              2          7          4          5          5          5</span>
<span class="sd">              6          5          5          3          2          7</span>
<span class="sd">              5          4          3          5          4          6</span>
<span class="sd">              3          5          5          3          4          4</span>
<span class="sd">              6          4          4          5 2147483647 2147483647</span>
<span class="sd">              2          5          7          3 2147483647 2147483647</span>
<span class="sd">              5          6          4          7          4          4</span>
<span class="sd">              3          4          6          4          3 2147483647</span>
<span class="sd">              5          6          3          4          6          5</span>
<span class="sd">              5          3          4          5]</span>
<span class="sd">    &gt;&gt;&gt;</span>
<span class="sd">    &gt;&gt;&gt; dist = gt.shortest_distance(g)</span>
<span class="sd">    &gt;&gt;&gt; print(dist[g.vertex(0)].a)</span>
<span class="sd">    [         0          4          5          6 2147483647          5</span>
<span class="sd">              4          3 2147483647          4          4          6</span>
<span class="sd">              6          5          5          4          4          2</span>
<span class="sd">              5          1 2147483647          6          5          5</span>
<span class="sd">              5          7          5          4          6          5</span>
<span class="sd">              5          4          1          4          4          3</span>
<span class="sd">              5 2147483647          5          1 2147483647          2</span>
<span class="sd">              2          7          4          5          5          5</span>
<span class="sd">              6          5          5          3          2          7</span>
<span class="sd">              5          4          3          5          4          6</span>
<span class="sd">              3          5          5          3          4          4</span>
<span class="sd">              6          4          4          5 2147483647 2147483647</span>
<span class="sd">              2          5          7          3 2147483647 2147483647</span>
<span class="sd">              5          6          4          7          4          4</span>
<span class="sd">              3          4          6          4          3 2147483647</span>
<span class="sd">              5          6          3          4          6          5</span>
<span class="sd">              5          3          4          5]</span>
<span class="sd">    &gt;&gt;&gt; dist = gt.shortest_distance(g, source=g.vertex(0), target=g.vertex(2))</span>
<span class="sd">    &gt;&gt;&gt; print(dist)</span>
<span class="sd">    5</span>
<span class="sd">    &gt;&gt;&gt; dist = gt.shortest_distance(g, source=g.vertex(0), target=[g.vertex(2), g.vertex(6)])</span>
<span class="sd">    &gt;&gt;&gt; print(dist)</span>
<span class="sd">    [5 4]</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    .. [bfs] Edward Moore, &quot;The shortest path through a maze&quot;, International</span>
<span class="sd">       Symposium on the Theory of Switching (1959), Harvard University Press.</span>
<span class="sd">    .. [bfs-boost] http://www.boost.org/libs/graph/doc/breadth_first_search.html</span>
<span class="sd">    .. [dijkstra] E. Dijkstra, &quot;A note on two problems in connexion with</span>
<span class="sd">       graphs.&quot; Numerische Mathematik, 1:269-271, 1959.</span>
<span class="sd">    .. [dijkstra-boost] http://www.boost.org/libs/graph/doc/dijkstra_shortest_paths.html</span>
<span class="sd">    .. [johnson-apsp] http://www.boost.org/libs/graph/doc/johnson_all_pairs_shortest.html</span>
<span class="sd">    .. [floyd-warshall-apsp] http://www.boost.org/libs/graph/doc/floyd_warshall_shortest.html</span>
<span class="sd">    .. [bellman-ford] http://www.boost.org/libs/graph/doc/bellman_ford_shortest.html</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">tgtlist</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">target</span><span class="p">,</span> <span class="n">collections</span><span class="o">.</span><span class="n">Iterable</span><span class="p">):</span>
        <span class="n">tgtlist</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="n">target</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">target</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="s2">&quot;int64&quot;</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">target</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">target</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">([],</span> <span class="n">dtype</span><span class="o">=</span><span class="s2">&quot;int64&quot;</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">target</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">asarray</span><span class="p">([</span><span class="nb">int</span><span class="p">(</span><span class="n">target</span><span class="p">)],</span> <span class="n">dtype</span><span class="o">=</span><span class="s2">&quot;int64&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">weights</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">dist_type</span> <span class="o">=</span> <span class="s1">&#39;int32_t&#39;</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">dist_type</span> <span class="o">=</span> <span class="n">weights</span><span class="o">.</span><span class="n">value_type</span><span class="p">()</span>

    <span class="k">if</span> <span class="n">dist_map</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">source</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">dist_map</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">new_vertex_property</span><span class="p">(</span><span class="n">dist_type</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">dist_map</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">new_vertex_property</span><span class="p">(</span><span class="s2">&quot;vector&lt;</span><span class="si">%s</span><span class="s2">&gt;&quot;</span> <span class="o">%</span> <span class="n">dist_type</span><span class="p">)</span>

    <span class="n">_check_prop_writable</span><span class="p">(</span><span class="n">dist_map</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;dist_map&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">source</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">_check_prop_scalar</span><span class="p">(</span><span class="n">dist_map</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;dist_map&quot;</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">_check_prop_vector</span><span class="p">(</span><span class="n">dist_map</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;dist_map&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">max_dist</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">max_dist</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="k">if</span> <span class="n">directed</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">u</span> <span class="o">=</span> <span class="n">GraphView</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">directed</span><span class="o">=</span><span class="n">directed</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">u</span> <span class="o">=</span> <span class="n">g</span>

    <span class="k">if</span> <span class="n">source</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">numpy</span><span class="o">.</span><span class="n">issubdtype</span><span class="p">(</span><span class="n">dist_map</span><span class="o">.</span><span class="n">a</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">numpy</span><span class="o">.</span><span class="n">integer</span><span class="p">):</span>
            <span class="n">dist_map</span><span class="o">.</span><span class="n">fa</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">iinfo</span><span class="p">(</span><span class="n">dist_map</span><span class="o">.</span><span class="n">a</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span><span class="o">.</span><span class="n">max</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">dist_map</span><span class="o">.</span><span class="n">fa</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">inf</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">pred_map</span><span class="p">,</span> <span class="n">PropertyMap</span><span class="p">):</span>
            <span class="n">pmap</span> <span class="o">=</span> <span class="n">pred_map</span>
            <span class="k">if</span> <span class="n">pmap</span><span class="o">.</span><span class="n">value_type</span><span class="p">()</span> <span class="o">!=</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;supplied pred_map must be of value type &#39;int64_t&#39;&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">pmap</span> <span class="o">=</span> <span class="n">u</span><span class="o">.</span><span class="n">copy_property</span><span class="p">(</span><span class="n">u</span><span class="o">.</span><span class="n">vertex_index</span><span class="p">,</span> <span class="n">value_type</span><span class="o">=</span><span class="s2">&quot;int64_t&quot;</span><span class="p">)</span>
        <span class="n">reached</span> <span class="o">=</span> <span class="n">libcore</span><span class="o">.</span><span class="n">Vector_size_t</span><span class="p">()</span>
        <span class="n">libgraph_tool_topology</span><span class="o">.</span><span class="n">get_dists</span><span class="p">(</span><span class="n">u</span><span class="o">.</span><span class="n">_Graph__graph</span><span class="p">,</span>
                                         <span class="nb">int</span><span class="p">(</span><span class="n">source</span><span class="p">),</span>
                                         <span class="n">target</span><span class="p">,</span>
                                         <span class="n">_prop</span><span class="p">(</span><span class="s2">&quot;v&quot;</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">dist_map</span><span class="p">),</span>
                                         <span class="n">_prop</span><span class="p">(</span><span class="s2">&quot;e&quot;</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">weights</span><span class="p">),</span>
                                         <span class="n">_prop</span><span class="p">(</span><span class="s2">&quot;v&quot;</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">pmap</span><span class="p">),</span>
                                         <span class="nb">float</span><span class="p">(</span><span class="n">max_dist</span><span class="p">),</span>
                                         <span class="n">negative_weights</span><span class="p">,</span> <span class="n">reached</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">libgraph_tool_topology</span><span class="o">.</span><span class="n">get_all_dists</span><span class="p">(</span><span class="n">u</span><span class="o">.</span><span class="n">_Graph__graph</span><span class="p">,</span>
                                             <span class="n">_prop</span><span class="p">(</span><span class="s2">&quot;v&quot;</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">dist_map</span><span class="p">),</span>
                                             <span class="n">_prop</span><span class="p">(</span><span class="s2">&quot;e&quot;</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">weights</span><span class="p">),</span> <span class="n">dense</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">source</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">target</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">target</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">tgtlist</span><span class="p">:</span>
            <span class="n">dist_map</span> <span class="o">=</span> <span class="n">dist_map</span><span class="o">.</span><span class="n">a</span><span class="p">[</span><span class="n">target</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">dist_map</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">dist_map</span><span class="o">.</span><span class="n">a</span><span class="p">[</span><span class="n">target</span><span class="p">])</span>

    <span class="k">if</span> <span class="n">source</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">pred_map</span><span class="p">:</span>
            <span class="n">ret</span> <span class="o">=</span> <span class="p">(</span><span class="n">dist_map</span><span class="p">,</span> <span class="n">pmap</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">ret</span> <span class="o">=</span> <span class="p">(</span><span class="n">dist_map</span><span class="p">,)</span>
        <span class="k">if</span> <span class="n">return_reached</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">ret</span> <span class="o">+</span> <span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">reached</span><span class="o">.</span><span class="n">a</span><span class="o">.</span><span class="n">copy</span><span class="p">()),)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">ret</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">ret</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">return</span> <span class="n">ret</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">dist_map</span></div>

<div class="viewcode-block" id="shortest_path"><a class="viewcode-back" href="../../../../doc/topology.html#graph_tool.topology.shortest_path">[docs]</a><span class="k">def</span> <span class="nf">shortest_path</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">source</span><span class="p">,</span> <span class="n">target</span><span class="p">,</span> <span class="n">weights</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">negative_weights</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                  <span class="n">pred_map</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Return the shortest path from ``source`` to ``target``.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    g : :class:`~graph_tool.Graph`</span>
<span class="sd">        Graph to be used.</span>
<span class="sd">    source : :class:`~graph_tool.Vertex`</span>
<span class="sd">        Source vertex of the search.</span>
<span class="sd">    target : :class:`~graph_tool.Vertex`</span>
<span class="sd">        Target vertex of the search.</span>
<span class="sd">    weights : :class:`~graph_tool.PropertyMap` (optional, default: None)</span>
<span class="sd">        The edge weights.</span>
<span class="sd">    negative_weights : ``bool`` (optional, default: ``False``)</span>
<span class="sd">        If ``True``, this will trigger the use of the Bellman-Ford algorithm.</span>
<span class="sd">    pred_map :  :class:`~graph_tool.PropertyMap` (optional, default: None)</span>
<span class="sd">        Vertex property map with the predecessors in the search tree. If this is</span>
<span class="sd">        provided, the shortest paths are not computed, and are obtained directly</span>
<span class="sd">        from this map.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    vertex_list : list of :class:`~graph_tool.Vertex`</span>
<span class="sd">        List of vertices from `source` to `target` in the shortest path.</span>
<span class="sd">    edge_list : list of :class:`~graph_tool.Edge`</span>
<span class="sd">        List of edges from `source` to `target` in the shortest path.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>

<span class="sd">    The paths are computed with a breadth-first search (BFS) or Dijkstra&#39;s</span>
<span class="sd">    algorithm [dijkstra]_, if weights are given. If ``negative_weights ==</span>
<span class="sd">    True``, the Bellman-Ford algorithm is used [bellman-ford]_, which accepts</span>
<span class="sd">    negative weights, as long as there are no negative loops.</span>

<span class="sd">    The algorithm runs in :math:`O(V + E)` time, or :math:`O(V \log V)` if</span>
<span class="sd">    weights are given.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    .. testcode::</span>
<span class="sd">       :hide:</span>

<span class="sd">       import numpy.random</span>
<span class="sd">       numpy.random.seed(43)</span>
<span class="sd">       gt.seed_rng(43)</span>

<span class="sd">    &gt;&gt;&gt; from numpy.random import poisson</span>
<span class="sd">    &gt;&gt;&gt; g = gt.random_graph(300, lambda: (poisson(4), poisson(4)))</span>
<span class="sd">    &gt;&gt;&gt; vlist, elist = gt.shortest_path(g, g.vertex(10), g.vertex(11))</span>
<span class="sd">    &gt;&gt;&gt; print([str(v) for v in vlist])</span>
<span class="sd">    [&#39;10&#39;, &#39;131&#39;, &#39;118&#39;, &#39;207&#39;, &#39;195&#39;, &#39;11&#39;]</span>
<span class="sd">    &gt;&gt;&gt; print([str(e) for e in elist])</span>
<span class="sd">    [&#39;(10, 131)&#39;, &#39;(131, 118)&#39;, &#39;(118, 207)&#39;, &#39;(207, 195)&#39;, &#39;(195, 11)&#39;]</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    .. [bfs] Edward Moore, &quot;The shortest path through a maze&quot;, International</span>
<span class="sd">       Symposium on the Theory of Switching (1959), Harvard University</span>
<span class="sd">       Press</span>
<span class="sd">    .. [bfs-boost] http://www.boost.org/libs/graph/doc/breadth_first_search.html</span>
<span class="sd">    .. [dijkstra] E. Dijkstra, &quot;A note on two problems in connexion with</span>
<span class="sd">       graphs.&quot; Numerische Mathematik, 1:269-271, 1959.</span>
<span class="sd">    .. [dijkstra-boost] http://www.boost.org/libs/graph/doc/dijkstra_shortest_paths.html</span>
<span class="sd">    .. [bellman-ford] http://www.boost.org/libs/graph/doc/bellman_ford_shortest.html</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="n">pred_map</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">pred_map</span> <span class="o">=</span> <span class="n">shortest_distance</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">source</span><span class="p">,</span> <span class="n">target</span><span class="p">,</span> <span class="n">weights</span><span class="o">=</span><span class="n">weights</span><span class="p">,</span>
                                     <span class="n">negative_weights</span><span class="o">=</span><span class="n">negative_weights</span><span class="p">,</span>
                                     <span class="n">pred_map</span><span class="o">=</span><span class="kc">True</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span>

    <span class="k">if</span> <span class="n">pred_map</span><span class="p">[</span><span class="n">target</span><span class="p">]</span> <span class="o">==</span> <span class="nb">int</span><span class="p">(</span><span class="n">target</span><span class="p">):</span>  <span class="c1"># no path to target</span>
        <span class="k">return</span> <span class="p">[],</span> <span class="p">[]</span>

    <span class="n">vlist</span> <span class="o">=</span> <span class="p">[</span><span class="n">target</span><span class="p">]</span>
    <span class="n">elist</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">if</span> <span class="n">weights</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">max_w</span> <span class="o">=</span> <span class="n">weights</span><span class="o">.</span><span class="n">a</span><span class="o">.</span><span class="n">max</span><span class="p">()</span> <span class="o">+</span> <span class="mi">1</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">max_w</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="n">v</span> <span class="o">=</span> <span class="n">target</span>
    <span class="k">while</span> <span class="n">v</span> <span class="o">!=</span> <span class="n">source</span><span class="p">:</span>
        <span class="n">p</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">vertex</span><span class="p">(</span><span class="n">pred_map</span><span class="p">[</span><span class="n">v</span><span class="p">])</span>
        <span class="n">min_w</span> <span class="o">=</span> <span class="n">max_w</span>
        <span class="n">pe</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">s</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">v</span><span class="o">.</span><span class="n">in_edges</span><span class="p">()</span> <span class="k">if</span> <span class="n">g</span><span class="o">.</span><span class="n">is_directed</span><span class="p">()</span> <span class="k">else</span> <span class="n">v</span><span class="o">.</span><span class="n">out_edges</span><span class="p">():</span>
            <span class="n">s</span> <span class="o">=</span> <span class="n">e</span><span class="o">.</span><span class="n">source</span><span class="p">()</span> <span class="k">if</span> <span class="n">g</span><span class="o">.</span><span class="n">is_directed</span><span class="p">()</span> <span class="k">else</span> <span class="n">e</span><span class="o">.</span><span class="n">target</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">s</span> <span class="o">==</span> <span class="n">p</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">weights</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">weights</span><span class="p">[</span><span class="n">e</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">min_w</span><span class="p">:</span>
                        <span class="n">min_w</span> <span class="o">=</span> <span class="n">weights</span><span class="p">[</span><span class="n">e</span><span class="p">]</span>
                        <span class="n">pe</span> <span class="o">=</span> <span class="n">e</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">pe</span> <span class="o">=</span> <span class="n">e</span>
                    <span class="k">break</span>
        <span class="n">elist</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">pe</span><span class="p">)</span>
        <span class="n">vlist</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">p</span><span class="p">)</span>
        <span class="n">v</span> <span class="o">=</span> <span class="n">p</span>
    <span class="k">return</span> <span class="n">vlist</span><span class="p">,</span> <span class="n">elist</span></div>

<div class="viewcode-block" id="all_predecessors"><a class="viewcode-back" href="../../../../doc/topology.html#graph_tool.topology.all_predecessors">[docs]</a><span class="k">def</span> <span class="nf">all_predecessors</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">dist_map</span><span class="p">,</span> <span class="n">pred_map</span><span class="p">,</span> <span class="n">weights</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">epsilon</span><span class="o">=</span><span class="mf">1e-8</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Return a property map with all possible predecessors in the search tree</span>
<span class="sd">        determined by ``dist_map`` and ``pred_map``.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    g : :class:`~graph_tool.Graph`</span>
<span class="sd">        Graph to be used.</span>
<span class="sd">    dist_map : :class:`~graph_tool.PropertyMap`</span>
<span class="sd">        Vertex property map with the distances from ``source`` to all other</span>
<span class="sd">        vertices.</span>
<span class="sd">    pred_map : :class:`~graph_tool.PropertyMap` (optional, default: None)</span>
<span class="sd">        Vertex property map with the predecessors in the search tree.</span>
<span class="sd">    weights : :class:`~graph_tool.PropertyMap` (optional, default: None)</span>
<span class="sd">        The edge weights.</span>
<span class="sd">    epsilon : `float` (optional, default: `1e-8`)</span>
<span class="sd">        Maximum relative difference between distances to be considered &quot;equal&quot;,</span>
<span class="sd">        in case floating-point weights are used.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    all_preds_map : :class:`~graph_tool.PropertyMap`</span>
<span class="sd">        Vector-valued vertex property map with all possible predecessors in the</span>
<span class="sd">        search tree.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">preds</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">new_vertex_property</span><span class="p">(</span><span class="s2">&quot;vector&lt;int64_t&gt;&quot;</span><span class="p">)</span>
    <span class="n">libgraph_tool_topology</span><span class="o">.</span><span class="n">get_all_preds</span><span class="p">(</span><span class="n">g</span><span class="o">.</span><span class="n">_Graph__graph</span><span class="p">,</span>
                                         <span class="n">_prop</span><span class="p">(</span><span class="s2">&quot;v&quot;</span><span class="p">,</span> <span class="n">g</span><span class="p">,</span> <span class="n">dist_map</span><span class="p">),</span>
                                         <span class="n">_prop</span><span class="p">(</span><span class="s2">&quot;v&quot;</span><span class="p">,</span> <span class="n">g</span><span class="p">,</span> <span class="n">pred_map</span><span class="p">),</span>
                                         <span class="n">_prop</span><span class="p">(</span><span class="s2">&quot;e&quot;</span><span class="p">,</span> <span class="n">g</span><span class="p">,</span> <span class="n">weights</span><span class="p">),</span>
                                         <span class="n">_prop</span><span class="p">(</span><span class="s2">&quot;v&quot;</span><span class="p">,</span> <span class="n">g</span><span class="p">,</span> <span class="n">preds</span><span class="p">),</span>
                                         <span class="n">epsilon</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">preds</span></div>

<div class="viewcode-block" id="all_shortest_paths"><a class="viewcode-back" href="../../../../doc/topology.html#graph_tool.topology.all_shortest_paths">[docs]</a><span class="k">def</span> <span class="nf">all_shortest_paths</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">source</span><span class="p">,</span> <span class="n">target</span><span class="p">,</span> <span class="n">weights</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">negative_weights</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                       <span class="n">dist_map</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">pred_map</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">all_preds_map</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                       <span class="n">epsilon</span><span class="o">=</span><span class="mf">1e-8</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Return an iterator over all shortest paths from `source` to `target`.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    g : :class:`~graph_tool.Graph`</span>
<span class="sd">        Graph to be used.</span>
<span class="sd">    source : :class:`~graph_tool.Vertex`</span>
<span class="sd">        Source vertex of the search.</span>
<span class="sd">    target : :class:`~graph_tool.Vertex`</span>
<span class="sd">        Target vertex of the search.</span>
<span class="sd">    weights : :class:`~graph_tool.PropertyMap` (optional, default: None)</span>
<span class="sd">        The edge weights.</span>
<span class="sd">    negative_weights : ``bool`` (optional, default: ``False``)</span>
<span class="sd">        If ``True``, this will trigger the use of the Bellman-Ford algorithm.</span>
<span class="sd">    dist_map : :class:`~graph_tool.PropertyMap` (optional, default: None)</span>
<span class="sd">        Vertex property map with the distances from ``source`` to all other</span>
<span class="sd">        vertices.</span>
<span class="sd">    pred_map : :class:`~graph_tool.PropertyMap` (optional, default: None)</span>
<span class="sd">        Vertex property map with the predecessors in the search tree. If this is</span>
<span class="sd">        provided, the shortest paths are not computed, and are obtained directly</span>
<span class="sd">        from this map.</span>
<span class="sd">    all_preds_map : :class:`~graph_tool.PropertyMap` (optional, default: None)</span>
<span class="sd">        Vector-valued vertex property map with all possible predecessors in the</span>
<span class="sd">        search tree. If this is provided, the shortest paths are obtained</span>
<span class="sd">        directly from this map.</span>
<span class="sd">    epsilon : `float` (optional, default: `1e-8`)</span>
<span class="sd">        Maximum relative difference between distances to be considered &quot;equal&quot;,</span>
<span class="sd">        in case floating-point weights are used.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    path_iterator : iterator over a sequence of integers</span>
<span class="sd">        Iterator over sequences of vertices from `source` to `target` in the</span>
<span class="sd">        shortest path.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>

<span class="sd">    The paths are computed with a breadth-first search (BFS) or Dijkstra&#39;s</span>
<span class="sd">    algorithm [dijkstra]_, if weights are given. If ``negative_weights ==</span>
<span class="sd">    True``, the Bellman-Ford algorithm is used [bellman-ford]_, which accepts</span>
<span class="sd">    negative weights, as long as there are no negative loops.</span>

<span class="sd">    If both ``dist_map`` and ``pred_map`` are provided, the search is not</span>
<span class="sd">    actually performed.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>

<span class="sd">    &gt;&gt;&gt; g = gt.collection.data[&quot;pgp-strong-2009&quot;]</span>
<span class="sd">    &gt;&gt;&gt; for path in gt.all_shortest_paths(g, 92, 45):</span>
<span class="sd">    ...     print(path)</span>
<span class="sd">    [  92  107 2176 7027   26   21   45]</span>
<span class="sd">    [  92  107 2176 7033   26   21   45]</span>
<span class="sd">    [  92   82   94 5877 5879   34   45]</span>
<span class="sd">    [  92   89   94 5877 5879   34   45]</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    .. [bfs] Edward Moore, &quot;The shortest path through a maze&quot;, International</span>
<span class="sd">       Symposium on the Theory of Switching (1959), Harvard University</span>
<span class="sd">       Press</span>
<span class="sd">    .. [bfs-boost] http://www.boost.org/libs/graph/doc/breadth_first_search.html</span>
<span class="sd">    .. [dijkstra] E. Dijkstra, &quot;A note on two problems in connexion with</span>
<span class="sd">       graphs.&quot; Numerische Mathematik, 1:269-271, 1959.</span>
<span class="sd">    .. [dijkstra-boost] http://www.boost.org/libs/graph/doc/dijkstra_shortest_paths.html</span>
<span class="sd">    .. [bellman-ford] http://www.boost.org/libs/graph/doc/bellman_ford_shortest.html</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="n">dist_map</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">pred_map</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">dist_map</span><span class="p">,</span> <span class="n">pred_map</span> <span class="o">=</span> <span class="n">shortest_distance</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">source</span><span class="p">,</span> <span class="n">weights</span><span class="o">=</span><span class="n">weights</span><span class="p">,</span>
                                               <span class="n">negative_weights</span><span class="o">=</span><span class="n">negative_weights</span><span class="p">,</span>
                                               <span class="n">pred_map</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">all_preds_map</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">all_preds_map</span> <span class="o">=</span> <span class="n">all_predecessors</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">dist_map</span><span class="p">,</span> <span class="n">pred_map</span><span class="p">,</span> <span class="n">weights</span><span class="p">,</span> <span class="n">epsilon</span><span class="p">)</span>

    <span class="n">path_iterator</span> <span class="o">=</span> \
        <span class="n">libgraph_tool_topology</span><span class="o">.</span><span class="n">get_all_shortest_paths</span><span class="p">(</span><span class="n">g</span><span class="o">.</span><span class="n">_Graph__graph</span><span class="p">,</span>
                                                      <span class="nb">int</span><span class="p">(</span><span class="n">source</span><span class="p">),</span>
                                                      <span class="nb">int</span><span class="p">(</span><span class="n">target</span><span class="p">),</span>
                                                      <span class="n">_prop</span><span class="p">(</span><span class="s2">&quot;v&quot;</span><span class="p">,</span> <span class="n">g</span><span class="p">,</span> <span class="n">all_preds_map</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">path_iterator</span></div>

<div class="viewcode-block" id="all_paths"><a class="viewcode-back" href="../../../../doc/topology.html#graph_tool.topology.all_paths">[docs]</a><span class="k">def</span> <span class="nf">all_paths</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">source</span><span class="p">,</span> <span class="n">target</span><span class="p">,</span> <span class="n">cutoff</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Return an iterator over all paths from `source` to `target`.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    g : :class:`~graph_tool.Graph`</span>
<span class="sd">        Graph to be used.</span>
<span class="sd">    source : :class:`~graph_tool.Vertex`</span>
<span class="sd">        Source vertex of the search.</span>
<span class="sd">    target : :class:`~graph_tool.Vertex`</span>
<span class="sd">        Target vertex of the search.</span>
<span class="sd">    cutoff : `int` (optional, default: None)</span>
<span class="sd">        Maximum path length.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    path_iterator : iterator over a sequence of integers</span>
<span class="sd">        Iterator over sequences of vertices from `source` to `target` in the</span>
<span class="sd">        path.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>

<span class="sd">    The algorithm uses a depth-first search to find all the paths.</span>

<span class="sd">    The total number of paths between any two vertices can be quite large,</span>
<span class="sd">    possibly scaling as :math:`O(V!)`.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>

<span class="sd">    &gt;&gt;&gt; g = gt.collection.data[&quot;football&quot;]</span>
<span class="sd">    &gt;&gt;&gt; for path in gt.all_paths(g, 13, 2, cutoff=2):</span>
<span class="sd">    ...     print(path)</span>
<span class="sd">    [13  2]</span>
<span class="sd">    [13 15  2]</span>
<span class="sd">    [13 60  2]</span>
<span class="sd">    [13 64  2]</span>
<span class="sd">    [ 13 100   2]</span>
<span class="sd">    [ 13 106   2]</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="n">cutoff</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">cutoff</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">num_edges</span><span class="p">()</span> <span class="o">+</span> <span class="mi">1</span>
    <span class="n">visited</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">new_vp</span><span class="p">(</span><span class="s2">&quot;bool&quot;</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>
    <span class="n">path_iterator</span> <span class="o">=</span> <span class="n">libgraph_tool_topology</span><span class="o">.</span><span class="n">get_all_paths</span><span class="p">(</span><span class="n">g</span><span class="o">.</span><span class="n">_Graph__graph</span><span class="p">,</span>
                                                         <span class="nb">int</span><span class="p">(</span><span class="n">source</span><span class="p">),</span>
                                                         <span class="nb">int</span><span class="p">(</span><span class="n">target</span><span class="p">),</span>
                                                         <span class="n">cutoff</span><span class="p">,</span>
                                                         <span class="n">_prop</span><span class="p">(</span><span class="s2">&quot;v&quot;</span><span class="p">,</span> <span class="n">g</span><span class="p">,</span> <span class="n">visited</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">path_iterator</span></div>

<div class="viewcode-block" id="all_circuits"><a class="viewcode-back" href="../../../../doc/topology.html#graph_tool.topology.all_circuits">[docs]</a><span class="k">def</span> <span class="nf">all_circuits</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">unique</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Return an iterator over all the cycles in a directed graph.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    g : :class:`~graph_tool.Graph`</span>
<span class="sd">        A directed graph to be used.</span>
<span class="sd">    unique : ``bool`` (optional, default: None)</span>
<span class="sd">        If ``True``, parallel edges and self-loops will be ignored.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    cycle_iterator : iterator over a sequence of integers</span>
<span class="sd">        Iterator over sequences of vertices that form a circuit.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    This algorithm [hawick-enumerating-2008]_ runs in worse time</span>
<span class="sd">    :math:`O[(V + E)(C + 1)]`, where :math:`C` is the number of circuits.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    .. testcode::</span>
<span class="sd">       :hide:</span>

<span class="sd">       gt.seed_rng(42)</span>

<span class="sd">    &gt;&gt;&gt; g = gt.random_graph(10, lambda: (1, 1))</span>
<span class="sd">    &gt;&gt;&gt; for c in gt.all_circuits(g):</span>
<span class="sd">    ...     print(c)</span>
<span class="sd">    [0 4 7 1 8 2]</span>
<span class="sd">    [3 9 6 5]</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    .. [hawick-enumerating-2008] K.A. Hawick and H.A. James, &quot;Enumerating</span>
<span class="sd">       Circuits and Loops in Graphs with Self-Arcs and Multiple-Arcs.&quot;,</span>
<span class="sd">       In Proceedings of FCS. 2008, 14-20,</span>
<span class="sd">       http://cssg.massey.ac.nz/cstn/013/cstn-013.html</span>
<span class="sd">    .. [hawick-bgl] http://www.boost.org/doc/libs/graph/doc/hawick_circuits.html</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">g</span><span class="o">.</span><span class="n">is_directed</span><span class="p">():</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;The graph must be directed.&quot;</span><span class="p">)</span>
    <span class="n">circuits_iterator</span> <span class="o">=</span> <span class="n">libgraph_tool_topology</span><span class="o">.</span><span class="n">get_all_circuits</span><span class="p">(</span><span class="n">g</span><span class="o">.</span><span class="n">_Graph__graph</span><span class="p">,</span>
                                                                <span class="n">unique</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">circuits_iterator</span></div>


<div class="viewcode-block" id="pseudo_diameter"><a class="viewcode-back" href="../../../../doc/topology.html#graph_tool.topology.pseudo_diameter">[docs]</a><span class="k">def</span> <span class="nf">pseudo_diameter</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">source</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">weights</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compute the pseudo-diameter of the graph.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    g : :class:`~graph_tool.Graph`</span>
<span class="sd">        Graph to be used.</span>
<span class="sd">    source : :class:`~graph_tool.Vertex` (optional, default: `None`)</span>
<span class="sd">        Source vertex of the search. If not supplied, the first vertex</span>
<span class="sd">        in the graph will be chosen.</span>
<span class="sd">    weights : :class:`~graph_tool.PropertyMap` (optional, default: `None`)</span>
<span class="sd">        The edge weights.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    pseudo_diameter : int</span>
<span class="sd">        The pseudo-diameter of the graph.</span>
<span class="sd">    end_points : pair of :class:`~graph_tool.Vertex`</span>
<span class="sd">        The two vertices which correspond to the pseudo-diameter found.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>

<span class="sd">    The pseudo-diameter is an approximate graph diameter. It is obtained by</span>
<span class="sd">    starting from a vertex `source`, and finds a vertex `target` that is</span>
<span class="sd">    farthest away from `source`. This process is repeated by treating</span>
<span class="sd">    `target` as the new starting vertex, and ends when the graph distance no</span>
<span class="sd">    longer increases. A vertex from the last level set that has the smallest</span>
<span class="sd">    degree is chosen as the final starting vertex u, and a traversal is done</span>
<span class="sd">    to see if the graph distance can be increased. This graph distance is</span>
<span class="sd">    taken to be the pseudo-diameter.</span>

<span class="sd">    The paths are computed with a breadth-first search (BFS) or Dijkstra&#39;s</span>
<span class="sd">    algorithm [dijkstra]_, if weights are given.</span>

<span class="sd">    The algorithm runs in :math:`O(V + E)` time, or :math:`O(V \log V)` if</span>
<span class="sd">    weights are given.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    .. testcode::</span>
<span class="sd">       :hide:</span>

<span class="sd">       import numpy.random</span>
<span class="sd">       numpy.random.seed(42)</span>
<span class="sd">       gt.seed_rng(42)</span>

<span class="sd">    &gt;&gt;&gt; from numpy.random import poisson</span>
<span class="sd">    &gt;&gt;&gt; g = gt.random_graph(300, lambda: (poisson(3), poisson(3)))</span>
<span class="sd">    &gt;&gt;&gt; dist, ends = gt.pseudo_diameter(g)</span>
<span class="sd">    &gt;&gt;&gt; print(dist)</span>
<span class="sd">    10.0</span>
<span class="sd">    &gt;&gt;&gt; print(int(ends[0]), int(ends[1]))</span>
<span class="sd">    0 11</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    .. [pseudo-diameter] http://en.wikipedia.org/wiki/Distance_%28graph_theory%29</span>
<span class="sd">    .. [dijkstra] E. Dijkstra, &quot;A note on two problems in connexion with</span>
<span class="sd">       graphs.&quot; Numerische Mathematik, 1:269-271, 1959.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="n">source</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">source</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">vertex</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">use_index</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    <span class="n">dist</span><span class="p">,</span> <span class="n">target</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">source</span>
    <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
        <span class="n">new_source</span> <span class="o">=</span> <span class="n">target</span>
        <span class="n">new_target</span><span class="p">,</span> <span class="n">new_dist</span> <span class="o">=</span> <span class="n">libgraph_tool_topology</span><span class="o">.</span><span class="n">get_diam</span><span class="p">(</span><span class="n">g</span><span class="o">.</span><span class="n">_Graph__graph</span><span class="p">,</span>
                                                               <span class="nb">int</span><span class="p">(</span><span class="n">new_source</span><span class="p">),</span>
                                                               <span class="n">_prop</span><span class="p">(</span><span class="s2">&quot;e&quot;</span><span class="p">,</span> <span class="n">g</span><span class="p">,</span> <span class="n">weights</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">new_dist</span> <span class="o">&gt;</span> <span class="n">dist</span><span class="p">:</span>
            <span class="n">target</span> <span class="o">=</span> <span class="n">new_target</span>
            <span class="n">source</span> <span class="o">=</span> <span class="n">new_source</span>
            <span class="n">dist</span> <span class="o">=</span> <span class="n">new_dist</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">break</span>
    <span class="k">return</span> <span class="n">dist</span><span class="p">,</span> <span class="p">(</span><span class="n">g</span><span class="o">.</span><span class="n">vertex</span><span class="p">(</span><span class="n">source</span><span class="p">),</span> <span class="n">g</span><span class="o">.</span><span class="n">vertex</span><span class="p">(</span><span class="n">target</span><span class="p">))</span></div>


<div class="viewcode-block" id="is_bipartite"><a class="viewcode-back" href="../../../../doc/topology.html#graph_tool.topology.is_bipartite">[docs]</a><span class="k">def</span> <span class="nf">is_bipartite</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">partition</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">find_odd_cycle</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Test if the graph is bipartite.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    g : :class:`~graph_tool.Graph`</span>
<span class="sd">        Graph to be used.</span>
<span class="sd">    partition : bool (optional, default: ``False``)</span>
<span class="sd">        If ``True``, return the two partitions in case the graph is bipartite.</span>
<span class="sd">    find_odd_cycle : bool (optional, default: ``False``)</span>
<span class="sd">        If ``True``, return an odd cycle if the graph is not bipartite.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    is_bipartite : ``bool``</span>
<span class="sd">        Whether or not the graph is bipartite.</span>
<span class="sd">    partition : :class:`~graph_tool.PropertyMap` (only if ``partition=True``)</span>
<span class="sd">        A vertex property map with the graph partitioning (or ``None``) if the</span>
<span class="sd">        graph is not bipartite.</span>
<span class="sd">    odd_cycle : list of vertices (only if ``find_odd_cycle=True``)</span>
<span class="sd">        A list of vertices corresponding to an odd cycle, or ``None`` if none is</span>
<span class="sd">        found.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>

<span class="sd">    An undirected graph is bipartite if one can partition its set of vertices</span>
<span class="sd">    into two sets, such that all edges go from one set to the other.</span>

<span class="sd">    This algorithm runs in :math:`O(V + E)` time.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; g = gt.lattice([10, 10])</span>
<span class="sd">    &gt;&gt;&gt; is_bi, part = gt.is_bipartite(g, partition=True)</span>
<span class="sd">    &gt;&gt;&gt; print(is_bi)</span>
<span class="sd">    True</span>
<span class="sd">    &gt;&gt;&gt; gt.graph_draw(g, vertex_fill_color=part, output_size=(300, 300), output=&quot;bipartite.pdf&quot;)</span>
<span class="sd">    &lt;...&gt;</span>

<span class="sd">    .. testcode::</span>
<span class="sd">       :hide:</span>

<span class="sd">       gt.graph_draw(g, vertex_fill_color=part, output_size=(300, 300), output=&quot;bipartite.png&quot;)</span>

<span class="sd">    .. figure:: bipartite.*</span>
<span class="sd">        :align: center</span>

<span class="sd">        Bipartition of a 2D lattice.</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    .. [boost-bipartite] http://www.boost.org/libs/graph/doc/is_bipartite.html</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="n">partition</span><span class="p">:</span>
        <span class="n">part</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">new_vertex_property</span><span class="p">(</span><span class="s2">&quot;bool&quot;</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">part</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">g</span> <span class="o">=</span> <span class="n">GraphView</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">directed</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">skip_properties</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">cycle</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">is_bi</span> <span class="o">=</span> <span class="n">libgraph_tool_topology</span><span class="o">.</span><span class="n">is_bipartite</span><span class="p">(</span><span class="n">g</span><span class="o">.</span><span class="n">_Graph__graph</span><span class="p">,</span>
                                                <span class="n">_prop</span><span class="p">(</span><span class="s2">&quot;v&quot;</span><span class="p">,</span> <span class="n">g</span><span class="p">,</span> <span class="n">part</span><span class="p">),</span>
                                                <span class="n">find_odd_cycle</span><span class="p">,</span> <span class="n">cycle</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">is_bi</span> <span class="ow">and</span> <span class="n">part</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">part</span><span class="o">.</span><span class="n">a</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">cycle</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">cycle</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">cycle</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">cycle</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

    <span class="k">if</span> <span class="n">find_odd_cycle</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">partition</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">is_bi</span><span class="p">,</span> <span class="n">part</span><span class="p">,</span> <span class="n">cycle</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">is_bi</span><span class="p">,</span> <span class="n">cycle</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">partition</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">is_bi</span><span class="p">,</span> <span class="n">part</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">is_bi</span></div>



<div class="viewcode-block" id="is_planar"><a class="viewcode-back" href="../../../../doc/topology.html#graph_tool.topology.is_planar">[docs]</a><span class="k">def</span> <span class="nf">is_planar</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">embedding</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">kuratowski</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Test if the graph is planar.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    g : :class:`~graph_tool.Graph`</span>
<span class="sd">        Graph to be used.</span>
<span class="sd">    embedding : bool (optional, default: False)</span>
<span class="sd">        If true, return a mapping from vertices to the clockwise order of</span>
<span class="sd">        out-edges in the planar embedding.</span>
<span class="sd">    kuratowski : bool (optional, default: False)</span>
<span class="sd">        If true, the minimal set of edges that form the obstructing Kuratowski</span>
<span class="sd">        subgraph will be returned as a property map, if the graph is not planar.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    is_planar : bool</span>
<span class="sd">        Whether or not the graph is planar.</span>
<span class="sd">    embedding : :class:`~graph_tool.PropertyMap` (only if `embedding=True`)</span>
<span class="sd">        A vertex property map with the out-edges indexes in clockwise order in</span>
<span class="sd">        the planar embedding,</span>
<span class="sd">    kuratowski : :class:`~graph_tool.PropertyMap` (only if `kuratowski=True`)</span>
<span class="sd">        An edge property map with the minimal set of edges that form the</span>
<span class="sd">        obstructing Kuratowski subgraph (if the value of kuratowski[e] is 1,</span>
<span class="sd">        the edge belongs to the set)</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>

<span class="sd">    A graph is planar if it can be drawn in two-dimensional space without any of</span>
<span class="sd">    its edges crossing. This algorithm performs the Boyer-Myrvold planarity</span>
<span class="sd">    testing [boyer-myrvold]_. See [boost-planarity]_ for more details.</span>

<span class="sd">    This algorithm runs in :math:`O(V)` time.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    .. testcode::</span>
<span class="sd">       :hide:</span>

<span class="sd">       import numpy.random</span>
<span class="sd">       numpy.random.seed(42)</span>
<span class="sd">       gt.seed_rng(42)</span>

<span class="sd">    &gt;&gt;&gt; from numpy.random import random</span>
<span class="sd">    &gt;&gt;&gt; g = gt.triangulation(random((100,2)))[0]</span>
<span class="sd">    &gt;&gt;&gt; p, embed_order = gt.is_planar(g, embedding=True)</span>
<span class="sd">    &gt;&gt;&gt; print(p)</span>
<span class="sd">    True</span>
<span class="sd">    &gt;&gt;&gt; print(list(embed_order[g.vertex(0)]))</span>
<span class="sd">    [0, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 1]</span>
<span class="sd">    &gt;&gt;&gt; g = gt.random_graph(100, lambda: 4, directed=False)</span>
<span class="sd">    &gt;&gt;&gt; p, kur = gt.is_planar(g, kuratowski=True)</span>
<span class="sd">    &gt;&gt;&gt; print(p)</span>
<span class="sd">    False</span>
<span class="sd">    &gt;&gt;&gt; g.set_edge_filter(kur, True)</span>
<span class="sd">    &gt;&gt;&gt; gt.graph_draw(g, output_size=(300, 300), output=&quot;kuratowski.pdf&quot;)</span>
<span class="sd">    &lt;...&gt;</span>

<span class="sd">    .. testcode::</span>
<span class="sd">       :hide:</span>

<span class="sd">       gt.graph_draw(g, output_size=(300, 300), output=&quot;kuratowski.png&quot;)</span>

<span class="sd">    .. figure:: kuratowski.*</span>
<span class="sd">        :align: center</span>

<span class="sd">        Obstructing Kuratowski subgraph of a random graph.</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    .. [boyer-myrvold] John M. Boyer and Wendy J. Myrvold, &quot;On the Cutting Edge:</span>
<span class="sd">       Simplified O(n) Planarity by Edge Addition&quot; Journal of Graph Algorithms</span>
<span class="sd">       and Applications, 8(2): 241-273, 2004. http://www.emis.ams.org/journals/JGAA/accepted/2004/BoyerMyrvold2004.8.3.pdf</span>
<span class="sd">    .. [boost-planarity] http://www.boost.org/libs/graph/doc/boyer_myrvold.html</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">u</span> <span class="o">=</span> <span class="n">GraphView</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">directed</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">embedding</span><span class="p">:</span>
        <span class="n">embed</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">new_vertex_property</span><span class="p">(</span><span class="s2">&quot;vector&lt;int&gt;&quot;</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">embed</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="k">if</span> <span class="n">kuratowski</span><span class="p">:</span>
        <span class="n">kur</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">new_edge_property</span><span class="p">(</span><span class="s2">&quot;bool&quot;</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">kur</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="n">is_planar</span> <span class="o">=</span> <span class="n">libgraph_tool_topology</span><span class="o">.</span><span class="n">is_planar</span><span class="p">(</span><span class="n">u</span><span class="o">.</span><span class="n">_Graph__graph</span><span class="p">,</span>
                                                 <span class="n">_prop</span><span class="p">(</span><span class="s2">&quot;v&quot;</span><span class="p">,</span> <span class="n">g</span><span class="p">,</span> <span class="n">embed</span><span class="p">),</span>
                                                 <span class="n">_prop</span><span class="p">(</span><span class="s2">&quot;e&quot;</span><span class="p">,</span> <span class="n">g</span><span class="p">,</span> <span class="n">kur</span><span class="p">))</span>

    <span class="n">ret</span> <span class="o">=</span> <span class="p">[</span><span class="n">is_planar</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">embed</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">ret</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">embed</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">kur</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">ret</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">kur</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">ret</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">ret</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">ret</span><span class="p">)</span></div>


<div class="viewcode-block" id="make_maximal_planar"><a class="viewcode-back" href="../../../../doc/topology.html#graph_tool.topology.make_maximal_planar">[docs]</a><span class="k">def</span> <span class="nf">make_maximal_planar</span><span class="p">(</span><span class="n">g</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Add edges to the graph to make it maximally planar.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    g : :class:`~graph_tool.Graph`</span>
<span class="sd">        Graph to be used. It must be a biconnected planar graph with at least 3</span>
<span class="sd">        vertices.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>

<span class="sd">    A graph is maximal planar if no additional edges can be added to it without</span>
<span class="sd">    creating a non-planar graph. By Euler&#39;s formula, a maximal planar graph with</span>
<span class="sd">    V &gt; 2 vertices always has 3V - 6 edges and 2V - 4 faces.</span>

<span class="sd">    The input graph to make_maximal_planar() must be a biconnected planar graph</span>
<span class="sd">    with at least 3 vertices.</span>

<span class="sd">    This algorithm runs in :math:`O(V + E)` time.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; g = gt.lattice([10, 10])</span>
<span class="sd">    &gt;&gt;&gt; gt.make_maximal_planar(g)</span>
<span class="sd">    &gt;&gt;&gt; gt.is_planar(g)</span>
<span class="sd">    True</span>
<span class="sd">    &gt;&gt;&gt; print(g.num_vertices(), g.num_edges())</span>
<span class="sd">    100 294</span>
<span class="sd">    &gt;&gt;&gt; pos = gt.planar_layout(g)</span>
<span class="sd">    &gt;&gt;&gt; gt.graph_draw(g, pos, output_size=(300, 300), output=&quot;maximal_planar.pdf&quot;)</span>
<span class="sd">    &lt;...&gt;</span>

<span class="sd">    .. testcode::</span>
<span class="sd">       :hide:</span>

<span class="sd">       gt.graph_draw(g, pos, output_size=(300, 300), output=&quot;maximal_planar.png&quot;)</span>

<span class="sd">    .. figure:: maximal_planar.*</span>
<span class="sd">        :align: center</span>

<span class="sd">        A maximally planar graph.</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    .. [boost-planarity] http://www.boost.org/libs/graph/doc/make_maximal_planar.html</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">g</span> <span class="o">=</span> <span class="n">GraphView</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">directed</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    <span class="n">libgraph_tool_topology</span><span class="o">.</span><span class="n">maximal_planar</span><span class="p">(</span><span class="n">g</span><span class="o">.</span><span class="n">_Graph__graph</span><span class="p">)</span></div>


<div class="viewcode-block" id="is_DAG"><a class="viewcode-back" href="../../../../doc/topology.html#graph_tool.topology.is_DAG">[docs]</a><span class="k">def</span> <span class="nf">is_DAG</span><span class="p">(</span><span class="n">g</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return `True` if the graph is a directed acyclic graph (DAG).</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    The time complexity is :math:`O(V + E)`.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    .. testcode::</span>
<span class="sd">       :hide:</span>

<span class="sd">       import numpy.random</span>
<span class="sd">       numpy.random.seed(42)</span>
<span class="sd">       gt.seed_rng(42)</span>

<span class="sd">    &gt;&gt;&gt; g = gt.random_graph(30, lambda: (3, 3))</span>
<span class="sd">    &gt;&gt;&gt; print(gt.is_DAG(g))</span>
<span class="sd">    False</span>
<span class="sd">    &gt;&gt;&gt; tree = gt.min_spanning_tree(g)</span>
<span class="sd">    &gt;&gt;&gt; g.set_edge_filter(tree)</span>
<span class="sd">    &gt;&gt;&gt; print(gt.is_DAG(g))</span>
<span class="sd">    True</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    .. [DAG-wiki] http://en.wikipedia.org/wiki/Directed_acyclic_graph</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">topological_order</span> <span class="o">=</span> <span class="n">Vector_int32_t</span><span class="p">()</span>
    <span class="n">is_DAG</span> <span class="o">=</span> <span class="n">libgraph_tool_topology</span><span class="o">.</span>\
        <span class="n">topological_sort</span><span class="p">(</span><span class="n">g</span><span class="o">.</span><span class="n">_Graph__graph</span><span class="p">,</span> <span class="n">topological_order</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">is_DAG</span></div>


<div class="viewcode-block" id="max_cardinality_matching"><a class="viewcode-back" href="../../../../doc/topology.html#graph_tool.topology.max_cardinality_matching">[docs]</a><span class="k">def</span> <span class="nf">max_cardinality_matching</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">heuristic</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">weight</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">minimize</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                             <span class="n">match</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;Find a maximum cardinality matching in the graph.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    g : :class:`~graph_tool.Graph`</span>
<span class="sd">        Graph to be used.</span>
<span class="sd">    heuristic : bool (optional, default: `False`)</span>
<span class="sd">        If true, a random heuristic will be used, which runs in linear time.</span>
<span class="sd">    weight : :class:`~graph_tool.PropertyMap` (optional, default: `None`)</span>
<span class="sd">        If provided, the matching will minimize the edge weights (or maximize</span>
<span class="sd">        if ``minimize == False``). This option has no effect if</span>
<span class="sd">        ``heuristic == False``.</span>
<span class="sd">    minimize : bool (optional, default: `True`)</span>
<span class="sd">        If `True`, the matching will minimize the weights, otherwise they will</span>
<span class="sd">        be maximized. This option has no effect if ``heuristic == False``.</span>
<span class="sd">    match : :class:`~graph_tool.PropertyMap` (optional, default: `None`)</span>
<span class="sd">        Edge property map where the matching will be specified.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    match : :class:`~graph_tool.PropertyMap`</span>
<span class="sd">        Boolean edge property map where the matching is specified.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    A *matching* is a subset of the edges of a graph such that no two edges</span>
<span class="sd">    share a common vertex. A *maximum cardinality matching* has maximum size</span>
<span class="sd">    over all matchings in the graph.</span>

<span class="sd">    If the parameter ``weight`` is provided, as well as ``heuristic == True`` a</span>
<span class="sd">    matching with maximum cardinality *and* maximum (or minimum) weight is</span>
<span class="sd">    returned.</span>

<span class="sd">    If ``heuristic == True`` the algorithm does not necessarily return the</span>
<span class="sd">    maximum matching, instead the focus is to run on linear time.</span>

<span class="sd">    This algorithm runs in time :math:`O(EV\times\alpha(E,V))`, where</span>
<span class="sd">    :math:`\alpha(m,n)` is a slow growing function that is at most 4 for any</span>
<span class="sd">    feasible input. If `heuristic == True`, the algorithm runs in time</span>
<span class="sd">    :math:`O(V + E)`.</span>

<span class="sd">    For a more detailed description, see [boost-max-matching]_.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    .. testcode::</span>
<span class="sd">       :hide:</span>

<span class="sd">       numpy.random.seed(43)</span>
<span class="sd">       gt.seed_rng(43)</span>

<span class="sd">    &gt;&gt;&gt; g = gt.GraphView(gt.price_network(300), directed=False)</span>
<span class="sd">    &gt;&gt;&gt; res = gt.max_cardinality_matching(g)</span>
<span class="sd">    &gt;&gt;&gt; print(res[1])</span>
<span class="sd">    True</span>
<span class="sd">    &gt;&gt;&gt; w = res[0].copy(&quot;double&quot;)</span>
<span class="sd">    &gt;&gt;&gt; w.a = 2 * w.a + 2</span>
<span class="sd">    &gt;&gt;&gt; gt.graph_draw(g, edge_color=res[0], edge_pen_width=w, vertex_fill_color=&quot;grey&quot;,</span>
<span class="sd">    ...               output=&quot;max_card_match.pdf&quot;)</span>
<span class="sd">    &lt;...&gt;</span>

<span class="sd">    .. testcode::</span>
<span class="sd">       :hide:</span>

<span class="sd">       gt.graph_draw(g, edge_color=res[0], edge_pen_width=w, vertex_fill_color=&quot;grey&quot;,</span>
<span class="sd">                     output=&quot;max_card_match.png&quot;)</span>

<span class="sd">    .. figure:: max_card_match.*</span>
<span class="sd">        :align: center</span>

<span class="sd">        Edges belonging to the matching are in yellow.</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    .. [boost-max-matching] http://www.boost.org/libs/graph/doc/maximum_matching.html</span>
<span class="sd">    .. [matching-heuristic] B. Hendrickson and R. Leland. &quot;A Multilevel Algorithm</span>
<span class="sd">       for Partitioning Graphs.&quot; In S. Karin, editor, Proc. Supercomputing ’95,</span>
<span class="sd">       San Diego. ACM Press, New York, 1995, :doi:`10.1145/224170.224228`</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">match</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">match</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">new_edge_property</span><span class="p">(</span><span class="s2">&quot;bool&quot;</span><span class="p">)</span>
    <span class="n">_check_prop_scalar</span><span class="p">(</span><span class="n">match</span><span class="p">,</span> <span class="s2">&quot;match&quot;</span><span class="p">)</span>
    <span class="n">_check_prop_writable</span><span class="p">(</span><span class="n">match</span><span class="p">,</span> <span class="s2">&quot;match&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">weight</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">_check_prop_scalar</span><span class="p">(</span><span class="n">weight</span><span class="p">,</span> <span class="s2">&quot;weight&quot;</span><span class="p">)</span>

    <span class="n">u</span> <span class="o">=</span> <span class="n">GraphView</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">directed</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">heuristic</span><span class="p">:</span>
        <span class="n">check</span> <span class="o">=</span> <span class="n">libgraph_tool_flow</span><span class="o">.</span>\
                <span class="n">max_cardinality_matching</span><span class="p">(</span><span class="n">u</span><span class="o">.</span><span class="n">_Graph__graph</span><span class="p">,</span> <span class="n">_prop</span><span class="p">(</span><span class="s2">&quot;e&quot;</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">match</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">match</span><span class="p">,</span> <span class="n">check</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">libgraph_tool_topology</span><span class="o">.</span>\
                <span class="n">random_matching</span><span class="p">(</span><span class="n">u</span><span class="o">.</span><span class="n">_Graph__graph</span><span class="p">,</span> <span class="n">_prop</span><span class="p">(</span><span class="s2">&quot;e&quot;</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">weight</span><span class="p">),</span>
                                 <span class="n">_prop</span><span class="p">(</span><span class="s2">&quot;e&quot;</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">match</span><span class="p">),</span> <span class="n">minimize</span><span class="p">,</span> <span class="n">_get_rng</span><span class="p">())</span>
        <span class="k">return</span> <span class="n">match</span></div>


<div class="viewcode-block" id="max_independent_vertex_set"><a class="viewcode-back" href="../../../../doc/topology.html#graph_tool.topology.max_independent_vertex_set">[docs]</a><span class="k">def</span> <span class="nf">max_independent_vertex_set</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">high_deg</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">mivs</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;Find a maximal independent vertex set in the graph.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    g : :class:`~graph_tool.Graph`</span>
<span class="sd">        Graph to be used.</span>
<span class="sd">    high_deg : bool (optional, default: `False`)</span>
<span class="sd">        If `True`, vertices with high degree will be included first in the set,</span>
<span class="sd">        otherwise they will be included last.</span>
<span class="sd">    mivs : :class:`~graph_tool.PropertyMap` (optional, default: `None`)</span>
<span class="sd">        Vertex property map where the vertex set will be specified.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    mivs : :class:`~graph_tool.PropertyMap`</span>
<span class="sd">        Boolean vertex property map where the set is specified.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    A maximal independent vertex set is an independent set such that adding any</span>
<span class="sd">    other vertex to the set forces the set to contain an edge between two</span>
<span class="sd">    vertices of the set.</span>

<span class="sd">    This implements the algorithm described in [mivs-luby]_, which runs in time</span>
<span class="sd">    :math:`O(V + E)`.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    .. testcode::</span>
<span class="sd">       :hide:</span>

<span class="sd">       numpy.random.seed(43)</span>
<span class="sd">       gt.seed_rng(43)</span>

<span class="sd">    &gt;&gt;&gt; g = gt.GraphView(gt.price_network(300), directed=False)</span>
<span class="sd">    &gt;&gt;&gt; res = gt.max_independent_vertex_set(g)</span>
<span class="sd">    &gt;&gt;&gt; gt.graph_draw(g, vertex_fill_color=res, output=&quot;mivs.pdf&quot;)</span>
<span class="sd">    &lt;...&gt;</span>

<span class="sd">    .. testcode::</span>
<span class="sd">       :hide:</span>

<span class="sd">       gt.graph_draw(g, vertex_fill_color=res, output=&quot;mivs.png&quot;)</span>

<span class="sd">    .. figure:: mivs.*</span>
<span class="sd">        :align: center</span>

<span class="sd">        Vertices belonging to the set are in yellow.</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    .. [mivs-wikipedia] http://en.wikipedia.org/wiki/Independent_set_%28graph_theory%29</span>
<span class="sd">    .. [mivs-luby] Luby, M., &quot;A simple parallel algorithm for the maximal independent set problem&quot;,</span>
<span class="sd">       Proc. 17th Symposium on Theory of Computing, Association for Computing Machinery, pp. 1-10, (1985)</span>
<span class="sd">       :doi:`10.1145/22145.22146`.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">mivs</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">mivs</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">new_vertex_property</span><span class="p">(</span><span class="s2">&quot;bool&quot;</span><span class="p">)</span>
    <span class="n">_check_prop_scalar</span><span class="p">(</span><span class="n">mivs</span><span class="p">,</span> <span class="s2">&quot;mivs&quot;</span><span class="p">)</span>
    <span class="n">_check_prop_writable</span><span class="p">(</span><span class="n">mivs</span><span class="p">,</span> <span class="s2">&quot;mivs&quot;</span><span class="p">)</span>

    <span class="n">u</span> <span class="o">=</span> <span class="n">GraphView</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">directed</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    <span class="n">libgraph_tool_topology</span><span class="o">.</span>\
        <span class="n">maximal_vertex_set</span><span class="p">(</span><span class="n">u</span><span class="o">.</span><span class="n">_Graph__graph</span><span class="p">,</span> <span class="n">_prop</span><span class="p">(</span><span class="s2">&quot;v&quot;</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">mivs</span><span class="p">),</span> <span class="n">high_deg</span><span class="p">,</span>
                           <span class="n">_get_rng</span><span class="p">())</span>
    <span class="n">mivs</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">own_property</span><span class="p">(</span><span class="n">mivs</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">mivs</span></div>


<div class="viewcode-block" id="edge_reciprocity"><a class="viewcode-back" href="../../../../doc/topology.html#graph_tool.topology.edge_reciprocity">[docs]</a><span class="k">def</span> <span class="nf">edge_reciprocity</span><span class="p">(</span><span class="n">g</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;Calculate the edge reciprocity of the graph.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    g : :class:`~graph_tool.Graph`</span>
<span class="sd">        Graph to be used</span>
<span class="sd">        edges.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    reciprocity : float</span>
<span class="sd">        The reciprocity value.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>

<span class="sd">    The edge [reciprocity]_ is defined as :math:`E^\leftrightarrow/E`, where</span>
<span class="sd">    :math:`E^\leftrightarrow` and :math:`E` are the number of bidirectional and</span>
<span class="sd">    all edges in the graph, respectively.</span>

<span class="sd">    The algorithm runs with complexity :math:`O(E + V)`.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>

<span class="sd">    &gt;&gt;&gt; g = gt.Graph()</span>
<span class="sd">    &gt;&gt;&gt; g.add_vertex(2)</span>
<span class="sd">    &lt;...&gt;</span>
<span class="sd">    &gt;&gt;&gt; g.add_edge(g.vertex(0), g.vertex(1))</span>
<span class="sd">    &lt;...&gt;</span>
<span class="sd">    &gt;&gt;&gt; gt.edge_reciprocity(g)</span>
<span class="sd">    0.0</span>
<span class="sd">    &gt;&gt;&gt; g.add_edge(g.vertex(1), g.vertex(0))</span>
<span class="sd">    &lt;...&gt;</span>
<span class="sd">    &gt;&gt;&gt; gt.edge_reciprocity(g)</span>
<span class="sd">    1.0</span>
<span class="sd">    &gt;&gt;&gt; g = gt.collection.data[&quot;pgp-strong-2009&quot;]</span>
<span class="sd">    &gt;&gt;&gt; gt.edge_reciprocity(g)</span>
<span class="sd">    0.692196963163...</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    .. [reciprocity] S. Wasserman and K. Faust, &quot;Social Network Analysis&quot;.</span>
<span class="sd">       (Cambridge University Press, Cambridge, 1994)</span>
<span class="sd">    .. [lopez-reciprocity-2007] Gorka Zamora-López, Vinko Zlatić, Changsong Zhou, Hrvoje Štefančić, and Jürgen Kurths</span>
<span class="sd">       &quot;Reciprocity of networks with degree correlations and arbitrary degree sequences&quot;, Phys. Rev. E 77, 016106 (2008)</span>
<span class="sd">       :doi:`10.1103/PhysRevE.77.016106`, :arxiv:`0706.3372`</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">r</span> <span class="o">=</span> <span class="n">libgraph_tool_topology</span><span class="o">.</span><span class="n">reciprocity</span><span class="p">(</span><span class="n">g</span><span class="o">.</span><span class="n">_Graph__graph</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">r</span></div>


<div class="viewcode-block" id="tsp_tour"><a class="viewcode-back" href="../../../../doc/topology.html#graph_tool.topology.tsp_tour">[docs]</a><span class="k">def</span> <span class="nf">tsp_tour</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">src</span><span class="p">,</span> <span class="n">weight</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Return a traveling salesman tour of the graph, which is guaranteed to be</span>
<span class="sd">    twice as long as the optimal tour in the worst case.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    g : :class:`~graph_tool.Graph`</span>
<span class="sd">        Graph to be used. The graph must be undirected.</span>
<span class="sd">    src : :class:`~graph_tool.Vertex`</span>
<span class="sd">        The source (and target) of the tour.</span>
<span class="sd">    weight : :class:`~graph_tool.PropertyMap` (optional, default: None)</span>
<span class="sd">        Edge weights.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    tour : :class:`numpy.ndarray`</span>
<span class="sd">        List of vertex indexes corresponding to the tour.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    The algorithm runs with :math:`O(E\log V)` complexity.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; g = gt.lattice([10, 10])</span>
<span class="sd">    &gt;&gt;&gt; tour = gt.tsp_tour(g, g.vertex(0))</span>
<span class="sd">    &gt;&gt;&gt; print(tour)</span>
<span class="sd">    [ 0  1  2 11 12 21 22 31 32 41 42 51 52 61 62 71 72 81 82 83 73 63 53 43</span>
<span class="sd">     33 23 13  3  4  5  6  7  8  9 19 29 39 49 59 69 79 89 14 24 34 44 54 64</span>
<span class="sd">     74 84 91 92 93 94 95 85 75 65 55 45 35 25 15 16 17 18 27 28 37 38 47 48</span>
<span class="sd">     57 58 67 68 77 78 87 88 97 98 99 26 36 46 56 66 76 86 96 10 20 30 40 50</span>
<span class="sd">     60 70 80 90  0]</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    .. [tsp-bgl] http://www.boost.org/libs/graph/doc/metric_tsp_approx.html</span>
<span class="sd">    .. [tsp] http://en.wikipedia.org/wiki/Travelling_salesman_problem</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="n">g</span><span class="o">.</span><span class="n">is_directed</span><span class="p">():</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;The graph must be undirected.&quot;</span><span class="p">)</span>
    <span class="n">tour</span> <span class="o">=</span> <span class="n">libgraph_tool_topology</span><span class="o">.</span>\
        <span class="n">get_tsp</span><span class="p">(</span><span class="n">g</span><span class="o">.</span><span class="n">_Graph__graph</span><span class="p">,</span> <span class="nb">int</span><span class="p">(</span><span class="n">src</span><span class="p">),</span> <span class="n">_prop</span><span class="p">(</span><span class="s2">&quot;e&quot;</span><span class="p">,</span> <span class="n">g</span><span class="p">,</span> <span class="n">weight</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">tour</span><span class="o">.</span><span class="n">a</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span></div>


<div class="viewcode-block" id="sequential_vertex_coloring"><a class="viewcode-back" href="../../../../doc/topology.html#graph_tool.topology.sequential_vertex_coloring">[docs]</a><span class="k">def</span> <span class="nf">sequential_vertex_coloring</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Returns a vertex coloring of the graph.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    g : :class:`~graph_tool.Graph`</span>
<span class="sd">        Graph to be used.</span>
<span class="sd">    order : :class:`~graph_tool.PropertyMap` (optional, default: None)</span>
<span class="sd">        Order with which the vertices will be colored.</span>
<span class="sd">    color : :class:`~graph_tool.PropertyMap` (optional, default: None)</span>
<span class="sd">        Integer-valued vertex property map to store the colors.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    color : :class:`~graph_tool.PropertyMap`</span>
<span class="sd">        Integer-valued vertex property map with the vertex colors.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    The time complexity is :math:`O(V(d+k))`, where :math:`V` is the number of</span>
<span class="sd">    vertices, :math:`d` is the maximum degree of the vertices in the graph, and</span>
<span class="sd">    :math:`k` is the number of colors used.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; g = gt.lattice([10, 10])</span>
<span class="sd">    &gt;&gt;&gt; colors = gt.sequential_vertex_coloring(g)</span>
<span class="sd">    &gt;&gt;&gt; print(colors.a)</span>
<span class="sd">    [0 1 0 1 0 1 0 1 0 1 1 0 1 0 1 0 1 0 1 0 0 1 0 1 0 1 0 1 0 1 1 0 1 0 1 0 1</span>
<span class="sd">     0 1 0 0 1 0 1 0 1 0 1 0 1 1 0 1 0 1 0 1 0 1 0 0 1 0 1 0 1 0 1 0 1 1 0 1 0</span>
<span class="sd">     1 0 1 0 1 0 0 1 0 1 0 1 0 1 0 1 1 0 1 0 1 0 1 0 1 0]</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    .. [sgc-bgl] http://www.boost.org/libs/graph/doc/sequential_vertex_coloring.html</span>
<span class="sd">    .. [graph-coloring] http://en.wikipedia.org/wiki/Graph_coloring</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="n">order</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">order</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">vertex_index</span>
    <span class="k">if</span> <span class="n">color</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">color</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">new_vertex_property</span><span class="p">(</span><span class="s2">&quot;int&quot;</span><span class="p">)</span>

    <span class="n">libgraph_tool_topology</span><span class="o">.</span>\
        <span class="n">sequential_coloring</span><span class="p">(</span><span class="n">g</span><span class="o">.</span><span class="n">_Graph__graph</span><span class="p">,</span>
                            <span class="n">_prop</span><span class="p">(</span><span class="s2">&quot;v&quot;</span><span class="p">,</span> <span class="n">g</span><span class="p">,</span> <span class="n">order</span><span class="p">),</span>
                            <span class="n">_prop</span><span class="p">(</span><span class="s2">&quot;v&quot;</span><span class="p">,</span> <span class="n">g</span><span class="p">,</span> <span class="n">color</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">color</span></div>


<span class="kn">from</span> <span class="nn">..</span> <span class="n">flow</span> <span class="kn">import</span> <span class="nn">libgraph_tool_flow</span>
</pre></div>

          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="https://graph-tool.skewed.de/static/doc/search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    </div>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="https://graph-tool.skewed.de/static/doc/genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="https://graph-tool.skewed.de/static/doc/py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
    <li><img src="../../../../img/graph-icon.png" alt="logo" style="margin-right: 5px; margin-bottom:-2px;" /><a href="https://graph-tool.skewed.de/">Project Homepage</a> &raquo;</li>
    
        <li class="nav-item nav-item-0"><a href="../../../../doc">graph-tool 2.27 documentation</a> &#187;</li>

          <li class="nav-item nav-item-1"><a href="../index.html" >Module code</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="../graph_tool.html" >graph_tool</a> &#187;</li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright 2018, Tiago de Paula Peixoto &lt;tiago@skewed.de&gt;.
      Last updated on Jun 28, 2018.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.7.5.
    </div>
  </body>
</html>