
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="X-UA-Compatible" content="IE=Edge" />
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>graph_tool &#8212; graph-tool 2.27 documentation</title>
    <link rel="stylesheet" href="https://graph-tool.skewed.de/static/doc/_static/gt_style.css" type="text/css" />
    <link rel="stylesheet" href="https://graph-tool.skewed.de/static/doc/_static/pygments.css" type="text/css" />
    <script type="text/javascript" id="documentation_options" data-url_root="../" src="https://graph-tool.skewed.de/static/doc/_static/documentation_options.js"></script>
    <script type="text/javascript" src="https://graph-tool.skewed.de/static/doc/_static/jquery.js"></script>
    <script type="text/javascript" src="https://graph-tool.skewed.de/static/doc/_static/underscore.js"></script>
    <script type="text/javascript" src="https://graph-tool.skewed.de/static/doc/_static/doctools.js"></script>
    <script type="text/javascript" src="https://graph-tool.skewed.de/static/doc/_static/MathJax/MathJax.js?config=default"></script>
    <link rel="search" type="application/opensearchdescription+xml"
          title="Search within graph-tool 2.27 documentation"
          href="https://graph-tool.skewed.de/static/doc/_static/opensearch.xml"/>
    <link rel="shortcut icon" href="https://graph-tool.skewed.de/static/doc/_static/graph-icon.ico"/>
    <link rel="index" title="Index" href="https://graph-tool.skewed.de/static/doc/genindex.html" />
    <link rel="search" title="Search" href="https://graph-tool.skewed.de/static/doc/search.html" />
    <script type="text/javascript">
      var _gaq = _gaq || [];
      var pluginUrl =
        '//www.google-analytics.com/plugins/ga/inpage_linkid.js';
      _gaq.push(['_require', 'inpage_linkid', pluginUrl]);
      _gaq.push(['_setAccount', 'UA-248813-2']);
      _gaq.push(['_setDomainName', '.skewed.de']);
      _gaq.push(['_trackPageview']);
      (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
      })();
    </script>
     

  </head><body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="https://graph-tool.skewed.de/static/doc/genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="https://graph-tool.skewed.de/static/doc/py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
    <li><img src="../../../img/graph-icon.png" alt="logo" style="margin-right: 5px; margin-bottom:-2px;" /><a href="https://graph-tool.skewed.de/">Project Homepage</a> &raquo;</li>
    
        <li class="nav-item nav-item-0"><a href="../../../doc">graph-tool 2.27 documentation</a> &#187;</li>

          <li class="nav-item nav-item-1"><a href="index.html" accesskey="U">Module code</a> &#187;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <h1>Source code for graph_tool</h1><div class="highlight"><pre>
<span></span><span class="ch">#! /usr/bin/env python</span>
<span class="c1"># -*- coding: utf-8 -*-</span>
<span class="c1">#</span>
<span class="c1"># graph_tool -- a general graph manipulation python module</span>
<span class="c1">#</span>
<span class="c1"># Copyright (C) 2006-2018 Tiago de Paula Peixoto &lt;tiago@skewed.de&gt;</span>
<span class="c1">#</span>
<span class="c1"># This program is free software: you can redistribute it and/or modify</span>
<span class="c1"># it under the terms of the GNU General Public License as published by</span>
<span class="c1"># the Free Software Foundation, either version 3 of the License, or</span>
<span class="c1"># (at your option) any later version.</span>
<span class="c1">#</span>
<span class="c1"># This program is distributed in the hope that it will be useful,</span>
<span class="c1"># but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="c1"># MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
<span class="c1"># GNU General Public License for more details.</span>
<span class="c1">#</span>
<span class="c1"># You should have received a copy of the GNU General Public License</span>
<span class="c1"># along with this program.  If not, see &lt;http://www.gnu.org/licenses/&gt;.</span>

<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">graph_tool - efficient graph analysis and manipulation</span>
<span class="sd">======================================================</span>

<span class="sd">Summary</span>
<span class="sd">-------</span>

<span class="sd">.. autosummary::</span>
<span class="sd">   :nosignatures:</span>

<span class="sd">   Graph</span>
<span class="sd">   GraphView</span>
<span class="sd">   Vertex</span>
<span class="sd">   Edge</span>
<span class="sd">   PropertyMap</span>
<span class="sd">   PropertyArray</span>
<span class="sd">   load_graph</span>
<span class="sd">   load_graph_from_csv</span>
<span class="sd">   group_vector_property</span>
<span class="sd">   ungroup_vector_property</span>
<span class="sd">   map_property_values</span>
<span class="sd">   infect_vertex_property</span>
<span class="sd">   edge_endpoint_property</span>
<span class="sd">   incident_edges_op</span>
<span class="sd">   perfect_prop_hash</span>
<span class="sd">   value_types</span>
<span class="sd">   openmp_enabled</span>
<span class="sd">   openmp_get_num_threads</span>
<span class="sd">   openmp_set_num_threads</span>
<span class="sd">   openmp_get_schedule</span>
<span class="sd">   openmp_set_schedule</span>
<span class="sd">   show_config</span>


<span class="sd">This module provides:</span>

<span class="sd">   1. A :class:`~graph_tool.Graph` class for graph representation and manipulation</span>
<span class="sd">   2. Property maps for Vertex, Edge or Graph.</span>
<span class="sd">   3. Fast algorithms implemented in C++.</span>

<span class="sd">How to use the documentation</span>
<span class="sd">----------------------------</span>

<span class="sd">Documentation is available in two forms: docstrings provided</span>
<span class="sd">with the code, and the full documentation available in</span>
<span class="sd">`the graph-tool homepage &lt;http://graph-tool.skewed.de&gt;`_.</span>

<span class="sd">We recommend exploring the docstrings using `IPython</span>
<span class="sd">&lt;http://ipython.scipy.org&gt;`_, an advanced Python shell with TAB-completion and</span>
<span class="sd">introspection capabilities.</span>

<span class="sd">The docstring examples assume that ``graph_tool.all`` has been imported as</span>
<span class="sd">``gt``::</span>

<span class="sd">   &gt;&gt;&gt; import graph_tool.all as gt</span>

<span class="sd">Code snippets are indicated by three greater-than signs::</span>

<span class="sd">   &gt;&gt;&gt; x = x + 1</span>

<span class="sd">Use the built-in ``help`` function to view a function&#39;s docstring::</span>

<span class="sd">   &gt;&gt;&gt; help(gt.Graph)</span>

<span class="sd">Contents</span>
<span class="sd">--------</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">from</span> <span class="nn">__future__</span> <span class="k">import</span> <span class="n">division</span><span class="p">,</span> <span class="n">absolute_import</span><span class="p">,</span> <span class="n">print_function</span>
<span class="kn">import</span> <span class="nn">sys</span>
<span class="k">if</span> <span class="n">sys</span><span class="o">.</span><span class="n">version_info</span> <span class="o">&lt;</span> <span class="p">(</span><span class="mi">3</span><span class="p">,):</span>
    <span class="nb">range</span> <span class="o">=</span> <span class="n">xrange</span>
<span class="k">else</span><span class="p">:</span>
    <span class="n">unicode</span> <span class="o">=</span> <span class="nb">str</span>

<span class="n">__author__</span> <span class="o">=</span> <span class="s2">&quot;Tiago de Paula Peixoto &lt;tiago@skewed.de&gt;&quot;</span>
<span class="n">__copyright__</span> <span class="o">=</span> <span class="s2">&quot;Copyright 2006-2018 Tiago de Paula Peixoto&quot;</span>
<span class="n">__license__</span> <span class="o">=</span> <span class="s2">&quot;GPL version 3 or above&quot;</span>
<span class="n">__URL__</span> <span class="o">=</span> <span class="s2">&quot;http://graph-tool.skewed.de&quot;</span>

<span class="c1"># import numpy and scipy before everything to avoid weird segmentation faults</span>
<span class="c1"># depending on the order things are imported.</span>

<span class="kn">import</span> <span class="nn">numpy</span>
<span class="kn">import</span> <span class="nn">numpy.ma</span>
<span class="kn">import</span> <span class="nn">scipy</span>
<span class="kn">import</span> <span class="nn">scipy.stats</span>


<span class="kn">from</span> <span class="nn">.dl_import</span> <span class="k">import</span> <span class="o">*</span>
<span class="n">dl_import</span><span class="p">(</span><span class="s2">&quot;from . import libgraph_tool_core as libcore&quot;</span><span class="p">)</span>
<span class="n">__version__</span> <span class="o">=</span> <span class="n">libcore</span><span class="o">.</span><span class="n">mod_info</span><span class="p">()</span><span class="o">.</span><span class="n">version</span>

<span class="kn">from</span> <span class="nn">.</span> <span class="k">import</span> <span class="n">gt_io</span>  <span class="c1"># sets up libcore io routines</span>

<span class="kn">import</span> <span class="nn">sys</span>
<span class="kn">import</span> <span class="nn">os</span>
<span class="kn">import</span> <span class="nn">re</span>
<span class="kn">import</span> <span class="nn">gzip</span>
<span class="kn">import</span> <span class="nn">bz2</span>
<span class="k">try</span><span class="p">:</span>
    <span class="kn">import</span> <span class="nn">lzma</span>
<span class="k">except</span> <span class="ne">ImportError</span><span class="p">:</span>
    <span class="k">pass</span>
<span class="kn">import</span> <span class="nn">weakref</span>
<span class="kn">import</span> <span class="nn">copy</span>
<span class="kn">import</span> <span class="nn">textwrap</span>
<span class="kn">import</span> <span class="nn">io</span>
<span class="kn">import</span> <span class="nn">collections</span>
<span class="kn">import</span> <span class="nn">itertools</span>
<span class="kn">import</span> <span class="nn">csv</span>

<span class="k">if</span> <span class="n">sys</span><span class="o">.</span><span class="n">version_info</span> <span class="o">&lt;</span> <span class="p">(</span><span class="mi">3</span><span class="p">,):</span>
    <span class="kn">import</span> <span class="nn">StringIO</span>
    <span class="k">def</span> <span class="nf">_to_str</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">unicode</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">x</span><span class="o">.</span><span class="n">encode</span><span class="p">(</span><span class="s2">&quot;utf8&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">x</span>
<span class="k">else</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">_to_str</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">x</span>

<span class="kn">from</span> <span class="nn">.decorators</span> <span class="k">import</span> <span class="n">_wraps</span><span class="p">,</span> <span class="n">_require</span><span class="p">,</span> <span class="n">_attrs</span><span class="p">,</span> <span class="n">_limit_args</span><span class="p">,</span> <span class="n">_copy_func</span>
<span class="kn">from</span> <span class="nn">inspect</span> <span class="k">import</span> <span class="n">ismethod</span>

<span class="n">__all__</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;Graph&quot;</span><span class="p">,</span> <span class="s2">&quot;GraphView&quot;</span><span class="p">,</span> <span class="s2">&quot;Vertex&quot;</span><span class="p">,</span> <span class="s2">&quot;Edge&quot;</span><span class="p">,</span> <span class="s2">&quot;VertexBase&quot;</span><span class="p">,</span> <span class="s2">&quot;EdgeBase&quot;</span><span class="p">,</span>
           <span class="s2">&quot;Vector_bool&quot;</span><span class="p">,</span> <span class="s2">&quot;Vector_int16_t&quot;</span><span class="p">,</span> <span class="s2">&quot;Vector_int32_t&quot;</span><span class="p">,</span> <span class="s2">&quot;Vector_int64_t&quot;</span><span class="p">,</span>
           <span class="s2">&quot;Vector_double&quot;</span><span class="p">,</span> <span class="s2">&quot;Vector_long_double&quot;</span><span class="p">,</span> <span class="s2">&quot;Vector_string&quot;</span><span class="p">,</span>
           <span class="s2">&quot;Vector_size_t&quot;</span><span class="p">,</span> <span class="s2">&quot;value_types&quot;</span><span class="p">,</span> <span class="s2">&quot;load_graph&quot;</span><span class="p">,</span> <span class="s2">&quot;load_graph_from_csv&quot;</span><span class="p">,</span>
           <span class="s2">&quot;PropertyMap&quot;</span><span class="p">,</span> <span class="s2">&quot;PropertyArray&quot;</span><span class="p">,</span> <span class="s2">&quot;group_vector_property&quot;</span><span class="p">,</span>
           <span class="s2">&quot;ungroup_vector_property&quot;</span><span class="p">,</span> <span class="s2">&quot;map_property_values&quot;</span><span class="p">,</span>
           <span class="s2">&quot;infect_vertex_property&quot;</span><span class="p">,</span> <span class="s2">&quot;edge_endpoint_property&quot;</span><span class="p">,</span>
           <span class="s2">&quot;incident_edges_op&quot;</span><span class="p">,</span> <span class="s2">&quot;perfect_prop_hash&quot;</span><span class="p">,</span> <span class="s2">&quot;seed_rng&quot;</span><span class="p">,</span> <span class="s2">&quot;show_config&quot;</span><span class="p">,</span>
           <span class="s2">&quot;openmp_enabled&quot;</span><span class="p">,</span> <span class="s2">&quot;openmp_get_num_threads&quot;</span><span class="p">,</span> <span class="s2">&quot;openmp_set_num_threads&quot;</span><span class="p">,</span>
           <span class="s2">&quot;openmp_get_schedule&quot;</span><span class="p">,</span> <span class="s2">&quot;openmp_set_schedule&quot;</span><span class="p">,</span> <span class="s2">&quot;__author__&quot;</span><span class="p">,</span>
           <span class="s2">&quot;__copyright__&quot;</span><span class="p">,</span> <span class="s2">&quot;__URL__&quot;</span><span class="p">,</span> <span class="s2">&quot;__version__&quot;</span><span class="p">]</span>

<span class="c1"># this is rather pointless, but it works around a sphinx bug</span>
<span class="n">graph_tool</span> <span class="o">=</span> <span class="n">sys</span><span class="o">.</span><span class="n">modules</span><span class="p">[</span><span class="vm">__name__</span><span class="p">]</span>

<span class="c1">################################################################################</span>
<span class="c1"># Utility functions</span>
<span class="c1">################################################################################</span>


<span class="k">def</span> <span class="nf">_prop</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">g</span><span class="p">,</span> <span class="n">prop</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Return either a property map, or an internal property map with a given</span>
<span class="sd">    name.&quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">prop</span><span class="p">,</span> <span class="p">(</span><span class="nb">str</span><span class="p">,</span> <span class="n">unicode</span><span class="p">)):</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">pmap</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">properties</span><span class="p">[(</span><span class="n">t</span><span class="p">,</span> <span class="n">prop</span><span class="p">)]</span>
        <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span><span class="s2">&quot;no internal </span><span class="si">%s</span><span class="s2"> property named: </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span>\
                           <span class="p">(</span><span class="s2">&quot;vertex&quot;</span> <span class="k">if</span> <span class="n">t</span> <span class="o">==</span> <span class="s2">&quot;v&quot;</span> <span class="k">else</span> \
                            <span class="p">(</span><span class="s2">&quot;edge&quot;</span> <span class="k">if</span> <span class="n">t</span> <span class="o">==</span> <span class="s2">&quot;e&quot;</span> <span class="k">else</span> <span class="s2">&quot;graph&quot;</span><span class="p">),</span> <span class="n">prop</span><span class="p">))</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">pmap</span> <span class="o">=</span> <span class="n">prop</span>
    <span class="k">if</span> <span class="n">pmap</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">libcore</span><span class="o">.</span><span class="n">any</span><span class="p">()</span>
    <span class="k">if</span> <span class="n">t</span> <span class="o">!=</span> <span class="n">prop</span><span class="o">.</span><span class="n">key_type</span><span class="p">():</span>
        <span class="n">names</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;e&#39;</span><span class="p">:</span> <span class="s1">&#39;edge&#39;</span><span class="p">,</span> <span class="s1">&#39;v&#39;</span><span class="p">:</span> <span class="s1">&#39;vertex&#39;</span><span class="p">,</span> <span class="s1">&#39;g&#39;</span><span class="p">:</span> <span class="s1">&#39;graph&#39;</span><span class="p">}</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Expected &#39;</span><span class="si">%s</span><span class="s2">&#39; property map, got &#39;</span><span class="si">%s</span><span class="s2">&#39;&quot;</span> <span class="o">%</span>
                         <span class="p">(</span><span class="n">names</span><span class="p">[</span><span class="n">t</span><span class="p">],</span> <span class="n">names</span><span class="p">[</span><span class="n">prop</span><span class="o">.</span><span class="n">key_type</span><span class="p">()]))</span>
    <span class="n">u</span> <span class="o">=</span> <span class="n">pmap</span><span class="o">.</span><span class="n">get_graph</span><span class="p">()</span>
    <span class="k">if</span> <span class="n">u</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Received orphaned property map&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">g</span><span class="o">.</span><span class="n">base</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">u</span><span class="o">.</span><span class="n">base</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Received property map for graph </span><span class="si">%s</span><span class="s2"> (base: </span><span class="si">%s</span><span class="s2">), expected: </span><span class="si">%s</span><span class="s2"> (base: </span><span class="si">%s</span><span class="s2">)&quot;</span> <span class="o">%</span>
                         <span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">g</span><span class="p">),</span> <span class="nb">str</span><span class="p">(</span><span class="n">g</span><span class="o">.</span><span class="n">base</span><span class="p">),</span> <span class="nb">str</span><span class="p">(</span><span class="n">u</span><span class="p">),</span> <span class="nb">str</span><span class="p">(</span><span class="n">u</span><span class="o">.</span><span class="n">base</span><span class="p">)))</span>
    <span class="k">return</span> <span class="n">pmap</span><span class="o">.</span><span class="n">_get_any</span><span class="p">()</span>


<span class="k">def</span> <span class="nf">_degree</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Retrieve the degree type from string, or returns the corresponding</span>
<span class="sd">    property map.&quot;&quot;&quot;</span>
    <span class="n">deg</span> <span class="o">=</span> <span class="n">name</span>
    <span class="k">if</span> <span class="n">name</span> <span class="o">==</span> <span class="s2">&quot;in-degree&quot;</span> <span class="ow">or</span> <span class="n">name</span> <span class="o">==</span> <span class="s2">&quot;in&quot;</span><span class="p">:</span>
        <span class="n">deg</span> <span class="o">=</span> <span class="n">libcore</span><span class="o">.</span><span class="n">Degree</span><span class="o">.</span><span class="n">In</span>
    <span class="k">elif</span> <span class="n">name</span> <span class="o">==</span> <span class="s2">&quot;out-degree&quot;</span> <span class="ow">or</span> <span class="n">name</span> <span class="o">==</span> <span class="s2">&quot;out&quot;</span><span class="p">:</span>
        <span class="n">deg</span> <span class="o">=</span> <span class="n">libcore</span><span class="o">.</span><span class="n">Degree</span><span class="o">.</span><span class="n">Out</span>
    <span class="k">elif</span> <span class="n">name</span> <span class="o">==</span> <span class="s2">&quot;total-degree&quot;</span> <span class="ow">or</span> <span class="n">name</span> <span class="o">==</span> <span class="s2">&quot;total&quot;</span><span class="p">:</span>
        <span class="n">deg</span> <span class="o">=</span> <span class="n">libcore</span><span class="o">.</span><span class="n">Degree</span><span class="o">.</span><span class="n">Total</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">deg</span> <span class="o">=</span> <span class="n">_prop</span><span class="p">(</span><span class="s2">&quot;v&quot;</span><span class="p">,</span> <span class="n">g</span><span class="p">,</span> <span class="n">deg</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">deg</span>


<span class="k">def</span> <span class="nf">_type_alias</span><span class="p">(</span><span class="n">type_name</span><span class="p">):</span>
    <span class="n">alias</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;int8_t&quot;</span><span class="p">:</span> <span class="s2">&quot;bool&quot;</span><span class="p">,</span>
             <span class="s2">&quot;boolean&quot;</span><span class="p">:</span> <span class="s2">&quot;bool&quot;</span><span class="p">,</span>
             <span class="s2">&quot;short&quot;</span><span class="p">:</span> <span class="s2">&quot;int16_t&quot;</span><span class="p">,</span>
             <span class="s2">&quot;int&quot;</span><span class="p">:</span> <span class="s2">&quot;int32_t&quot;</span><span class="p">,</span>
             <span class="s2">&quot;unsigned int&quot;</span><span class="p">:</span> <span class="s2">&quot;int32_t&quot;</span><span class="p">,</span>
             <span class="s2">&quot;long&quot;</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">,</span>
             <span class="s2">&quot;long long&quot;</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">,</span>
             <span class="s2">&quot;unsigned long&quot;</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">,</span>
             <span class="s2">&quot;object&quot;</span><span class="p">:</span> <span class="s2">&quot;python::object&quot;</span><span class="p">,</span>
             <span class="s2">&quot;float&quot;</span><span class="p">:</span> <span class="s2">&quot;double&quot;</span><span class="p">}</span>
    <span class="k">if</span> <span class="n">type_name</span> <span class="ow">in</span> <span class="n">alias</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">alias</span><span class="p">[</span><span class="n">type_name</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">type_name</span> <span class="ow">in</span> <span class="n">value_types</span><span class="p">():</span>
        <span class="k">return</span> <span class="n">_to_str</span><span class="p">(</span><span class="n">type_name</span><span class="p">)</span>
    <span class="n">ma</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;vector&lt;(.*)&gt;&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">type_name</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">ma</span><span class="p">:</span>
        <span class="n">t</span> <span class="o">=</span> <span class="n">ma</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">alias</span><span class="p">:</span>
            <span class="k">return</span> <span class="s2">&quot;vector&lt;</span><span class="si">%s</span><span class="s2">&gt;&quot;</span> <span class="o">%</span> <span class="n">alias</span><span class="p">[</span><span class="n">t</span><span class="p">]</span>
    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;invalid property value type: &quot;</span> <span class="o">+</span> <span class="n">type_name</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_python_type</span><span class="p">(</span><span class="n">type_name</span><span class="p">):</span>
    <span class="n">type_name</span> <span class="o">=</span> <span class="n">_type_alias</span><span class="p">(</span><span class="n">type_name</span><span class="p">)</span>
    <span class="k">if</span> <span class="s2">&quot;vector&quot;</span> <span class="ow">in</span> <span class="n">type_name</span><span class="p">:</span>
        <span class="n">ma</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;vector&lt;(.*)&gt;&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">type_name</span><span class="p">)</span>
        <span class="n">t</span> <span class="o">=</span> <span class="n">ma</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">return</span> <span class="nb">list</span><span class="p">,</span> <span class="n">_python_type</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
    <span class="k">if</span> <span class="s2">&quot;int&quot;</span> <span class="ow">in</span> <span class="n">type_name</span><span class="p">:</span>
        <span class="k">return</span> <span class="nb">int</span>
    <span class="k">if</span> <span class="n">type_name</span> <span class="o">==</span> <span class="s2">&quot;bool&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="nb">bool</span>
    <span class="k">if</span> <span class="s2">&quot;double&quot;</span> <span class="ow">in</span> <span class="n">type_name</span><span class="p">:</span>
        <span class="k">return</span> <span class="nb">float</span>
    <span class="k">if</span> <span class="n">type_name</span> <span class="o">==</span> <span class="s2">&quot;string&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="nb">str</span>
    <span class="k">return</span> <span class="nb">object</span>

<span class="k">def</span> <span class="nf">_gt_type</span><span class="p">(</span><span class="n">obj</span><span class="p">):</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">numpy</span><span class="o">.</span><span class="n">dtype</span><span class="p">):</span>
        <span class="n">t</span> <span class="o">=</span> <span class="n">obj</span><span class="o">.</span><span class="n">type</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">t</span> <span class="o">=</span> <span class="nb">type</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">issubclass</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">int16</span><span class="p">,</span> <span class="n">numpy</span><span class="o">.</span><span class="n">uint16</span><span class="p">,</span> <span class="n">numpy</span><span class="o">.</span><span class="n">int8</span><span class="p">,</span> <span class="n">numpy</span><span class="o">.</span><span class="n">uint8</span><span class="p">)):</span>
        <span class="k">return</span> <span class="s2">&quot;int16_t&quot;</span>
    <span class="k">if</span> <span class="nb">issubclass</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="n">numpy</span><span class="o">.</span><span class="n">int32</span><span class="p">,</span> <span class="n">numpy</span><span class="o">.</span><span class="n">uint32</span><span class="p">)):</span>
        <span class="k">return</span> <span class="s2">&quot;int32_t&quot;</span>
    <span class="k">if</span> <span class="nb">issubclass</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">longlong</span><span class="p">,</span> <span class="n">numpy</span><span class="o">.</span><span class="n">uint64</span><span class="p">,</span> <span class="n">numpy</span><span class="o">.</span><span class="n">int64</span><span class="p">)):</span>
        <span class="k">return</span> <span class="s2">&quot;int64_t&quot;</span>
    <span class="k">if</span> <span class="nb">issubclass</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="p">(</span><span class="nb">float</span><span class="p">,</span> <span class="n">numpy</span><span class="o">.</span><span class="n">float</span><span class="p">,</span> <span class="n">numpy</span><span class="o">.</span><span class="n">float16</span><span class="p">,</span> <span class="n">numpy</span><span class="o">.</span><span class="n">float32</span><span class="p">,</span> <span class="n">numpy</span><span class="o">.</span><span class="n">float64</span><span class="p">)):</span>
        <span class="k">return</span> <span class="s2">&quot;double&quot;</span>
    <span class="k">if</span> <span class="nb">issubclass</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">numpy</span><span class="o">.</span><span class="n">float128</span><span class="p">):</span>
        <span class="k">return</span> <span class="s2">&quot;long double&quot;</span>
    <span class="k">if</span> <span class="nb">issubclass</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="p">(</span><span class="nb">str</span><span class="p">,</span> <span class="n">unicode</span><span class="p">)):</span>
        <span class="k">return</span> <span class="s2">&quot;string&quot;</span>
    <span class="k">if</span> <span class="nb">issubclass</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="nb">bool</span><span class="p">):</span>
        <span class="k">return</span> <span class="s2">&quot;bool&quot;</span>
    <span class="k">if</span> <span class="nb">issubclass</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="n">numpy</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)):</span>
        <span class="k">return</span> <span class="s2">&quot;vector&lt;</span><span class="si">%s</span><span class="s2">&gt;&quot;</span> <span class="o">%</span> <span class="n">_gt_type</span><span class="p">(</span><span class="n">obj</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
    <span class="k">return</span> <span class="s2">&quot;object&quot;</span>

<span class="k">def</span> <span class="nf">_converter</span><span class="p">(</span><span class="n">val_type</span><span class="p">):</span>
    <span class="c1"># attempt to convert to a compatible python type. This is useful,</span>
    <span class="c1"># for instance, when dealing with numpy types.</span>
    <span class="n">vtype</span> <span class="o">=</span> <span class="n">_python_type</span><span class="p">(</span><span class="n">val_type</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">vtype</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">tuple</span><span class="p">:</span>
        <span class="k">def</span> <span class="nf">convert</span><span class="p">(</span><span class="n">val</span><span class="p">):</span>
            <span class="k">return</span> <span class="p">[</span><span class="n">vtype</span><span class="p">[</span><span class="mi">1</span><span class="p">](</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">val</span><span class="p">]</span>
    <span class="k">elif</span> <span class="n">vtype</span> <span class="ow">is</span> <span class="nb">object</span><span class="p">:</span>
        <span class="k">def</span> <span class="nf">convert</span><span class="p">(</span><span class="n">val</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">val</span>
    <span class="k">elif</span> <span class="n">vtype</span> <span class="ow">is</span> <span class="nb">str</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_c_str</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">def</span> <span class="nf">convert</span><span class="p">(</span><span class="n">val</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">vtype</span><span class="p">(</span><span class="n">val</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">convert</span>

<div class="viewcode-block" id="show_config"><a class="viewcode-back" href="https://graph-tool.skewed.de/static/doc/graph_tool.html#graph_tool.show_config">[docs]</a><span class="k">def</span> <span class="nf">show_config</span><span class="p">():</span>
    <span class="sd">&quot;&quot;&quot;Show ``graph_tool`` build configuration.&quot;&quot;&quot;</span>
    <span class="n">info</span> <span class="o">=</span> <span class="n">libcore</span><span class="o">.</span><span class="n">mod_info</span><span class="p">()</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;version:&quot;</span><span class="p">,</span> <span class="n">info</span><span class="o">.</span><span class="n">version</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;gcc version:&quot;</span><span class="p">,</span> <span class="n">info</span><span class="o">.</span><span class="n">gcc_version</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;compilation flags:&quot;</span><span class="p">,</span> <span class="n">info</span><span class="o">.</span><span class="n">cxxflags</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;install prefix:&quot;</span><span class="p">,</span> <span class="n">info</span><span class="o">.</span><span class="n">install_prefix</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;python dir:&quot;</span><span class="p">,</span> <span class="n">info</span><span class="o">.</span><span class="n">python_dir</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;graph filtering:&quot;</span><span class="p">,</span> <span class="n">libcore</span><span class="o">.</span><span class="n">graph_filtering_enabled</span><span class="p">())</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;openmp:&quot;</span><span class="p">,</span> <span class="n">libcore</span><span class="o">.</span><span class="n">openmp_enabled</span><span class="p">())</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;uname:&quot;</span><span class="p">,</span> <span class="s2">&quot; &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">uname</span><span class="p">()))</span></div>

<span class="k">def</span> <span class="nf">terminal_size</span><span class="p">():</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="kn">import</span> <span class="nn">fcntl</span><span class="o">,</span> <span class="nn">termios</span><span class="o">,</span> <span class="nn">struct</span>
        <span class="n">h</span><span class="p">,</span> <span class="n">w</span><span class="p">,</span> <span class="n">hp</span><span class="p">,</span> <span class="n">wp</span> <span class="o">=</span> <span class="n">struct</span><span class="o">.</span><span class="n">unpack</span><span class="p">(</span><span class="s1">&#39;HHHH&#39;</span><span class="p">,</span>
            <span class="n">fcntl</span><span class="o">.</span><span class="n">ioctl</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">termios</span><span class="o">.</span><span class="n">TIOCGWINSZ</span><span class="p">,</span>
            <span class="n">struct</span><span class="o">.</span><span class="n">pack</span><span class="p">(</span><span class="s1">&#39;HHHH&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)))</span>
    <span class="k">except</span> <span class="ne">IOError</span><span class="p">:</span>
        <span class="n">w</span><span class="p">,</span> <span class="n">h</span> <span class="o">=</span> <span class="mi">80</span><span class="p">,</span> <span class="mi">100</span>
    <span class="k">return</span> <span class="n">w</span><span class="p">,</span> <span class="n">h</span>

<span class="k">try</span><span class="p">:</span>
    <span class="n">libcore</span><span class="o">.</span><span class="n">mod_info</span><span class="p">(</span><span class="s2">&quot;wrong&quot;</span><span class="p">)</span>
<span class="k">except</span> <span class="ne">BaseException</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
    <span class="n">ArgumentError</span> <span class="o">=</span> <span class="nb">type</span><span class="p">(</span><span class="n">e</span><span class="p">)</span>

<span class="c1"># Python 2 vs 3 compatibility</span>

<span class="k">if</span> <span class="n">sys</span><span class="o">.</span><span class="n">version_info</span> <span class="o">&lt;</span> <span class="p">(</span><span class="mi">3</span><span class="p">,):</span>
    <span class="k">def</span> <span class="nf">_c_str</span><span class="p">(</span><span class="n">s</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">unicode</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">s</span><span class="o">.</span><span class="n">encode</span><span class="p">(</span><span class="s2">&quot;utf-8&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="nb">str</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">_str_decode</span><span class="p">(</span><span class="n">s</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">s</span>
<span class="k">else</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">_c_str</span><span class="p">(</span><span class="n">s</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">str</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">_str_decode</span><span class="p">(</span><span class="n">s</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="nb">bytes</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">s</span><span class="o">.</span><span class="n">decode</span><span class="p">(</span><span class="s2">&quot;utf-8&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">s</span>

<span class="k">def</span> <span class="nf">get_bytes_io</span><span class="p">(</span><span class="n">buf</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;We want BytesIO for python 3, but StringIO for python 2.&quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">sys</span><span class="o">.</span><span class="n">version_info</span> <span class="o">&lt;</span> <span class="p">(</span><span class="mi">3</span><span class="p">,):</span>
        <span class="k">return</span> <span class="n">StringIO</span><span class="o">.</span><span class="n">StringIO</span><span class="p">(</span><span class="n">buf</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">io</span><span class="o">.</span><span class="n">BytesIO</span><span class="p">(</span><span class="n">buf</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">conv_pickle_state</span><span class="p">(</span><span class="n">state</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;State keys may be of type `bytes` if python 3 is being used, but state was</span>
<span class="sd">    pickled with python 2.&quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="n">sys</span><span class="o">.</span><span class="n">version_info</span> <span class="o">&gt;=</span> <span class="p">(</span><span class="mi">3</span><span class="p">,):</span>
        <span class="n">keys</span> <span class="o">=</span> <span class="p">[</span><span class="n">k</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">state</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span> <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">k</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">bytes</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">keys</span><span class="p">:</span>
            <span class="n">state</span><span class="p">[</span><span class="n">k</span><span class="o">.</span><span class="n">decode</span><span class="p">(</span><span class="s2">&quot;utf-8&quot;</span><span class="p">)]</span> <span class="o">=</span> <span class="n">state</span><span class="p">[</span><span class="n">k</span><span class="p">]</span>
            <span class="k">del</span> <span class="n">state</span><span class="p">[</span><span class="n">k</span><span class="p">]</span>


<span class="c1">################################################################################</span>
<span class="c1"># Property Maps</span>
<span class="c1">################################################################################</span>

<div class="viewcode-block" id="PropertyMap"><a class="viewcode-back" href="https://graph-tool.skewed.de/static/doc/graph_tool.html#graph_tool.PropertyMap">[docs]</a><span class="k">class</span> <span class="nc">PropertyMap</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;This class provides a mapping from vertices, edges or whole graphs to</span>
<span class="sd">    arbitrary properties.</span>

<span class="sd">    See :ref:`sec_property_maps` for more details.</span>

<span class="sd">    The possible property value types are listed below.</span>

<span class="sd">    .. table::</span>

<span class="sd">        =======================     ======================</span>
<span class="sd">         Type name                  Alias</span>
<span class="sd">        =======================     ======================</span>
<span class="sd">        ``bool``                    ``uint8_t``</span>
<span class="sd">        ``int16_t``                 ``short``</span>
<span class="sd">        ``int32_t``                 ``int``</span>
<span class="sd">        ``int64_t``                 ``long``, ``long long``</span>
<span class="sd">        ``double``                  ``float``</span>
<span class="sd">        ``long double``</span>
<span class="sd">        ``string``</span>
<span class="sd">        ``vector&lt;bool&gt;``            ``vector&lt;uint8_t&gt;``</span>
<span class="sd">        ``vector&lt;int16_t&gt;``         ``short``</span>
<span class="sd">        ``vector&lt;int32_t&gt;``         ``vector&lt;int&gt;``</span>
<span class="sd">        ``vector&lt;int64_t&gt;``         ``vector&lt;long&gt;``, ``vector&lt;long long&gt;``</span>
<span class="sd">        ``vector&lt;double&gt;``          ``vector&lt;float&gt;``</span>
<span class="sd">        ``vector&lt;long double&gt;``</span>
<span class="sd">        ``vector&lt;string&gt;``</span>
<span class="sd">        ``python::object``          ``object``</span>
<span class="sd">        =======================     ======================</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pmap</span><span class="p">,</span> <span class="n">g</span><span class="p">,</span> <span class="n">key_type</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__map</span> <span class="o">=</span> <span class="n">pmap</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__g</span> <span class="o">=</span> <span class="n">weakref</span><span class="o">.</span><span class="n">ref</span><span class="p">(</span><span class="n">g</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__base_g</span> <span class="o">=</span> <span class="n">weakref</span><span class="o">.</span><span class="n">ref</span><span class="p">(</span><span class="n">g</span><span class="o">.</span><span class="n">base</span><span class="p">)</span>  <span class="c1"># keep reference to the</span>
                                             <span class="c1"># base graph, in case the</span>
                                             <span class="c1"># graph view is deleted.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__key_type</span> <span class="o">=</span> <span class="n">key_type</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__convert</span> <span class="o">=</span> <span class="n">_converter</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">value_type</span><span class="p">())</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__register_map</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">_get_any</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">t</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">key_type</span><span class="p">()</span>
        <span class="n">g</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_graph</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">t</span> <span class="o">==</span> <span class="s2">&quot;v&quot;</span><span class="p">:</span>
            <span class="n">N</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">num_vertices</span><span class="p">(</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">t</span> <span class="o">==</span> <span class="s2">&quot;e&quot;</span><span class="p">:</span>
            <span class="n">N</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">edge_index_range</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">N</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">reserve</span><span class="p">(</span><span class="n">N</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__map</span><span class="o">.</span><span class="n">get_map</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">__key_trans</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">key_type</span><span class="p">()</span> <span class="o">==</span> <span class="s2">&quot;g&quot;</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">key</span><span class="o">.</span><span class="n">_Graph__graph</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">key</span>

    <span class="k">def</span> <span class="nf">__key_convert</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">k</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">key_type</span><span class="p">()</span> <span class="o">==</span> <span class="s2">&quot;e&quot;</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">k</span> <span class="o">=</span> <span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">k</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="nb">int</span><span class="p">(</span><span class="n">k</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>
            <span class="k">except</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">ArgumentError</span>
            <span class="n">key</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__g</span><span class="p">()</span><span class="o">.</span><span class="n">edge</span><span class="p">(</span><span class="n">k</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">k</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
            <span class="k">if</span> <span class="n">key</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Nonexistent edge: </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="nb">str</span><span class="p">(</span><span class="n">k</span><span class="p">))</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">key_type</span><span class="p">()</span> <span class="o">==</span> <span class="s2">&quot;v&quot;</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">key</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">k</span><span class="p">)</span>
            <span class="k">except</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">ArgumentError</span>
            <span class="n">key</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__g</span><span class="p">()</span><span class="o">.</span><span class="n">vertex</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">key</span>

    <span class="k">def</span> <span class="nf">__register_map</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">g</span> <span class="ow">in</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">__g</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">__base_g</span><span class="p">()]:</span>
            <span class="k">if</span> <span class="n">g</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">g</span><span class="o">.</span><span class="n">_Graph__known_properties</span><span class="p">[</span><span class="nb">id</span><span class="p">(</span><span class="bp">self</span><span class="p">)]</span> <span class="o">=</span> <span class="n">weakref</span><span class="o">.</span><span class="n">ref</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__unregister_map</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">g</span> <span class="ow">in</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">__g</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">__base_g</span><span class="p">()]:</span>
            <span class="k">if</span> <span class="n">g</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="nb">id</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="ow">in</span> <span class="n">g</span><span class="o">.</span><span class="n">_Graph__known_properties</span><span class="p">:</span>
                <span class="k">del</span> <span class="n">g</span><span class="o">.</span><span class="n">_Graph__known_properties</span><span class="p">[</span><span class="nb">id</span><span class="p">(</span><span class="bp">self</span><span class="p">)]</span>

    <span class="k">def</span> <span class="nf">__del__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__unregister_map</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">k</span><span class="p">):</span>
        <span class="n">k</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__key_trans</span><span class="p">(</span><span class="n">k</span><span class="p">)</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__map</span><span class="p">[</span><span class="n">k</span><span class="p">]</span>
        <span class="k">except</span> <span class="n">ArgumentError</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">k</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__key_convert</span><span class="p">(</span><span class="n">k</span><span class="p">)</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__map</span><span class="p">[</span><span class="n">k</span><span class="p">]</span>
            <span class="k">except</span> <span class="n">ArgumentError</span><span class="p">:</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">key_type</span><span class="p">()</span> <span class="o">==</span> <span class="s2">&quot;e&quot;</span><span class="p">:</span>
                    <span class="n">kt</span> <span class="o">=</span> <span class="s2">&quot;Edge&quot;</span>
                <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">key_type</span><span class="p">()</span> <span class="o">==</span> <span class="s2">&quot;v&quot;</span><span class="p">:</span>
                    <span class="n">kt</span> <span class="o">=</span> <span class="s2">&quot;Vertex&quot;</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">kt</span> <span class="o">=</span> <span class="s2">&quot;Graph&quot;</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;invalid key &#39;</span><span class="si">%s</span><span class="s2">&#39; of type &#39;</span><span class="si">%s</span><span class="s2">&#39;, wanted type: </span><span class="si">%s</span><span class="s2">&quot;</span>
                                 <span class="o">%</span> <span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">k</span><span class="p">),</span> <span class="nb">str</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">k</span><span class="p">)),</span> <span class="n">kt</span><span class="p">)</span> <span class="p">)</span>

    <span class="k">def</span> <span class="nf">__setitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span><span class="p">):</span>
        <span class="n">key</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__key_trans</span><span class="p">(</span><span class="n">k</span><span class="p">)</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">__map</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">v</span>
            <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">__map</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__convert</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
        <span class="k">except</span> <span class="n">ArgumentError</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">key</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__key_convert</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">__map</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">v</span>
                <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">__map</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__convert</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
            <span class="k">except</span> <span class="n">ArgumentError</span><span class="p">:</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">key_type</span><span class="p">()</span> <span class="o">==</span> <span class="s2">&quot;e&quot;</span><span class="p">:</span>
                    <span class="n">kt</span> <span class="o">=</span> <span class="s2">&quot;Edge&quot;</span>
                <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">key_type</span><span class="p">()</span> <span class="o">==</span> <span class="s2">&quot;v&quot;</span><span class="p">:</span>
                    <span class="n">kt</span> <span class="o">=</span> <span class="s2">&quot;Vertex&quot;</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">kt</span> <span class="o">=</span> <span class="s2">&quot;Graph&quot;</span>
                <span class="n">vt</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">value_type</span><span class="p">()</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;invalid key value pair &#39;(</span><span class="si">%s</span><span class="s2">, </span><span class="si">%s</span><span class="s2">)&#39; of types &quot;</span>
                                 <span class="s2">&quot;&#39;(</span><span class="si">%s</span><span class="s2">, </span><span class="si">%s</span><span class="s2">)&#39;, wanted types: (</span><span class="si">%s</span><span class="s2">, </span><span class="si">%s</span><span class="s2">)&quot;</span> <span class="o">%</span>
                                 <span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">k</span><span class="p">),</span> <span class="nb">str</span><span class="p">(</span><span class="n">v</span><span class="p">),</span> <span class="nb">str</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">k</span><span class="p">)),</span>
                                  <span class="nb">str</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">v</span><span class="p">)),</span> <span class="n">kt</span><span class="p">,</span> <span class="n">vt</span><span class="p">))</span>
    <span class="k">def</span> <span class="nf">__iter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">g</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__g</span><span class="p">()</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">key_type</span><span class="p">()</span> <span class="o">==</span> <span class="s2">&quot;g&quot;</span><span class="p">:</span>
            <span class="n">iters</span> <span class="o">=</span> <span class="p">[</span><span class="n">g</span><span class="p">]</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">key_type</span><span class="p">()</span> <span class="o">==</span> <span class="s2">&quot;v&quot;</span><span class="p">:</span>
            <span class="n">iters</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">vertices</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">iters</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">edges</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">iters</span><span class="p">:</span>
            <span class="k">yield</span> <span class="bp">self</span><span class="p">[</span><span class="n">x</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># provide some more useful information</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">key_type</span><span class="p">()</span> <span class="o">==</span> <span class="s2">&quot;e&quot;</span><span class="p">:</span>
            <span class="n">k</span> <span class="o">=</span> <span class="s2">&quot;Edge&quot;</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">key_type</span><span class="p">()</span> <span class="o">==</span> <span class="s2">&quot;v&quot;</span><span class="p">:</span>
            <span class="n">k</span> <span class="o">=</span> <span class="s2">&quot;Vertex&quot;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">k</span> <span class="o">=</span> <span class="s2">&quot;Graph&quot;</span>
        <span class="n">g</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_graph</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">g</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">g</span> <span class="o">=</span> <span class="s2">&quot;a non-existent graph&quot;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">g</span> <span class="o">=</span> <span class="s2">&quot;Graph 0x</span><span class="si">%x</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="nb">id</span><span class="p">(</span><span class="n">g</span><span class="p">)</span>
        <span class="k">return</span> <span class="p">(</span><span class="s2">&quot;&lt;PropertyMap object with key type &#39;</span><span class="si">%s</span><span class="s2">&#39; and value type &#39;</span><span class="si">%s</span><span class="s2">&#39;,&quot;</span>
                <span class="o">+</span> <span class="s2">&quot; for </span><span class="si">%s</span><span class="s2">, at 0x</span><span class="si">%x</span><span class="s2">&gt;&quot;</span><span class="p">)</span> <span class="o">%</span> <span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">value_type</span><span class="p">(),</span> <span class="n">g</span><span class="p">,</span> <span class="nb">id</span><span class="p">(</span><span class="bp">self</span><span class="p">))</span>

<div class="viewcode-block" id="PropertyMap.copy"><a class="viewcode-back" href="https://graph-tool.skewed.de/static/doc/graph_tool.html#graph_tool.PropertyMap.copy">[docs]</a>    <span class="k">def</span> <span class="nf">copy</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value_type</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">full</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return a copy of the property map. If ``value_type`` is specified, the value</span>
<span class="sd">        type is converted to the chosen type. If ``full == False``, in the case</span>
<span class="sd">        of filtered graphs only the unmasked values are copied (with the</span>
<span class="sd">        remaining ones taking the type-dependent default value).</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_graph</span><span class="p">()</span><span class="o">.</span><span class="n">copy_property</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value_type</span><span class="o">=</span><span class="n">value_type</span><span class="p">,</span>
                                              <span class="n">full</span><span class="o">=</span><span class="n">full</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">__copy__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">__deepcopy__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">memo</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">value_type</span><span class="p">()</span> <span class="o">!=</span> <span class="s2">&quot;python::object&quot;</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">pmap</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="n">g</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_graph</span><span class="p">()</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">key_type</span><span class="p">()</span> <span class="o">==</span> <span class="s2">&quot;g&quot;</span><span class="p">:</span>
                <span class="n">iters</span> <span class="o">=</span> <span class="p">[</span><span class="n">g</span><span class="p">]</span>
            <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">key_type</span><span class="p">()</span> <span class="o">==</span> <span class="s2">&quot;v&quot;</span><span class="p">:</span>
                <span class="n">iters</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">vertices</span><span class="p">()</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">iters</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">edges</span><span class="p">()</span>
            <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">iters</span><span class="p">:</span>
                <span class="n">pmap</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="p">[</span><span class="n">v</span><span class="p">],</span> <span class="n">memo</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">pmap</span>

<div class="viewcode-block" id="PropertyMap.get_graph"><a class="viewcode-back" href="https://graph-tool.skewed.de/static/doc/graph_tool.html#graph_tool.PropertyMap.get_graph">[docs]</a>    <span class="k">def</span> <span class="nf">get_graph</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Get the graph class to which the map refers.&quot;&quot;&quot;</span>
        <span class="n">g</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__g</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">g</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">g</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__base_g</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">g</span></div>

<div class="viewcode-block" id="PropertyMap.key_type"><a class="viewcode-back" href="https://graph-tool.skewed.de/static/doc/graph_tool.html#graph_tool.PropertyMap.key_type">[docs]</a>    <span class="k">def</span> <span class="nf">key_type</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the key type of the map. Either &#39;g&#39;, &#39;v&#39; or &#39;e&#39;.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__key_type</span></div>

<div class="viewcode-block" id="PropertyMap.value_type"><a class="viewcode-back" href="https://graph-tool.skewed.de/static/doc/graph_tool.html#graph_tool.PropertyMap.value_type">[docs]</a>    <span class="k">def</span> <span class="nf">value_type</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the value type of the map.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__map</span><span class="o">.</span><span class="n">value_type</span><span class="p">()</span></div>

<div class="viewcode-block" id="PropertyMap.python_value_type"><a class="viewcode-back" href="https://graph-tool.skewed.de/static/doc/graph_tool.html#graph_tool.PropertyMap.python_value_type">[docs]</a>    <span class="k">def</span> <span class="nf">python_value_type</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the python-compatible value type of the map.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_python_type</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__map</span><span class="o">.</span><span class="n">value_type</span><span class="p">())</span></div>

<div class="viewcode-block" id="PropertyMap.get_array"><a class="viewcode-back" href="https://graph-tool.skewed.de/static/doc/graph_tool.html#graph_tool.PropertyMap.get_array">[docs]</a>    <span class="k">def</span> <span class="nf">get_array</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Get a :class:`numpy.ndarray` subclass (:class:`~graph_tool.PropertyArray`)</span>
<span class="sd">        with the property values.</span>

<span class="sd">        .. note::</span>

<span class="sd">           An array is returned *only if* the value type of the property map is</span>
<span class="sd">           a scalar. For vector, string or object types, ``None`` is returned</span>
<span class="sd">           instead. For vector and string objects, indirect array access is</span>
<span class="sd">           provided via the :func:`~graph_tool.PropertyMap.get_2d_array()` and</span>
<span class="sd">           :func:`~graph_tool.PropertyMap.set_2d_array()` member functions.</span>

<span class="sd">        .. warning::</span>

<span class="sd">           The returned array does not own the data, which belongs to the</span>
<span class="sd">           property map. Therefore, if the graph changes, the array may become</span>
<span class="sd">           *invalid*. Do **not** store the array if the graph is to be modified;</span>
<span class="sd">           store a **copy** instead.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_data</span><span class="p">()</span></div>

    <span class="k">def</span> <span class="nf">_get_data</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">g</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_graph</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">g</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Cannot get array for an orphaned property map&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">__key_type</span> <span class="o">==</span> <span class="s1">&#39;v&#39;</span><span class="p">:</span>
            <span class="n">n</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">_Graph__graph</span><span class="o">.</span><span class="n">get_num_vertices</span><span class="p">(</span><span class="kc">False</span><span class="p">)</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">__key_type</span> <span class="o">==</span> <span class="s1">&#39;e&#39;</span><span class="p">:</span>
            <span class="n">n</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">edge_index_range</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">n</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="n">a</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__map</span><span class="o">.</span><span class="n">get_array</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">a</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">a</span>
        <span class="k">return</span> <span class="n">PropertyArray</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__set_array</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">v</span><span class="p">):</span>
        <span class="n">a</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_array</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">a</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;cannot set property map values from array for&quot;</span> <span class="o">+</span>
                            <span class="s2">&quot; property map of type: &quot;</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">value_type</span><span class="p">())</span>
        <span class="n">a</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">v</span>

    <span class="n">a</span> <span class="o">=</span> <span class="nb">property</span><span class="p">(</span><span class="n">get_array</span><span class="p">,</span> <span class="n">__set_array</span><span class="p">,</span>
                 <span class="n">doc</span><span class="o">=</span><span class="sa">r</span><span class="s2">&quot;&quot;&quot;Shortcut to the :meth:`~PropertyMap.get_array` method</span>
<span class="s2">                 as an attribute. This makes assignments more convenient, e.g.:</span>

<span class="s2">                 &gt;&gt;&gt; g = gt.Graph()</span>
<span class="s2">                 &gt;&gt;&gt; g.add_vertex(10)</span>
<span class="s2">                 &lt;...&gt;</span>
<span class="s2">                 &gt;&gt;&gt; prop = g.new_vertex_property(&quot;double&quot;)</span>
<span class="s2">                 &gt;&gt;&gt; prop.a = np.random.random(10)           # Assignment from array</span>
<span class="s2">                 &quot;&quot;&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__get_set_f_array</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">v</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">get</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="n">g</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_graph</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">g</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>
        <span class="n">a</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_array</span><span class="p">()</span>
        <span class="n">filt</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">__key_type</span> <span class="o">==</span> <span class="s1">&#39;v&#39;</span><span class="p">:</span>
            <span class="n">filt</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">get_vertex_filter</span><span class="p">()</span>
            <span class="n">N</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">num_vertices</span><span class="p">()</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">__key_type</span> <span class="o">==</span> <span class="s1">&#39;e&#39;</span><span class="p">:</span>
            <span class="n">filt</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">get_edge_filter</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">g</span><span class="o">.</span><span class="n">get_vertex_filter</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">filt</span> <span class="o">=</span> <span class="p">(</span><span class="n">g</span><span class="o">.</span><span class="n">new_edge_property</span><span class="p">(</span><span class="s2">&quot;bool&quot;</span><span class="p">),</span> <span class="n">filt</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
                <span class="n">libcore</span><span class="o">.</span><span class="n">mark_edges</span><span class="p">(</span><span class="n">g</span><span class="o">.</span><span class="n">_Graph__graph</span><span class="p">,</span> <span class="n">_prop</span><span class="p">(</span><span class="s2">&quot;e&quot;</span><span class="p">,</span> <span class="n">g</span><span class="p">,</span> <span class="n">filt</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
                <span class="k">if</span> <span class="n">filt</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
                    <span class="n">filt</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">a</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">logical_not</span><span class="p">(</span><span class="n">filt</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">a</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">g</span><span class="o">.</span><span class="n">edge_index_range</span> <span class="o">!=</span> <span class="n">g</span><span class="o">.</span><span class="n">num_edges</span><span class="p">():</span>
                <span class="n">filt</span> <span class="o">=</span> <span class="p">(</span><span class="n">g</span><span class="o">.</span><span class="n">new_edge_property</span><span class="p">(</span><span class="s2">&quot;bool&quot;</span><span class="p">),</span> <span class="kc">False</span><span class="p">)</span>
                <span class="n">libcore</span><span class="o">.</span><span class="n">mark_edges</span><span class="p">(</span><span class="n">g</span><span class="o">.</span><span class="n">_Graph__graph</span><span class="p">,</span> <span class="n">_prop</span><span class="p">(</span><span class="s2">&quot;e&quot;</span><span class="p">,</span> <span class="n">g</span><span class="p">,</span> <span class="n">filt</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
            <span class="k">if</span> <span class="n">filt</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">N</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">edge_index_range</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">N</span> <span class="o">=</span> <span class="p">(</span><span class="n">filt</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">a</span> <span class="o">==</span> <span class="p">(</span><span class="ow">not</span> <span class="n">filt</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">get</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">a</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">a</span>
            <span class="k">if</span> <span class="n">filt</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">a</span>
            <span class="k">return</span> <span class="n">a</span><span class="p">[</span><span class="n">filt</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">a</span> <span class="o">==</span> <span class="p">(</span><span class="ow">not</span> <span class="n">filt</span><span class="p">[</span><span class="mi">1</span><span class="p">])][:</span><span class="n">N</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">a</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;cannot set property map values from array for&quot;</span> <span class="o">+</span>
                                <span class="s2">&quot; property map of type: &quot;</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">value_type</span><span class="p">())</span>
            <span class="k">if</span> <span class="n">filt</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">a</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">v</span>
                <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
                    <span class="n">a</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">v</span><span class="p">[:</span><span class="nb">len</span><span class="p">(</span><span class="n">a</span><span class="p">)]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">m</span> <span class="o">=</span> <span class="n">filt</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">a</span> <span class="o">==</span> <span class="p">(</span><span class="ow">not</span> <span class="n">filt</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
                <span class="n">m</span> <span class="o">*=</span> <span class="n">m</span><span class="o">.</span><span class="n">cumsum</span><span class="p">()</span> <span class="o">&lt;=</span> <span class="n">N</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">a</span><span class="p">[</span><span class="n">m</span><span class="p">]</span> <span class="o">=</span> <span class="n">v</span>
                <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
                    <span class="n">a</span><span class="p">[</span><span class="n">m</span><span class="p">]</span> <span class="o">=</span> <span class="n">v</span><span class="p">[:</span><span class="nb">len</span><span class="p">(</span><span class="n">m</span><span class="p">)][</span><span class="n">m</span><span class="p">]</span>

    <span class="n">fa</span> <span class="o">=</span> <span class="nb">property</span><span class="p">(</span><span class="n">__get_set_f_array</span><span class="p">,</span>
                  <span class="k">lambda</span> <span class="bp">self</span><span class="p">,</span> <span class="n">v</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">__get_set_f_array</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="kc">False</span><span class="p">),</span>
                  <span class="n">doc</span><span class="o">=</span><span class="sa">r</span><span class="s2">&quot;&quot;&quot;The same as the :attr:`~PropertyMap.a` attribute, but</span>
<span class="s2">                  instead an *indexed* array is returned, which contains only</span>
<span class="s2">                  entries for vertices/edges which are not filtered out. If</span>
<span class="s2">                  there are no filters in place, the array is not indexed, and</span>
<span class="s2">                  is identical to the :attr:`~PropertyMap.a` attribute.</span>

<span class="s2">                  Note that because advanced indexing is triggered, a **copy**</span>
<span class="s2">                  of the array is returned, not a view, as for the</span>
<span class="s2">                  :attr:`~PropertyMap.a` attribute. Nevertheless, the assignment</span>
<span class="s2">                  of values to the *whole* array at once works as expected.&quot;&quot;&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__get_set_m_array</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">v</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">get</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="n">g</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_graph</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">g</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>
        <span class="n">a</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_array</span><span class="p">()</span>
        <span class="n">filt</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">__key_type</span> <span class="o">==</span> <span class="s1">&#39;v&#39;</span><span class="p">:</span>
            <span class="n">filt</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">get_vertex_filter</span><span class="p">()</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">__key_type</span> <span class="o">==</span> <span class="s1">&#39;e&#39;</span><span class="p">:</span>
            <span class="n">filt</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">get_edge_filter</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">g</span><span class="o">.</span><span class="n">get_vertex_filter</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">filt</span> <span class="o">=</span> <span class="p">(</span><span class="n">g</span><span class="o">.</span><span class="n">new_edge_property</span><span class="p">(</span><span class="s2">&quot;bool&quot;</span><span class="p">),</span> <span class="n">filt</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
                <span class="n">libcore</span><span class="o">.</span><span class="n">mark_edges</span><span class="p">(</span><span class="n">g</span><span class="o">.</span><span class="n">_Graph__graph</span><span class="p">,</span> <span class="n">_prop</span><span class="p">(</span><span class="s2">&quot;e&quot;</span><span class="p">,</span> <span class="n">g</span><span class="p">,</span> <span class="n">filt</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
                <span class="k">if</span> <span class="n">filt</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
                    <span class="n">filt</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">a</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">filt</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">a</span>
        <span class="k">if</span> <span class="n">filt</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">a</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">get</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">a</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span>
        <span class="n">ma</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">mask</span><span class="o">=</span><span class="p">(</span><span class="n">filt</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">a</span> <span class="o">==</span> <span class="kc">False</span><span class="p">)</span> <span class="k">if</span> <span class="ow">not</span> <span class="n">filt</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="k">else</span> <span class="p">(</span><span class="n">filt</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">a</span> <span class="o">==</span> <span class="kc">True</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">get</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">ma</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">ma</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">v</span>

    <span class="n">ma</span> <span class="o">=</span> <span class="nb">property</span><span class="p">(</span><span class="n">__get_set_m_array</span><span class="p">,</span>
                  <span class="k">lambda</span> <span class="bp">self</span><span class="p">,</span> <span class="n">v</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">__get_set_m_array</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="kc">False</span><span class="p">),</span>
                  <span class="n">doc</span><span class="o">=</span><span class="sa">r</span><span class="s2">&quot;&quot;&quot;The same as the :attr:`~PropertyMap.a` attribute, but</span>
<span class="s2">                  instead a :class:`~numpy.ma.MaskedArray` object is returned,</span>
<span class="s2">                  which contains only entries for vertices/edges which are not</span>
<span class="s2">                  filtered out. If there are no filters in place, a regular</span>
<span class="s2">                  :class:`~graph_tool.PropertyArray` is returned, which</span>
<span class="s2">                  is identical to the :attr:`~PropertyMap.a` attribute.&quot;&quot;&quot;</span><span class="p">)</span>

<div class="viewcode-block" id="PropertyMap.get_2d_array"><a class="viewcode-back" href="https://graph-tool.skewed.de/static/doc/graph_tool.html#graph_tool.PropertyMap.get_2d_array">[docs]</a>    <span class="k">def</span> <span class="nf">get_2d_array</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pos</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;Return a two-dimensional array with a copy of the entries of the</span>
<span class="sd">        vector-valued property map. The parameter ``pos`` must be a sequence of</span>
<span class="sd">        integers which specifies the indexes of the property values which will</span>
<span class="sd">        be used. &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">key_type</span><span class="p">()</span> <span class="o">==</span> <span class="s2">&quot;g&quot;</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Cannot create multidimensional array for graph property maps.&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="s2">&quot;vector&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">value_type</span><span class="p">()</span> <span class="ow">and</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">pos</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="ow">or</span> <span class="n">pos</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Cannot create array of dimension </span><span class="si">%d</span><span class="s2"> (indexes </span><span class="si">%s</span><span class="s2">) from non-vector property map of type &#39;</span><span class="si">%s</span><span class="s2">&#39;.&quot;</span> \
                             <span class="o">%</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">pos</span><span class="p">),</span> <span class="nb">str</span><span class="p">(</span><span class="n">pos</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">value_type</span><span class="p">()))</span>
        <span class="k">if</span> <span class="s2">&quot;string&quot;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">value_type</span><span class="p">():</span>
            <span class="k">if</span> <span class="s2">&quot;vector&quot;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">value_type</span><span class="p">():</span>
                <span class="n">p</span> <span class="o">=</span> <span class="n">ungroup_vector_property</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pos</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">p</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="p">]</span>
            <span class="n">g</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_graph</span><span class="p">()</span>
            <span class="n">vfilt</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">get_vertex_filter</span><span class="p">()</span>
            <span class="n">efilt</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">get_edge_filter</span><span class="p">()</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">key_type</span><span class="p">()</span> <span class="o">==</span> <span class="s2">&quot;v&quot;</span><span class="p">:</span>
                <span class="n">iters</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">vertices</span><span class="p">()</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">iters</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">g</span><span class="o">.</span><span class="n">edge_index_range</span><span class="p">)]</span>
                <span class="n">idx</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">edge_index</span>
                <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">g</span><span class="o">.</span><span class="n">edges</span><span class="p">():</span>
                    <span class="n">iters</span><span class="p">[</span><span class="n">idx</span><span class="p">[</span><span class="n">e</span><span class="p">]]</span> <span class="o">=</span> <span class="n">e</span>
                <span class="n">iters</span> <span class="o">=</span> <span class="p">[</span><span class="n">e</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">iters</span> <span class="k">if</span> <span class="n">e</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">]</span>
            <span class="n">a</span> <span class="o">=</span> <span class="p">[[]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">p</span><span class="p">))]</span>
            <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">iters</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">p</span><span class="p">)):</span>
                    <span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">p</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">v</span><span class="p">])</span>
            <span class="n">a</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">a</span>

        <span class="n">p</span> <span class="o">=</span> <span class="n">ungroup_vector_property</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pos</span><span class="p">)</span>
        <span class="n">a</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">x</span><span class="o">.</span><span class="n">fa</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">p</span><span class="p">])</span>
        <span class="k">return</span> <span class="n">a</span></div>

<div class="viewcode-block" id="PropertyMap.set_2d_array"><a class="viewcode-back" href="https://graph-tool.skewed.de/static/doc/graph_tool.html#graph_tool.PropertyMap.set_2d_array">[docs]</a>    <span class="k">def</span> <span class="nf">set_2d_array</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">pos</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;Set the entries of the vector-valued property map from a</span>
<span class="sd">        two-dimensional array ``a``. If given, the parameter ``pos`` must be a</span>
<span class="sd">        sequence of integers which specifies the indexes of the property values</span>
<span class="sd">        which will be set.&quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">key_type</span><span class="p">()</span> <span class="o">==</span> <span class="s2">&quot;g&quot;</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Cannot set multidimensional array for graph property maps.&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="s2">&quot;vector&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">value_type</span><span class="p">():</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Cannot set array of shape </span><span class="si">%s</span><span class="s2"> to non-vector property map of type </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> \
                                 <span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">shape</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">value_type</span><span class="p">()))</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">value_type</span><span class="p">()</span> <span class="o">!=</span> <span class="s2">&quot;string&quot;</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">fa</span> <span class="o">=</span> <span class="n">a</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">g</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_graph</span><span class="p">()</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">key_type</span><span class="p">()</span> <span class="o">==</span> <span class="s2">&quot;v&quot;</span><span class="p">:</span>
                    <span class="n">iters</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">vertices</span><span class="p">()</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">iters</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">g</span><span class="o">.</span><span class="n">edge_index_range</span><span class="p">)]</span>
                    <span class="n">idx</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">edge_index</span>
                    <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">g</span><span class="o">.</span><span class="n">edges</span><span class="p">():</span>
                        <span class="n">iters</span><span class="p">[</span><span class="n">idx</span><span class="p">[</span><span class="n">e</span><span class="p">]]</span> <span class="o">=</span> <span class="n">e</span>
                    <span class="n">iters</span> <span class="o">=</span> <span class="p">[</span><span class="n">e</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">iters</span> <span class="k">if</span> <span class="n">e</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">]</span>
                <span class="k">for</span> <span class="n">j</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">iters</span><span class="p">):</span>
                    <span class="bp">self</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">=</span> <span class="n">a</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
            <span class="k">return</span>

        <span class="n">val</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">value_type</span><span class="p">()[</span><span class="mi">7</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">ps</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
            <span class="n">ps</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">get_graph</span><span class="p">()</span><span class="o">.</span><span class="n">new_property</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">key_type</span><span class="p">(),</span> <span class="n">val</span><span class="p">))</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">value_type</span><span class="p">()</span> <span class="o">!=</span> <span class="s2">&quot;string&quot;</span><span class="p">:</span>
                <span class="n">ps</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">fa</span> <span class="o">=</span> <span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">g</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_graph</span><span class="p">()</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">key_type</span><span class="p">()</span> <span class="o">==</span> <span class="s2">&quot;v&quot;</span><span class="p">:</span>
                    <span class="n">iters</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">vertices</span><span class="p">()</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">iters</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">g</span><span class="o">.</span><span class="n">edge_index_range</span><span class="p">)]</span>
                    <span class="n">idx</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">edge_index</span>
                    <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">g</span><span class="o">.</span><span class="n">edges</span><span class="p">():</span>
                        <span class="n">iters</span><span class="p">[</span><span class="n">idx</span><span class="p">[</span><span class="n">e</span><span class="p">]]</span> <span class="o">=</span> <span class="n">e</span>
                    <span class="n">iters</span> <span class="o">=</span> <span class="p">[</span><span class="n">e</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">iters</span> <span class="k">if</span> <span class="n">e</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">]</span>
                <span class="k">for</span> <span class="n">j</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">iters</span><span class="p">):</span>
                    <span class="n">ps</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="n">v</span><span class="p">]</span> <span class="o">=</span> <span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span>
        <span class="n">group_vector_property</span><span class="p">(</span><span class="n">ps</span><span class="p">,</span> <span class="n">val</span><span class="p">,</span> <span class="bp">self</span><span class="p">,</span> <span class="n">pos</span><span class="p">)</span></div>

<div class="viewcode-block" id="PropertyMap.is_writable"><a class="viewcode-back" href="https://graph-tool.skewed.de/static/doc/graph_tool.html#graph_tool.PropertyMap.is_writable">[docs]</a>    <span class="k">def</span> <span class="nf">is_writable</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return True if the property is writable.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__map</span><span class="o">.</span><span class="n">is_writable</span><span class="p">()</span></div>


<div class="viewcode-block" id="PropertyMap.set_value"><a class="viewcode-back" href="https://graph-tool.skewed.de/static/doc/graph_tool.html#graph_tool.PropertyMap.set_value">[docs]</a>    <span class="k">def</span> <span class="nf">set_value</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">val</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Sets all values in the property map to ``val``.&quot;&quot;&quot;</span>
        <span class="n">g</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_graph</span><span class="p">()</span>
        <span class="n">val</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__convert</span><span class="p">(</span><span class="n">val</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">key_type</span><span class="p">()</span> <span class="o">==</span> <span class="s2">&quot;v&quot;</span><span class="p">:</span>
            <span class="n">libcore</span><span class="o">.</span><span class="n">set_vertex_property</span><span class="p">(</span><span class="n">g</span><span class="o">.</span><span class="n">_Graph__graph</span><span class="p">,</span> <span class="n">_prop</span><span class="p">(</span><span class="s2">&quot;v&quot;</span><span class="p">,</span> <span class="n">g</span><span class="p">,</span> <span class="bp">self</span><span class="p">),</span> <span class="n">val</span><span class="p">)</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">key_type</span><span class="p">()</span> <span class="o">==</span> <span class="s2">&quot;e&quot;</span><span class="p">:</span>
            <span class="n">libcore</span><span class="o">.</span><span class="n">set_edge_property</span><span class="p">(</span><span class="n">g</span><span class="o">.</span><span class="n">_Graph__graph</span><span class="p">,</span> <span class="n">_prop</span><span class="p">(</span><span class="s2">&quot;e&quot;</span><span class="p">,</span> <span class="n">g</span><span class="p">,</span> <span class="bp">self</span><span class="p">),</span> <span class="n">val</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="p">[</span><span class="n">g</span><span class="p">]</span> <span class="o">=</span> <span class="n">val</span></div>

<div class="viewcode-block" id="PropertyMap.reserve"><a class="viewcode-back" href="https://graph-tool.skewed.de/static/doc/graph_tool.html#graph_tool.PropertyMap.reserve">[docs]</a>    <span class="k">def</span> <span class="nf">reserve</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">size</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Reserve enough space for ``size`` elements in underlying container. If the</span>
<span class="sd">           original size is already equal or larger, nothing will happen.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__map</span><span class="o">.</span><span class="n">reserve</span><span class="p">(</span><span class="n">size</span><span class="p">)</span></div>

<div class="viewcode-block" id="PropertyMap.resize"><a class="viewcode-back" href="https://graph-tool.skewed.de/static/doc/graph_tool.html#graph_tool.PropertyMap.resize">[docs]</a>    <span class="k">def</span> <span class="nf">resize</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">size</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Resize the underlying container to contain exactly ``size`` elements.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__map</span><span class="o">.</span><span class="n">resize</span><span class="p">(</span><span class="n">size</span><span class="p">)</span></div>

<div class="viewcode-block" id="PropertyMap.shrink_to_fit"><a class="viewcode-back" href="https://graph-tool.skewed.de/static/doc/graph_tool.html#graph_tool.PropertyMap.shrink_to_fit">[docs]</a>    <span class="k">def</span> <span class="nf">shrink_to_fit</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Shrink size of underlying container to accommodate only the necessary amount,</span>
<span class="sd">        and thus potentially freeing memory.&quot;&quot;&quot;</span>
        <span class="n">g</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_graph</span><span class="p">()</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">key_type</span><span class="p">()</span> <span class="o">==</span> <span class="s2">&quot;v&quot;</span><span class="p">:</span>
            <span class="n">size</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">num_vertices</span><span class="p">(</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">key_type</span><span class="p">()</span> <span class="o">==</span> <span class="s2">&quot;e&quot;</span><span class="p">:</span>
            <span class="n">size</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">edge_index_range</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">size</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__map</span><span class="o">.</span><span class="n">resize</span><span class="p">(</span><span class="n">size</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__map</span><span class="o">.</span><span class="n">shrink_to_fit</span><span class="p">()</span></div>

<div class="viewcode-block" id="PropertyMap.data_ptr"><a class="viewcode-back" href="https://graph-tool.skewed.de/static/doc/graph_tool.html#graph_tool.PropertyMap.data_ptr">[docs]</a>    <span class="k">def</span> <span class="nf">data_ptr</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the pointer to memory where the data resides.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__map</span><span class="o">.</span><span class="n">data_ptr</span><span class="p">()</span></div>

    <span class="k">def</span> <span class="nf">__getstate__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">g</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_graph</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">g</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;cannot pickle orphaned property map&quot;</span><span class="p">)</span>
        <span class="n">value_type</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">value_type</span><span class="p">()</span>
        <span class="n">key_type</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">key_type</span><span class="p">()</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_writable</span><span class="p">():</span>
            <span class="n">vals</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">u</span> <span class="o">=</span> <span class="n">GraphView</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">skip_vfilt</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">skip_efilt</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">key_type</span> <span class="o">==</span> <span class="s2">&quot;v&quot;</span><span class="p">:</span>
                <span class="n">vals</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">__convert</span><span class="p">(</span><span class="bp">self</span><span class="p">[</span><span class="n">v</span><span class="p">])</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">u</span><span class="o">.</span><span class="n">vertices</span><span class="p">()]</span>
            <span class="k">elif</span> <span class="n">key_type</span> <span class="o">==</span> <span class="s2">&quot;e&quot;</span><span class="p">:</span>
                <span class="n">vals</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">__convert</span><span class="p">(</span><span class="bp">self</span><span class="p">[</span><span class="n">e</span><span class="p">])</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">u</span><span class="o">.</span><span class="n">edges</span><span class="p">()]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">vals</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__convert</span><span class="p">(</span><span class="bp">self</span><span class="p">[</span><span class="n">g</span><span class="p">])</span>

        <span class="n">state</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">g</span><span class="o">=</span><span class="n">g</span><span class="p">,</span> <span class="n">value_type</span><span class="o">=</span><span class="n">value_type</span><span class="p">,</span>
                     <span class="n">key_type</span><span class="o">=</span><span class="n">key_type</span><span class="p">,</span> <span class="n">vals</span><span class="o">=</span><span class="n">vals</span><span class="p">,</span>
                     <span class="n">is_vindex</span><span class="o">=</span><span class="bp">self</span> <span class="ow">is</span> <span class="n">g</span><span class="o">.</span><span class="n">vertex_index</span><span class="p">,</span>
                     <span class="n">is_eindex</span><span class="o">=</span><span class="bp">self</span> <span class="ow">is</span> <span class="n">g</span><span class="o">.</span><span class="n">edge_index</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">state</span>

    <span class="k">def</span> <span class="nf">__setstate__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">state</span><span class="p">):</span>
        <span class="n">conv_pickle_state</span><span class="p">(</span><span class="n">state</span><span class="p">)</span>
        <span class="n">g</span> <span class="o">=</span> <span class="n">state</span><span class="p">[</span><span class="s2">&quot;g&quot;</span><span class="p">]</span>
        <span class="n">key_type</span> <span class="o">=</span> <span class="n">_str_decode</span><span class="p">(</span><span class="n">state</span><span class="p">[</span><span class="s2">&quot;key_type&quot;</span><span class="p">])</span>
        <span class="n">value_type</span> <span class="o">=</span> <span class="n">_str_decode</span><span class="p">(</span><span class="n">state</span><span class="p">[</span><span class="s2">&quot;value_type&quot;</span><span class="p">])</span>
        <span class="n">vals</span> <span class="o">=</span> <span class="n">state</span><span class="p">[</span><span class="s2">&quot;vals&quot;</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">state</span><span class="p">[</span><span class="s2">&quot;is_vindex&quot;</span><span class="p">]:</span>
            <span class="n">pmap</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">vertex_index</span>
        <span class="k">elif</span> <span class="n">state</span><span class="p">[</span><span class="s2">&quot;is_eindex&quot;</span><span class="p">]:</span>
            <span class="n">pmap</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">edge_index</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">u</span> <span class="o">=</span> <span class="n">GraphView</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">skip_vfilt</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">skip_efilt</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">key_type</span> <span class="o">==</span> <span class="s2">&quot;v&quot;</span><span class="p">:</span>
                <span class="n">pmap</span> <span class="o">=</span> <span class="n">u</span><span class="o">.</span><span class="n">new_vertex_property</span><span class="p">(</span><span class="n">value_type</span><span class="p">,</span> <span class="n">vals</span><span class="o">=</span><span class="n">vals</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">key_type</span> <span class="o">==</span> <span class="s2">&quot;e&quot;</span><span class="p">:</span>
                <span class="n">pmap</span> <span class="o">=</span> <span class="n">u</span><span class="o">.</span><span class="n">new_edge_property</span><span class="p">(</span><span class="n">value_type</span><span class="p">,</span> <span class="n">vals</span><span class="o">=</span><span class="n">vals</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">pmap</span> <span class="o">=</span> <span class="n">u</span><span class="o">.</span><span class="n">new_graph_property</span><span class="p">(</span><span class="n">value_type</span><span class="p">)</span>
                <span class="n">pmap</span><span class="p">[</span><span class="n">u</span><span class="p">]</span> <span class="o">=</span> <span class="n">vals</span>
            <span class="n">pmap</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">own_property</span><span class="p">(</span><span class="n">pmap</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">__map</span> <span class="o">=</span> <span class="n">pmap</span><span class="o">.</span><span class="n">__map</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__g</span> <span class="o">=</span> <span class="n">pmap</span><span class="o">.</span><span class="n">__g</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__base_g</span> <span class="o">=</span> <span class="n">pmap</span><span class="o">.</span><span class="n">__base_g</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__key_type</span> <span class="o">=</span> <span class="n">key_type</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__convert</span> <span class="o">=</span> <span class="n">_converter</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">value_type</span><span class="p">())</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__register_map</span><span class="p">()</span></div>

<div class="viewcode-block" id="PropertyArray"><a class="viewcode-back" href="https://graph-tool.skewed.de/static/doc/graph_tool.html#graph_tool.PropertyArray">[docs]</a><span class="k">class</span> <span class="nc">PropertyArray</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;This is a :class:`~numpy.ndarray` subclass which keeps a reference of its</span>
<span class="sd">    :class:`~graph_tool.PropertyMap` owner.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">__array_priority__</span> <span class="o">=</span> <span class="o">-</span><span class="mi">10</span>

    <span class="k">def</span> <span class="nf">_get_pmap</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_prop_map</span>

    <span class="k">def</span> <span class="nf">_set_pmap</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_prop_map</span> <span class="o">=</span> <span class="n">value</span>

    <span class="n">prop_map</span> <span class="o">=</span> <span class="nb">property</span><span class="p">(</span><span class="n">_get_pmap</span><span class="p">,</span> <span class="n">_set_pmap</span><span class="p">,</span>
                        <span class="n">doc</span><span class="o">=</span><span class="s2">&quot;:class:`~graph_tool.PropertyMap` owner instance.&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__new__</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">input_array</span><span class="p">,</span> <span class="n">prop_map</span><span class="p">):</span>
        <span class="n">obj</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">input_array</span><span class="p">)</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="bp">cls</span><span class="p">)</span>
        <span class="n">obj</span><span class="o">.</span><span class="n">prop_map</span> <span class="o">=</span> <span class="n">prop_map</span>
        <span class="k">return</span> <span class="n">obj</span></div>

<span class="k">def</span> <span class="nf">_check_prop_writable</span><span class="p">(</span><span class="n">prop</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">prop</span><span class="o">.</span><span class="n">is_writable</span><span class="p">():</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;property map</span><span class="si">%s</span><span class="s2"> is not writable.&quot;</span> <span class="o">%</span>\
                         <span class="p">((</span><span class="s2">&quot; &#39;</span><span class="si">%s</span><span class="s2">&#39;&quot;</span> <span class="o">%</span> <span class="n">name</span><span class="p">)</span> <span class="k">if</span> <span class="n">name</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="s2">&quot;&quot;</span><span class="p">))</span>


<span class="k">def</span> <span class="nf">_check_prop_scalar</span><span class="p">(</span><span class="n">prop</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">floating</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="n">scalars</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;bool&quot;</span><span class="p">,</span> <span class="s2">&quot;int16_t&quot;</span><span class="p">,</span> <span class="s2">&quot;int32_t&quot;</span><span class="p">,</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">,</span> <span class="s2">&quot;unsigned long&quot;</span><span class="p">,</span>
               <span class="s2">&quot;double&quot;</span><span class="p">,</span> <span class="s2">&quot;long double&quot;</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">floating</span><span class="p">:</span>
        <span class="n">scalars</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;double&quot;</span><span class="p">,</span> <span class="s2">&quot;long double&quot;</span><span class="p">]</span>

    <span class="k">if</span> <span class="n">prop</span><span class="o">.</span><span class="n">value_type</span><span class="p">()</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">scalars</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;property map</span><span class="si">%s</span><span class="s2"> is not of scalar</span><span class="si">%s</span><span class="s2"> type.&quot;</span> <span class="o">%</span>\
                         <span class="p">(((</span><span class="s2">&quot; &#39;</span><span class="si">%s</span><span class="s2">&#39;&quot;</span> <span class="o">%</span> <span class="n">name</span><span class="p">)</span> <span class="k">if</span> <span class="n">name</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="s2">&quot;&quot;</span><span class="p">),</span>
                          <span class="p">(</span><span class="s2">&quot; floating&quot;</span> <span class="k">if</span> <span class="n">floating</span> <span class="k">else</span> <span class="s2">&quot;&quot;</span><span class="p">)))</span>


<span class="k">def</span> <span class="nf">_check_prop_vector</span><span class="p">(</span><span class="n">prop</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">scalar</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">floating</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="n">scalars</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;bool&quot;</span><span class="p">,</span> <span class="s2">&quot;int16_t&quot;</span><span class="p">,</span> <span class="s2">&quot;int32_t&quot;</span><span class="p">,</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">,</span> <span class="s2">&quot;unsigned long&quot;</span><span class="p">,</span>
               <span class="s2">&quot;double&quot;</span><span class="p">,</span> <span class="s2">&quot;long double&quot;</span><span class="p">]</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">scalar</span><span class="p">:</span>
        <span class="n">scalars</span> <span class="o">+=</span> <span class="p">[</span><span class="s2">&quot;string&quot;</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">floating</span><span class="p">:</span>
        <span class="n">scalars</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;double&quot;</span><span class="p">,</span> <span class="s2">&quot;long double&quot;</span><span class="p">]</span>
    <span class="n">vals</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;vector&lt;</span><span class="si">%s</span><span class="s2">&gt;&quot;</span> <span class="o">%</span> <span class="n">v</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">scalars</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">prop</span><span class="o">.</span><span class="n">value_type</span><span class="p">()</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">vals</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;property map</span><span class="si">%s</span><span class="s2"> is not of vector</span><span class="si">%s</span><span class="s2"> type.&quot;</span> <span class="o">%</span>\
                         <span class="p">(((</span><span class="s2">&quot; &#39;</span><span class="si">%s</span><span class="s2">&#39;&quot;</span> <span class="o">%</span> <span class="n">name</span><span class="p">)</span> <span class="k">if</span> <span class="n">name</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="s2">&quot;&quot;</span><span class="p">),</span>
                          <span class="p">(</span><span class="s2">&quot; floating&quot;</span> <span class="k">if</span> <span class="n">floating</span> <span class="k">else</span> <span class="s2">&quot;&quot;</span><span class="p">)))</span>


<div class="viewcode-block" id="group_vector_property"><a class="viewcode-back" href="https://graph-tool.skewed.de/static/doc/graph_tool.html#graph_tool.group_vector_property">[docs]</a><span class="k">def</span> <span class="nf">group_vector_property</span><span class="p">(</span><span class="n">props</span><span class="p">,</span> <span class="n">value_type</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">vprop</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">pos</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Group list of properties ``props`` into a vector property map of the same type.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    props : list of :class:`~graph_tool.PropertyMap`</span>
<span class="sd">        Properties to be grouped.</span>
<span class="sd">    value_type : string (optional, default: None)</span>
<span class="sd">        If supplied, defines the value type of the grouped property.</span>
<span class="sd">    vprop : :class:`~graph_tool.PropertyMap` (optional, default: None)</span>
<span class="sd">        If supplied, the properties are grouped into this property map.</span>
<span class="sd">    pos : list of ints (optional, default: None)</span>
<span class="sd">        If supplied, should contain a list of indexes where each corresponding</span>
<span class="sd">        element of ``props`` should be inserted.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    vprop : :class:`~graph_tool.PropertyMap`</span>
<span class="sd">       A vector property map with the grouped values of each property map in</span>
<span class="sd">       ``props``.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; from numpy.random import seed, randint</span>
<span class="sd">    &gt;&gt;&gt; from numpy import array</span>
<span class="sd">    &gt;&gt;&gt; seed(42)</span>
<span class="sd">    &gt;&gt;&gt; gt.seed_rng(42)</span>
<span class="sd">    &gt;&gt;&gt; g = gt.random_graph(100, lambda: (3, 3))</span>
<span class="sd">    &gt;&gt;&gt; props = [g.new_vertex_property(&quot;int&quot;) for i in range(3)]</span>
<span class="sd">    &gt;&gt;&gt; for i in range(3):</span>
<span class="sd">    ...    props[i].a = randint(0, 100, g.num_vertices())</span>
<span class="sd">    &gt;&gt;&gt; gprop = gt.group_vector_property(props)</span>
<span class="sd">    &gt;&gt;&gt; print(gprop[g.vertex(0)].a)</span>
<span class="sd">    [51 25  8]</span>
<span class="sd">    &gt;&gt;&gt; print(array([p[g.vertex(0)] for p in props]))</span>
<span class="sd">    [51 25  8]</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">g</span> <span class="o">=</span> <span class="n">props</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">get_graph</span><span class="p">()</span>
    <span class="n">vtypes</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
    <span class="n">keys</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">p</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">props</span><span class="p">):</span>
        <span class="k">if</span> <span class="s2">&quot;vector&quot;</span> <span class="ow">in</span> <span class="n">p</span><span class="o">.</span><span class="n">value_type</span><span class="p">():</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;property map &#39;props[</span><span class="si">%d</span><span class="s2">]&#39; is a vector property.&quot;</span> <span class="o">%</span>
                             <span class="n">i</span><span class="p">)</span>
        <span class="n">vtypes</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">value_type</span><span class="p">())</span>
        <span class="n">keys</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">key_type</span><span class="p">())</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">keys</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;&#39;props&#39; must be of the same key type.&quot;</span><span class="p">)</span>
    <span class="n">k</span> <span class="o">=</span> <span class="n">keys</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>

    <span class="k">if</span> <span class="n">vprop</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">value_type</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">vtypes</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">value_type</span> <span class="o">=</span> <span class="n">vtypes</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">value_type</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">value_type</span> <span class="o">=</span> <span class="s2">&quot;vector&lt;</span><span class="si">%s</span><span class="s2">&gt;&quot;</span> <span class="o">%</span> <span class="n">value_type</span>
            <span class="k">if</span> <span class="n">k</span> <span class="o">==</span> <span class="s1">&#39;v&#39;</span><span class="p">:</span>
                <span class="n">vprop</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">new_vertex_property</span><span class="p">(</span><span class="n">value_type</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">k</span> <span class="o">==</span> <span class="s1">&#39;e&#39;</span><span class="p">:</span>
                <span class="n">vprop</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">new_edge_property</span><span class="p">(</span><span class="n">value_type</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">vprop</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">new_graph_property</span><span class="p">(</span><span class="n">value_type</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Can&#39;t automatically determine property map value&quot;</span> <span class="o">+</span>
                       <span class="s2">&quot; type. Please provide the &#39;value_type&#39; parameter.&quot;</span><span class="p">)</span>
    <span class="n">_check_prop_vector</span><span class="p">(</span><span class="n">vprop</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;vprop&quot;</span><span class="p">,</span> <span class="n">scalar</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">p</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">props</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">k</span> <span class="o">!=</span> <span class="s2">&quot;g&quot;</span><span class="p">:</span>
            <span class="n">u</span> <span class="o">=</span> <span class="n">GraphView</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">directed</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="nb">reversed</span><span class="o">=</span><span class="n">g</span><span class="o">.</span><span class="n">is_reversed</span><span class="p">(),</span>
                          <span class="n">skip_properties</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="n">libcore</span><span class="o">.</span><span class="n">group_vector_property</span><span class="p">(</span><span class="n">u</span><span class="o">.</span><span class="n">_Graph__graph</span><span class="p">,</span> <span class="n">_prop</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">g</span><span class="p">,</span> <span class="n">vprop</span><span class="p">),</span>
                                          <span class="n">_prop</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">g</span><span class="p">,</span> <span class="n">p</span><span class="p">),</span>
                                          <span class="n">i</span> <span class="k">if</span> <span class="n">pos</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">pos</span><span class="p">[</span><span class="n">i</span><span class="p">],</span>
                                          <span class="n">k</span> <span class="o">==</span> <span class="s1">&#39;e&#39;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">vprop</span><span class="p">[</span><span class="n">g</span><span class="p">][</span><span class="n">i</span> <span class="k">if</span> <span class="n">pos</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">pos</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="o">=</span> <span class="n">p</span><span class="p">[</span><span class="n">g</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">vprop</span></div>


<div class="viewcode-block" id="ungroup_vector_property"><a class="viewcode-back" href="https://graph-tool.skewed.de/static/doc/graph_tool.html#graph_tool.ungroup_vector_property">[docs]</a><span class="k">def</span> <span class="nf">ungroup_vector_property</span><span class="p">(</span><span class="n">vprop</span><span class="p">,</span> <span class="n">pos</span><span class="p">,</span> <span class="n">props</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Ungroup vector property map ``vprop`` into a list of individual property maps.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    vprop : :class:`~graph_tool.PropertyMap`</span>
<span class="sd">        Vector property map to be ungrouped.</span>
<span class="sd">    pos : list of ints</span>
<span class="sd">        A list of indexes corresponding to where each element of ``vprop``</span>
<span class="sd">        should be inserted into the ungrouped list.</span>
<span class="sd">    props : list of :class:`~graph_tool.PropertyMap`  (optional, default: None)</span>
<span class="sd">        If supplied, should contain a list of property maps to which ``vprop``</span>
<span class="sd">        should be ungroupped.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    props : list of :class:`~graph_tool.PropertyMap`</span>
<span class="sd">       A list of property maps with the ungrouped values of ``vprop``.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; from numpy.random import seed, randint</span>
<span class="sd">    &gt;&gt;&gt; from numpy import array</span>
<span class="sd">    &gt;&gt;&gt; seed(42)</span>
<span class="sd">    &gt;&gt;&gt; gt.seed_rng(42)</span>
<span class="sd">    &gt;&gt;&gt; g = gt.random_graph(100, lambda: (3, 3))</span>
<span class="sd">    &gt;&gt;&gt; prop = g.new_vertex_property(&quot;vector&lt;int&gt;&quot;)</span>
<span class="sd">    &gt;&gt;&gt; for v in g.vertices():</span>
<span class="sd">    ...    prop[v] = randint(0, 100, 3)</span>
<span class="sd">    &gt;&gt;&gt; uprops = gt.ungroup_vector_property(prop, [0, 1, 2])</span>
<span class="sd">    &gt;&gt;&gt; print(prop[g.vertex(0)].a)</span>
<span class="sd">    [51 92 14]</span>
<span class="sd">    &gt;&gt;&gt; print(array([p[g.vertex(0)] for p in uprops]))</span>
<span class="sd">    [51 92 14]</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">g</span> <span class="o">=</span> <span class="n">vprop</span><span class="o">.</span><span class="n">get_graph</span><span class="p">()</span>
    <span class="n">_check_prop_vector</span><span class="p">(</span><span class="n">vprop</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;vprop&quot;</span><span class="p">,</span> <span class="n">scalar</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    <span class="n">k</span> <span class="o">=</span> <span class="n">vprop</span><span class="o">.</span><span class="n">key_type</span><span class="p">()</span>
    <span class="n">value_type</span> <span class="o">=</span> <span class="n">vprop</span><span class="o">.</span><span class="n">value_type</span><span class="p">()</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;&lt;&quot;</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;&gt;&quot;</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">props</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">k</span> <span class="o">==</span> <span class="s1">&#39;v&#39;</span><span class="p">:</span>
            <span class="n">props</span> <span class="o">=</span> <span class="p">[</span><span class="n">g</span><span class="o">.</span><span class="n">new_vertex_property</span><span class="p">(</span><span class="n">value_type</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">pos</span><span class="p">]</span>
        <span class="k">elif</span> <span class="n">k</span> <span class="o">==</span> <span class="s1">&#39;e&#39;</span><span class="p">:</span>
            <span class="n">props</span> <span class="o">=</span> <span class="p">[</span><span class="n">g</span><span class="o">.</span><span class="n">new_edge_property</span><span class="p">(</span><span class="n">value_type</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">pos</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">props</span> <span class="o">=</span> <span class="p">[</span><span class="n">g</span><span class="o">.</span><span class="n">new_graph_property</span><span class="p">(</span><span class="n">value_type</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">pos</span><span class="p">]</span>

    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">p</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">pos</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">props</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">key_type</span><span class="p">()</span> <span class="o">!=</span> <span class="n">k</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;&#39;props&#39; must be of the same key type as &#39;vprop&#39;.&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">k</span> <span class="o">!=</span> <span class="s1">&#39;g&#39;</span><span class="p">:</span>
            <span class="n">u</span> <span class="o">=</span> <span class="n">GraphView</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">directed</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="nb">reversed</span><span class="o">=</span><span class="n">g</span><span class="o">.</span><span class="n">is_reversed</span><span class="p">(),</span>
                          <span class="n">skip_properties</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="n">libcore</span><span class="o">.</span><span class="n">ungroup_vector_property</span><span class="p">(</span><span class="n">u</span><span class="o">.</span><span class="n">_Graph__graph</span><span class="p">,</span>
                                            <span class="n">_prop</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">g</span><span class="p">,</span> <span class="n">vprop</span><span class="p">),</span>
                                            <span class="n">_prop</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">g</span><span class="p">,</span> <span class="n">props</span><span class="p">[</span><span class="n">i</span><span class="p">]),</span>
                                            <span class="n">p</span><span class="p">,</span> <span class="n">k</span> <span class="o">==</span> <span class="s1">&#39;e&#39;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">vprop</span><span class="p">[</span><span class="n">g</span><span class="p">])</span> <span class="o">&lt;=</span> <span class="n">pos</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span>
                <span class="n">vprop</span><span class="p">[</span><span class="n">g</span><span class="p">]</span><span class="o">.</span><span class="n">resize</span><span class="p">(</span><span class="n">pos</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
            <span class="n">props</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">g</span><span class="p">]</span> <span class="o">=</span> <span class="n">vprop</span><span class="p">[</span><span class="n">g</span><span class="p">][</span><span class="n">pos</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span>
    <span class="k">return</span> <span class="n">props</span></div>

<div class="viewcode-block" id="map_property_values"><a class="viewcode-back" href="https://graph-tool.skewed.de/static/doc/graph_tool.html#graph_tool.map_property_values">[docs]</a><span class="k">def</span> <span class="nf">map_property_values</span><span class="p">(</span><span class="n">src_prop</span><span class="p">,</span> <span class="n">tgt_prop</span><span class="p">,</span> <span class="n">map_func</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Map the values of ``src_prop`` to ``tgt_prop`` according to the mapping</span>
<span class="sd">    function ``map_func``.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    src_prop : :class:`~graph_tool.PropertyMap`</span>
<span class="sd">        Source property map.</span>
<span class="sd">    tgt_prop : :class:`~graph_tool.PropertyMap`</span>
<span class="sd">        Target property map.</span>
<span class="sd">    map_func : function or callable object</span>
<span class="sd">        Function mapping values of ``src_prop`` to values of ``tgt_prop``.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    None</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; g = gt.collection.data[&quot;lesmis&quot;]</span>
<span class="sd">    &gt;&gt;&gt; label_len = g.new_vertex_property(&quot;int64_t&quot;)</span>
<span class="sd">    &gt;&gt;&gt; gt.map_property_values(g.vp.label, label_len,</span>
<span class="sd">    ...                        lambda x: len(x))</span>
<span class="sd">    &gt;&gt;&gt; print(label_len.a)</span>
<span class="sd">    [ 6  8 14 11 12  8 12  8  5  6  7  7 10  6  7  7  9  9  7 11  9  6  7  7</span>
<span class="sd">     13 10  7  6 12 10  8  8 11  6  5 12  6 10 11  9 12  7  7  6 14  7  9  9</span>
<span class="sd">      8 12  6 16 12 11 14  6  9  6  8 10  9  7 10  7  7  4  9 14  9  5 10 12</span>
<span class="sd">      9  6  6  6 12]</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="n">src_prop</span><span class="o">.</span><span class="n">key_type</span><span class="p">()</span> <span class="o">!=</span> <span class="n">tgt_prop</span><span class="o">.</span><span class="n">key_type</span><span class="p">():</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;src_prop and tgt_prop must be of the same key type&quot;</span><span class="p">)</span>
    <span class="n">g</span> <span class="o">=</span> <span class="n">src_prop</span><span class="o">.</span><span class="n">get_graph</span><span class="p">()</span>
    <span class="n">k</span> <span class="o">=</span> <span class="n">src_prop</span><span class="o">.</span><span class="n">key_type</span><span class="p">()</span>
    <span class="k">if</span> <span class="n">k</span> <span class="o">==</span> <span class="s2">&quot;g&quot;</span><span class="p">:</span>
        <span class="n">tgt_prop</span><span class="p">[</span><span class="n">g</span><span class="p">]</span> <span class="o">=</span> <span class="n">map_func</span><span class="p">(</span><span class="n">src_prop</span><span class="p">[</span><span class="n">g</span><span class="p">])</span>
        <span class="k">return</span>
    <span class="n">u</span> <span class="o">=</span> <span class="n">GraphView</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">directed</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="nb">reversed</span><span class="o">=</span><span class="n">g</span><span class="o">.</span><span class="n">is_reversed</span><span class="p">(),</span>
                  <span class="n">skip_properties</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">libcore</span><span class="o">.</span><span class="n">property_map_values</span><span class="p">(</span><span class="n">u</span><span class="o">.</span><span class="n">_Graph__graph</span><span class="p">,</span>
                                <span class="n">_prop</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">g</span><span class="p">,</span> <span class="n">src_prop</span><span class="p">),</span>
                                <span class="n">_prop</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">g</span><span class="p">,</span> <span class="n">tgt_prop</span><span class="p">),</span>
                                <span class="n">map_func</span><span class="p">,</span> <span class="n">k</span> <span class="o">==</span> <span class="s1">&#39;e&#39;</span><span class="p">)</span></div>

<div class="viewcode-block" id="infect_vertex_property"><a class="viewcode-back" href="https://graph-tool.skewed.de/static/doc/graph_tool.html#graph_tool.infect_vertex_property">[docs]</a><span class="k">def</span> <span class="nf">infect_vertex_property</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">prop</span><span class="p">,</span> <span class="n">vals</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Propagate the `prop` values of vertices with value `val` to all their</span>
<span class="sd">    out-neighbors.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    prop : :class:`~graph_tool.PropertyMap`</span>
<span class="sd">        Property map to be modified.</span>
<span class="sd">    vals : list (optional, default: `None`)</span>
<span class="sd">        List of values to be propagated. If not provided, all values</span>
<span class="sd">        will be propagated.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    None : ``None``</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; from numpy.random import seed</span>
<span class="sd">    &gt;&gt;&gt; seed(42)</span>
<span class="sd">    &gt;&gt;&gt; gt.seed_rng(42)</span>
<span class="sd">    &gt;&gt;&gt; g = gt.random_graph(100, lambda: (3, 3))</span>
<span class="sd">    &gt;&gt;&gt; prop = g.vertex_index.copy(&quot;int32_t&quot;)</span>
<span class="sd">    &gt;&gt;&gt; gt.infect_vertex_property(g, prop, [10])</span>
<span class="sd">    &gt;&gt;&gt; print(sum(prop.a == 10))</span>
<span class="sd">    4</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">libcore</span><span class="o">.</span><span class="n">infect_vertex_property</span><span class="p">(</span><span class="n">g</span><span class="o">.</span><span class="n">_Graph__graph</span><span class="p">,</span> <span class="n">_prop</span><span class="p">(</span><span class="s2">&quot;v&quot;</span><span class="p">,</span> <span class="n">g</span><span class="p">,</span> <span class="n">prop</span><span class="p">),</span>
                                   <span class="n">vals</span><span class="p">)</span></div>


<div class="viewcode-block" id="edge_endpoint_property"><a class="viewcode-back" href="https://graph-tool.skewed.de/static/doc/graph_tool.html#graph_tool.edge_endpoint_property">[docs]</a><span class="nd">@_limit_args</span><span class="p">({</span><span class="s2">&quot;endpoint&quot;</span><span class="p">:</span> <span class="p">[</span><span class="s2">&quot;source&quot;</span><span class="p">,</span> <span class="s2">&quot;target&quot;</span><span class="p">]})</span>
<span class="k">def</span> <span class="nf">edge_endpoint_property</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">prop</span><span class="p">,</span> <span class="n">endpoint</span><span class="p">,</span> <span class="n">eprop</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Return an edge property map corresponding to the vertex property `prop` of</span>
<span class="sd">    either the target and source of the edge, according to `endpoint`.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    prop : :class:`~graph_tool.PropertyMap`</span>
<span class="sd">        Vertex property map to be used to propagated to the edge.</span>
<span class="sd">    endpoint : `&quot;source&quot;` or `&quot;target&quot;`</span>
<span class="sd">        Edge endpoint considered. If the graph is undirected, the source is</span>
<span class="sd">        always the vertex with the lowest index.</span>
<span class="sd">    eprop : :class:`~graph_tool.PropertyMap` (optional, default: `None`)</span>
<span class="sd">        If provided, the resulting edge properties will be stored here.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    eprop : :class:`~graph_tool.PropertyMap`</span>
<span class="sd">        Propagated edge property.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; gt.seed_rng(42)</span>
<span class="sd">    &gt;&gt;&gt; g = gt.random_graph(100, lambda: (3, 3))</span>
<span class="sd">    &gt;&gt;&gt; esource = gt.edge_endpoint_property(g, g.vertex_index, &quot;source&quot;)</span>
<span class="sd">    &gt;&gt;&gt; print(esource.a)</span>
<span class="sd">    [ 0  0  0 96 96 96 92 92 92 88 88 88 84 84 84 80 80 80 76 76 76 72 72 72</span>
<span class="sd">     68 68 68 64 64 64 60 60 60 56 56 56 52 52 52 48 48 48 44 44 44 40 40 40</span>
<span class="sd">     36 36 36 32 32 32 28 28 28 24 24 24 20 20 20 16 16 16 12 12 12  8  8  8</span>
<span class="sd">      4  4  4 99 99 99  1  1  1  2  2  2  3  3  3  5  5  5  6  6  6  7  7  7</span>
<span class="sd">      9  9  9 10 10 10 14 14 14 19 19 19 25 25 25 30 30 30 35 35 35 41 41 41</span>
<span class="sd">     46 46 46 51 51 51 57 57 57 62 62 62 67 67 67 73 73 73 78 78 78 83 83 83</span>
<span class="sd">     89 89 89 94 94 94 11 11 11 98 98 98 97 97 97 95 95 95 93 93 93 91 91 91</span>
<span class="sd">     90 90 90 87 87 87 86 86 86 85 85 85 82 82 82 81 81 81 79 79 79 77 77 77</span>
<span class="sd">     75 75 75 74 74 74 71 71 71 69 69 69 61 61 61 54 54 54 47 47 47 39 39 39</span>
<span class="sd">     33 33 33 26 26 26 18 18 18 70 70 70 13 13 13 15 15 15 17 17 17 21 21 21</span>
<span class="sd">     22 22 22 23 23 23 27 27 27 29 29 29 31 31 31 34 34 34 37 37 37 38 38 38</span>
<span class="sd">     42 42 42 43 43 43 45 45 45 49 49 49 50 50 50 53 53 53 55 55 55 58 58 58</span>
<span class="sd">     59 59 59 63 63 63 65 65 65 66 66 66]</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">val_t</span> <span class="o">=</span> <span class="n">prop</span><span class="o">.</span><span class="n">value_type</span><span class="p">()</span>
    <span class="k">if</span> <span class="n">val_t</span> <span class="o">==</span> <span class="s2">&quot;unsigned long&quot;</span> <span class="ow">or</span> <span class="n">val_t</span> <span class="o">==</span> <span class="s2">&quot;unsigned int&quot;</span><span class="p">:</span>
        <span class="n">val_t</span> <span class="o">=</span> <span class="s2">&quot;int64_t&quot;</span>
    <span class="k">if</span> <span class="n">eprop</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">eprop</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">new_edge_property</span><span class="p">(</span><span class="n">val_t</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">eprop</span><span class="o">.</span><span class="n">value_type</span><span class="p">()</span> <span class="o">!=</span> <span class="n">val_t</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;&#39;eprop&#39; must be of the same value type as &#39;prop&#39;: &quot;</span> <span class="o">+</span>
                         <span class="n">val_t</span><span class="p">)</span>
    <span class="n">libcore</span><span class="o">.</span><span class="n">edge_endpoint</span><span class="p">(</span><span class="n">g</span><span class="o">.</span><span class="n">_Graph__graph</span><span class="p">,</span> <span class="n">_prop</span><span class="p">(</span><span class="s2">&quot;v&quot;</span><span class="p">,</span> <span class="n">g</span><span class="p">,</span> <span class="n">prop</span><span class="p">),</span>
                          <span class="n">_prop</span><span class="p">(</span><span class="s2">&quot;e&quot;</span><span class="p">,</span> <span class="n">g</span><span class="p">,</span> <span class="n">eprop</span><span class="p">),</span> <span class="n">_to_str</span><span class="p">(</span><span class="n">endpoint</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">eprop</span></div>

<div class="viewcode-block" id="incident_edges_op"><a class="viewcode-back" href="https://graph-tool.skewed.de/static/doc/graph_tool.html#graph_tool.incident_edges_op">[docs]</a><span class="nd">@_limit_args</span><span class="p">({</span><span class="s2">&quot;direction&quot;</span><span class="p">:</span> <span class="p">[</span><span class="s2">&quot;in&quot;</span><span class="p">,</span> <span class="s2">&quot;out&quot;</span><span class="p">],</span> <span class="s2">&quot;op&quot;</span><span class="p">:</span> <span class="p">[</span><span class="s2">&quot;sum&quot;</span><span class="p">,</span> <span class="s2">&quot;prod&quot;</span><span class="p">,</span> <span class="s2">&quot;min&quot;</span><span class="p">,</span> <span class="s2">&quot;max&quot;</span><span class="p">]})</span>
<span class="k">def</span> <span class="nf">incident_edges_op</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">direction</span><span class="p">,</span> <span class="n">op</span><span class="p">,</span> <span class="n">eprop</span><span class="p">,</span> <span class="n">vprop</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Return a vertex property map corresponding to a specific operation (sum,</span>
<span class="sd">    product, min or max) on the edge property `eprop` of incident edges on each</span>
<span class="sd">    vertex, following the direction given by `direction`.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    direction : `&quot;in&quot;` or `&quot;out&quot;`</span>
<span class="sd">        Direction of the incident edges.</span>
<span class="sd">    op : `&quot;sum&quot;`, `&quot;prod&quot;`, `&quot;min&quot;` or `&quot;max&quot;`</span>
<span class="sd">        Operation performed on incident edges.</span>
<span class="sd">    eprop : :class:`~graph_tool.PropertyMap`</span>
<span class="sd">        Edge property map to be summed.</span>
<span class="sd">    vprop : :class:`~graph_tool.PropertyMap` (optional, default: `None`)</span>
<span class="sd">        If provided, the resulting vertex properties will be stored here.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    vprop : :class:`~graph_tool.PropertyMap`</span>
<span class="sd">        Resulting vertex property.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; gt.seed_rng(42)</span>
<span class="sd">    &gt;&gt;&gt; g = gt.random_graph(100, lambda: (3, 3))</span>
<span class="sd">    &gt;&gt;&gt; vsum = gt.incident_edges_op(g, &quot;out&quot;, &quot;sum&quot;, g.edge_index)</span>
<span class="sd">    &gt;&gt;&gt; print(vsum.a)</span>
<span class="sd">    [  3 237 246 255 219 264 273 282 210 291 300 453 201 687 309 696 192 705</span>
<span class="sd">     669 318 183 714 723 732 174 327 660 741 165 750 336 759 156 651 768 345</span>
<span class="sd">     147 777 786 642 138 354 795 804 129 813 363 633 120 822 831 372 111 840</span>
<span class="sd">     624 849 102 381 858 867  93 615 390 876  84 885 894 399  75 606 678 597</span>
<span class="sd">      66 408 588 579  57 570 417 561  48 552 543 426  39 534 525 516  30 435</span>
<span class="sd">     507 498  21 489 444 480  12 471 462 228]</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">val_t</span> <span class="o">=</span> <span class="n">eprop</span><span class="o">.</span><span class="n">value_type</span><span class="p">()</span>
    <span class="k">if</span> <span class="n">val_t</span> <span class="o">==</span> <span class="s2">&quot;unsigned long&quot;</span> <span class="ow">or</span> <span class="n">val_t</span> <span class="o">==</span> <span class="s2">&quot;unsigned int&quot;</span><span class="p">:</span>
        <span class="n">val_t</span> <span class="o">=</span> <span class="s2">&quot;int64_t&quot;</span>
    <span class="k">if</span> <span class="n">vprop</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">vprop</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">new_vertex_property</span><span class="p">(</span><span class="n">val_t</span><span class="p">)</span>
    <span class="n">orig_vprop</span> <span class="o">=</span> <span class="n">vprop</span>
    <span class="k">if</span> <span class="n">vprop</span><span class="o">.</span><span class="n">value_type</span> <span class="o">!=</span> <span class="n">val_t</span><span class="p">:</span>
        <span class="n">vprop</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">new_vertex_property</span><span class="p">(</span><span class="n">val_t</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">direction</span> <span class="o">==</span> <span class="s2">&quot;in&quot;</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">g</span><span class="o">.</span><span class="n">is_directed</span><span class="p">():</span>
        <span class="k">return</span> <span class="n">orig_vprop</span>
    <span class="k">if</span> <span class="n">direction</span> <span class="o">==</span> <span class="s2">&quot;in&quot;</span><span class="p">:</span>
        <span class="n">g</span> <span class="o">=</span> <span class="n">GraphView</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="nb">reversed</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">skip_properties</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">libcore</span><span class="o">.</span><span class="n">out_edges_op</span><span class="p">(</span><span class="n">g</span><span class="o">.</span><span class="n">_Graph__graph</span><span class="p">,</span> <span class="n">_prop</span><span class="p">(</span><span class="s2">&quot;e&quot;</span><span class="p">,</span> <span class="n">g</span><span class="p">,</span> <span class="n">eprop</span><span class="p">),</span>
                          <span class="n">_prop</span><span class="p">(</span><span class="s2">&quot;v&quot;</span><span class="p">,</span> <span class="n">g</span><span class="p">,</span> <span class="n">vprop</span><span class="p">),</span> <span class="n">_to_str</span><span class="p">(</span><span class="n">op</span><span class="p">))</span>
    <span class="k">if</span> <span class="n">vprop</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">orig_vprop</span><span class="p">:</span>
        <span class="n">g</span><span class="o">.</span><span class="n">copy_property</span><span class="p">(</span><span class="n">vprop</span><span class="p">,</span> <span class="n">orig_vprop</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">orig_vprop</span></div>

<div class="viewcode-block" id="perfect_prop_hash"><a class="viewcode-back" href="https://graph-tool.skewed.de/static/doc/graph_tool.html#graph_tool.perfect_prop_hash">[docs]</a><span class="nd">@_limit_args</span><span class="p">({</span><span class="s2">&quot;htype&quot;</span><span class="p">:</span> <span class="p">[</span><span class="s2">&quot;int8_t&quot;</span><span class="p">,</span> <span class="s2">&quot;int32_t&quot;</span><span class="p">,</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">]})</span>
<span class="k">def</span> <span class="nf">perfect_prop_hash</span><span class="p">(</span><span class="n">props</span><span class="p">,</span> <span class="n">htype</span><span class="o">=</span><span class="s2">&quot;int32_t&quot;</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Given a list of property maps `props` of the same type, a derived list of</span>
<span class="sd">    property maps with integral type `htype` is returned, where each value is</span>
<span class="sd">    replaced by a perfect (i.e. unique) hash value.</span>

<span class="sd">    .. note::</span>
<span class="sd">       The hash value is deterministic, but it will not be necessarily the same</span>
<span class="sd">       for different values of `props`.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">val_types</span> <span class="o">=</span> <span class="nb">set</span><span class="p">([</span><span class="n">p</span><span class="o">.</span><span class="n">value_type</span><span class="p">()</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">props</span><span class="p">])</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">val_types</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;All properties must have the same value type&quot;</span><span class="p">)</span>
    <span class="n">hprops</span> <span class="o">=</span> <span class="p">[</span><span class="n">p</span><span class="o">.</span><span class="n">get_graph</span><span class="p">()</span><span class="o">.</span><span class="n">new_property</span><span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">key_type</span><span class="p">(),</span> <span class="n">htype</span><span class="p">)</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">props</span><span class="p">]</span>

    <span class="n">eprops</span> <span class="o">=</span> <span class="p">[</span><span class="n">p</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">props</span> <span class="k">if</span> <span class="n">p</span><span class="o">.</span><span class="n">key_type</span><span class="p">()</span> <span class="o">==</span> <span class="s2">&quot;e&quot;</span><span class="p">]</span>
    <span class="n">heprops</span> <span class="o">=</span> <span class="p">[</span><span class="n">p</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">hprops</span> <span class="k">if</span> <span class="n">p</span><span class="o">.</span><span class="n">key_type</span><span class="p">()</span> <span class="o">==</span> <span class="s2">&quot;e&quot;</span><span class="p">]</span>

    <span class="n">vprops</span> <span class="o">=</span> <span class="p">[</span><span class="n">p</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">props</span> <span class="k">if</span> <span class="n">p</span><span class="o">.</span><span class="n">key_type</span><span class="p">()</span> <span class="o">==</span> <span class="s2">&quot;v&quot;</span><span class="p">]</span>
    <span class="n">hvprops</span> <span class="o">=</span> <span class="p">[</span><span class="n">p</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">hprops</span> <span class="k">if</span> <span class="n">p</span><span class="o">.</span><span class="n">key_type</span><span class="p">()</span> <span class="o">==</span> <span class="s2">&quot;v&quot;</span><span class="p">]</span>

    <span class="n">hdict</span> <span class="o">=</span> <span class="n">libcore</span><span class="o">.</span><span class="n">any</span><span class="p">()</span>

    <span class="k">for</span> <span class="n">eprop</span><span class="p">,</span> <span class="n">heprop</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">eprops</span><span class="p">,</span> <span class="n">heprops</span><span class="p">):</span>
        <span class="n">g</span> <span class="o">=</span> <span class="n">eprop</span><span class="o">.</span><span class="n">get_graph</span><span class="p">()</span>
        <span class="n">g</span> <span class="o">=</span> <span class="n">GraphView</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">directed</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">skip_properties</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">libcore</span><span class="o">.</span><span class="n">perfect_ehash</span><span class="p">(</span><span class="n">g</span><span class="o">.</span><span class="n">_Graph__graph</span><span class="p">,</span> <span class="n">_prop</span><span class="p">(</span><span class="s1">&#39;e&#39;</span><span class="p">,</span> <span class="n">g</span><span class="p">,</span> <span class="n">eprop</span><span class="p">),</span>
                              <span class="n">_prop</span><span class="p">(</span><span class="s1">&#39;e&#39;</span><span class="p">,</span> <span class="n">g</span><span class="p">,</span> <span class="n">heprop</span><span class="p">),</span> <span class="n">hdict</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">vprop</span><span class="p">,</span> <span class="n">hvprop</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">vprops</span><span class="p">,</span> <span class="n">hvprops</span><span class="p">):</span>
        <span class="n">g</span> <span class="o">=</span> <span class="n">vprop</span><span class="o">.</span><span class="n">get_graph</span><span class="p">()</span>
        <span class="n">g</span> <span class="o">=</span> <span class="n">GraphView</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">directed</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">skip_properties</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">libcore</span><span class="o">.</span><span class="n">perfect_vhash</span><span class="p">(</span><span class="n">g</span><span class="o">.</span><span class="n">_Graph__graph</span><span class="p">,</span> <span class="n">_prop</span><span class="p">(</span><span class="s1">&#39;v&#39;</span><span class="p">,</span> <span class="n">g</span><span class="p">,</span> <span class="n">vprop</span><span class="p">),</span>
                              <span class="n">_prop</span><span class="p">(</span><span class="s1">&#39;v&#39;</span><span class="p">,</span> <span class="n">g</span><span class="p">,</span> <span class="n">hvprop</span><span class="p">),</span> <span class="n">hdict</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">hprops</span></div>



<span class="k">class</span> <span class="nc">InternalPropertyDict</span><span class="p">(</span><span class="nb">dict</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Internal dictionary of property maps. It only accepts string keys and</span>
<span class="sd">    :class:`PropertyMap` instances as values.&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">g</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">g</span> <span class="o">=</span> <span class="n">weakref</span><span class="o">.</span><span class="n">ref</span><span class="p">(</span><span class="n">g</span><span class="p">)</span>
        <span class="nb">dict</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="nd">@_require</span><span class="p">(</span><span class="s2">&quot;key&quot;</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)</span>
    <span class="nd">@_require</span><span class="p">(</span><span class="s2">&quot;val&quot;</span><span class="p">,</span> <span class="n">PropertyMap</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">__setitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">val</span><span class="p">):</span>
        <span class="n">t</span><span class="p">,</span> <span class="n">k</span> <span class="o">=</span> <span class="n">key</span>
        <span class="n">u</span> <span class="o">=</span> <span class="n">val</span><span class="o">.</span><span class="n">get_graph</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">u</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Received orphaned property map&quot;</span><span class="p">)</span>
        <span class="n">g</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">g</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">u</span><span class="o">.</span><span class="n">base</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">g</span><span class="o">.</span><span class="n">base</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Received property map for graph </span><span class="si">%s</span><span class="s2"> (base: </span><span class="si">%s</span><span class="s2">), expected: </span><span class="si">%s</span><span class="s2"> (base: </span><span class="si">%s</span><span class="s2">)&quot;</span> <span class="o">%</span>
                         <span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">u</span><span class="p">),</span> <span class="nb">str</span><span class="p">(</span><span class="n">u</span><span class="o">.</span><span class="n">base</span><span class="p">),</span> <span class="nb">str</span><span class="p">(</span><span class="n">g</span><span class="p">),</span> <span class="nb">str</span><span class="p">(</span><span class="n">g</span><span class="o">.</span><span class="n">base</span><span class="p">)))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__set_property</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">val</span><span class="p">)</span>

    <span class="nd">@_limit_args</span><span class="p">({</span><span class="s2">&quot;t&quot;</span><span class="p">:</span> <span class="p">[</span><span class="s2">&quot;v&quot;</span><span class="p">,</span> <span class="s2">&quot;e&quot;</span><span class="p">,</span> <span class="s2">&quot;g&quot;</span><span class="p">]})</span>
    <span class="nd">@_require</span><span class="p">(</span><span class="s2">&quot;key&quot;</span><span class="p">,</span> <span class="nb">str</span><span class="p">,</span> <span class="n">unicode</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">__set_property</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">v</span><span class="p">):</span>
        <span class="nb">dict</span><span class="o">.</span><span class="fm">__setitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">key</span><span class="p">),</span> <span class="n">v</span><span class="p">)</span>

    <span class="nd">@_require</span><span class="p">(</span><span class="s2">&quot;key&quot;</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">__delitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
        <span class="nb">dict</span><span class="o">.</span><span class="fm">__delitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">)</span>

    <span class="nd">@_require</span><span class="p">(</span><span class="s2">&quot;key&quot;</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">setdefault</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">default</span><span class="p">,</span> <span class="n">PropertyMap</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;default parameter must be of type PropertyMap, not: </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="nb">type</span><span class="p">(</span><span class="n">default</span><span class="p">))</span>
        <span class="n">v</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">v</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">v</span> <span class="o">=</span> <span class="n">default</span>
        <span class="k">return</span> <span class="n">v</span>

    <span class="k">if</span> <span class="n">sys</span><span class="o">.</span><span class="n">version_info</span> <span class="o">&lt;</span> <span class="p">(</span><span class="mi">3</span><span class="p">,):</span>
        <span class="k">def</span> <span class="nf">update</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
            <span class="n">temp</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">temp</span><span class="o">.</span><span class="n">iteritems</span><span class="p">():</span>
                <span class="bp">self</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">v</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">def</span> <span class="nf">update</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
            <span class="n">temp</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">temp</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="bp">self</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">v</span>


<span class="k">class</span> <span class="nc">PropertyDict</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Wrapper for the dict of vertex, graph or edge properties, which sets the</span>
<span class="sd">    value on the property map when changed in the dict.</span>

<span class="sd">    For convenience, the dictionary entries are also available via attributes.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">properties</span><span class="p">,</span> <span class="n">t</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">PropertyDict</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__setattr__</span><span class="p">(</span><span class="s2">&quot;properties&quot;</span><span class="p">,</span> <span class="n">properties</span><span class="p">)</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">PropertyDict</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__setattr__</span><span class="p">(</span><span class="s2">&quot;t&quot;</span><span class="p">,</span> <span class="n">t</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__contains__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">t</span><span class="p">,</span> <span class="n">key</span><span class="p">)</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">properties</span>

    <span class="k">def</span> <span class="nf">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">t</span> <span class="o">==</span> <span class="s2">&quot;g&quot;</span><span class="p">:</span>
            <span class="n">p</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">properties</span><span class="p">[(</span><span class="bp">self</span><span class="o">.</span><span class="n">t</span><span class="p">,</span> <span class="n">key</span><span class="p">)]</span>
            <span class="k">return</span> <span class="n">p</span><span class="p">[</span><span class="n">p</span><span class="o">.</span><span class="n">get_graph</span><span class="p">()]</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">properties</span><span class="p">[(</span><span class="bp">self</span><span class="o">.</span><span class="n">t</span><span class="p">,</span> <span class="n">key</span><span class="p">)]</span>

    <span class="k">def</span> <span class="nf">get</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>
        <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">default</span>

    <span class="k">def</span> <span class="nf">pop</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>
            <span class="k">del</span> <span class="bp">self</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>
            <span class="k">return</span> <span class="n">x</span>
        <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">default</span>

    <span class="k">def</span> <span class="nf">__setitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">val</span><span class="p">):</span>
        <span class="n">k</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">t</span><span class="p">,</span> <span class="n">key</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">t</span> <span class="o">==</span> <span class="s2">&quot;g&quot;</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="n">PropertyMap</span><span class="p">)</span> <span class="ow">and</span> <span class="n">k</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">properties</span><span class="p">:</span>
            <span class="n">p</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">properties</span><span class="p">[</span><span class="n">k</span><span class="p">]</span>
            <span class="n">p</span><span class="p">[</span><span class="n">p</span><span class="o">.</span><span class="n">get_graph</span><span class="p">()]</span> <span class="o">=</span> <span class="n">val</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="n">PropertyMap</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;value must be of type PropertyMap, not </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="nb">str</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">val</span><span class="p">)))</span>
            <span class="k">if</span> <span class="n">val</span><span class="o">.</span><span class="n">key_type</span><span class="p">()</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">t</span><span class="p">:</span>
                <span class="k">def</span> <span class="nf">name</span><span class="p">(</span><span class="n">t</span><span class="p">):</span>
                    <span class="k">if</span> <span class="n">t</span> <span class="o">==</span> <span class="s2">&quot;e&quot;</span><span class="p">:</span>
                        <span class="k">return</span> <span class="s2">&quot;Edge&quot;</span>
                    <span class="k">if</span> <span class="n">t</span> <span class="o">==</span> <span class="s2">&quot;v&quot;</span><span class="p">:</span>
                        <span class="k">return</span> <span class="s2">&quot;Vertex&quot;</span>
                    <span class="k">if</span> <span class="n">t</span> <span class="o">==</span> <span class="s2">&quot;g&quot;</span><span class="p">:</span>
                        <span class="k">return</span> <span class="s2">&quot;Graph&quot;</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;wanted a property map of type &#39;</span><span class="si">%s</span><span class="s2">&#39;, not &#39;</span><span class="si">%s</span><span class="s2">&#39;&quot;</span> <span class="o">%</span>
                                 <span class="p">(</span><span class="n">name</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">t</span><span class="p">),</span> <span class="n">name</span><span class="p">(</span><span class="n">val</span><span class="o">.</span><span class="n">key_type</span><span class="p">())))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">properties</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">val</span>

    <span class="k">def</span> <span class="nf">setdefault</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">properties</span><span class="o">.</span><span class="n">setdefault</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">t</span><span class="p">,</span> <span class="n">key</span><span class="p">),</span> <span class="n">default</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">sys</span><span class="o">.</span><span class="n">version_info</span> <span class="o">&lt;</span> <span class="p">(</span><span class="mi">3</span><span class="p">,):</span>
        <span class="k">def</span> <span class="nf">update</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
            <span class="n">temp</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">temp</span><span class="o">.</span><span class="n">iteritems</span><span class="p">():</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">properties</span><span class="p">[(</span><span class="bp">self</span><span class="o">.</span><span class="n">t</span><span class="p">,</span> <span class="n">k</span><span class="p">)]</span> <span class="o">=</span> <span class="n">v</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">def</span> <span class="nf">update</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
            <span class="n">temp</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">temp</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">properties</span><span class="p">[(</span><span class="bp">self</span><span class="o">.</span><span class="n">t</span><span class="p">,</span> <span class="n">k</span><span class="p">)]</span> <span class="o">=</span> <span class="n">v</span>

    <span class="k">def</span> <span class="nf">__delitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
        <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">properties</span><span class="p">[(</span><span class="bp">self</span><span class="o">.</span><span class="n">t</span><span class="p">,</span> <span class="n">key</span><span class="p">)]</span>

    <span class="k">def</span> <span class="nf">clear</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">keys</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">properties</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">k</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">t</span><span class="p">:</span>
                <span class="n">keys</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">k</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">keys</span><span class="p">:</span>
            <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">properties</span><span class="p">[(</span><span class="bp">self</span><span class="o">.</span><span class="n">t</span><span class="p">,</span> <span class="n">k</span><span class="p">)]</span>

    <span class="k">def</span> <span class="nf">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">properties</span><span class="o">.</span><span class="n">iterkeys</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">k</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">t</span><span class="p">:</span>
                <span class="n">count</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">return</span> <span class="n">count</span>

    <span class="k">def</span> <span class="nf">__iter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">iterkeys</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">iterkeys</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">properties</span><span class="o">.</span><span class="n">iterkeys</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">k</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">t</span><span class="p">:</span>
                <span class="k">yield</span> <span class="n">k</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">items</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">properties</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">k</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">t</span><span class="p">:</span>
                <span class="k">yield</span> <span class="n">k</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">v</span>

    <span class="k">if</span> <span class="n">sys</span><span class="o">.</span><span class="n">version_info</span> <span class="o">&lt;</span> <span class="p">(</span><span class="mi">3</span><span class="p">,):</span>
        <span class="k">def</span> <span class="nf">has_key</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">properties</span><span class="o">.</span><span class="n">has_key</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">t</span><span class="p">,</span> <span class="n">key</span><span class="p">))</span>

        <span class="k">def</span> <span class="nf">iteritems</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">properties</span><span class="o">.</span><span class="n">iteritems</span><span class="p">():</span>
                <span class="k">if</span> <span class="n">k</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">t</span><span class="p">:</span>
                    <span class="k">yield</span> <span class="n">k</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">v</span>

    <span class="k">def</span> <span class="nf">itervalues</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">properties</span><span class="o">.</span><span class="n">iteritems</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">k</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">t</span><span class="p">:</span>
                <span class="k">yield</span> <span class="n">v</span>

    <span class="k">def</span> <span class="nf">keys</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">k</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">properties</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span> <span class="k">if</span> <span class="n">k</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">t</span><span class="p">]</span>

    <span class="k">if</span> <span class="n">sys</span><span class="o">.</span><span class="n">version_info</span> <span class="o">&lt;</span> <span class="p">(</span><span class="mi">3</span><span class="p">,):</span>
        <span class="k">def</span> <span class="nf">values</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
            <span class="k">return</span> <span class="p">[</span><span class="n">v</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">properties</span><span class="o">.</span><span class="n">iteritems</span><span class="p">()</span> <span class="k">if</span> <span class="n">k</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">t</span><span class="p">]</span>
        <span class="k">def</span> <span class="nf">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
            <span class="n">temp</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">([(</span><span class="n">k</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">v</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">properties</span><span class="o">.</span><span class="n">iteritems</span><span class="p">()</span> <span class="k">if</span> <span class="n">k</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">t</span><span class="p">])</span>
            <span class="k">return</span> <span class="nb">repr</span><span class="p">(</span><span class="n">temp</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">def</span> <span class="nf">values</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
            <span class="k">return</span> <span class="p">[</span><span class="n">v</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">properties</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">if</span> <span class="n">k</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">t</span><span class="p">]</span>
        <span class="k">def</span> <span class="nf">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
            <span class="n">temp</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">([(</span><span class="n">k</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">v</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">properties</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">if</span> <span class="n">k</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">t</span><span class="p">])</span>
            <span class="k">return</span> <span class="nb">repr</span><span class="p">(</span><span class="n">temp</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">__getattr__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">attr</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="fm">__getitem__</span><span class="p">(</span><span class="n">attr</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__setattr__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">attr</span><span class="p">,</span> <span class="n">val</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="fm">__setitem__</span><span class="p">(</span><span class="n">attr</span><span class="p">,</span> <span class="n">val</span><span class="p">)</span>


<span class="c1">################################################################################</span>
<span class="c1"># Graph class</span>
<span class="c1"># The main graph interface</span>
<span class="c1">################################################################################</span>

<span class="kn">from</span> <span class="nn">.libgraph_tool_core</span> <span class="k">import</span> <span class="n">Vertex</span><span class="p">,</span> <span class="n">EdgeBase</span><span class="p">,</span> <span class="n">Vector_bool</span><span class="p">,</span> <span class="n">Vector_int16_t</span><span class="p">,</span> \
    <span class="n">Vector_int32_t</span><span class="p">,</span> <span class="n">Vector_int64_t</span><span class="p">,</span> <span class="n">Vector_double</span><span class="p">,</span> <span class="n">Vector_long_double</span><span class="p">,</span> \
    <span class="n">Vector_string</span><span class="p">,</span> <span class="n">Vector_size_t</span><span class="p">,</span> <span class="n">new_vertex_property</span><span class="p">,</span> <span class="n">new_edge_property</span><span class="p">,</span> \
    <span class="n">new_graph_property</span>


<div class="viewcode-block" id="Graph"><a class="viewcode-back" href="https://graph-tool.skewed.de/static/doc/graph_tool.html#graph_tool.Graph">[docs]</a><span class="k">class</span> <span class="nc">Graph</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Generic multigraph class.</span>

<span class="sd">    This class encapsulates either a directed multigraph (default or if</span>
<span class="sd">    ``directed=True``) or an undirected multigraph (if ``directed=False``),</span>
<span class="sd">    with optional internal edge, vertex or graph properties.</span>

<span class="sd">    If ``g`` is specified, the graph (and its internal properties) will be</span>
<span class="sd">    copied.</span>

<span class="sd">    If ``prune`` is set to ``True``, and ``g`` is specified, only the filtered</span>
<span class="sd">    graph will be copied, and the new graph object will not be</span>
<span class="sd">    filtered. Optionally, a tuple of three booleans can be passed as value to</span>
<span class="sd">    ``prune``, to specify a different behavior to vertex, edge, and reversal</span>
<span class="sd">    filters, respectively.</span>

<span class="sd">    If ``vorder`` is specified, it should correspond to a vertex</span>
<span class="sd">    :class:`~graph_tool.PropertyMap` specifying the ordering of the vertices in</span>
<span class="sd">    the copied graph.</span>

<span class="sd">    The graph is implemented as an `adjacency list`_, where both vertex and edge</span>
<span class="sd">    lists are C++ STL vectors.</span>

<span class="sd">    .. _adjacency list: http://en.wikipedia.org/wiki/Adjacency_list</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">g</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">directed</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">prune</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">vorder</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__properties</span> <span class="o">=</span> <span class="n">InternalPropertyDict</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__graph_properties</span> <span class="o">=</span> <span class="n">PropertyDict</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__properties</span><span class="p">,</span> <span class="s2">&quot;g&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__vertex_properties</span> <span class="o">=</span> <span class="n">PropertyDict</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__properties</span><span class="p">,</span> <span class="s2">&quot;v&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__edge_properties</span> <span class="o">=</span> <span class="n">PropertyDict</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__properties</span><span class="p">,</span> <span class="s2">&quot;e&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__known_properties</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__filter_state</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;reversed&quot;</span><span class="p">:</span> <span class="kc">False</span><span class="p">,</span>
                               <span class="s2">&quot;edge_filter&quot;</span><span class="p">:</span> <span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="kc">False</span><span class="p">),</span>
                               <span class="s2">&quot;vertex_filter&quot;</span><span class="p">:</span> <span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="kc">False</span><span class="p">),</span>
                               <span class="s2">&quot;directed&quot;</span><span class="p">:</span> <span class="kc">True</span><span class="p">}</span>
        <span class="k">if</span> <span class="n">g</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__graph</span> <span class="o">=</span> <span class="n">libcore</span><span class="o">.</span><span class="n">GraphInterface</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">set_directed</span><span class="p">(</span><span class="n">directed</span><span class="p">)</span>

            <span class="c1"># internal index maps</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__vertex_index</span> <span class="o">=</span> \
                     <span class="n">PropertyMap</span><span class="p">(</span><span class="n">libcore</span><span class="o">.</span><span class="n">get_vertex_index</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__graph</span><span class="p">),</span> <span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;v&quot;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__edge_index</span> <span class="o">=</span> \
                     <span class="n">PropertyMap</span><span class="p">(</span><span class="n">libcore</span><span class="o">.</span><span class="n">get_edge_index</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__graph</span><span class="p">),</span> <span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;e&quot;</span><span class="p">)</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">prune</span><span class="p">,</span> <span class="nb">bool</span><span class="p">):</span>
                <span class="n">vprune</span> <span class="o">=</span> <span class="n">eprune</span> <span class="o">=</span> <span class="n">rprune</span> <span class="o">=</span> <span class="n">prune</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">vprune</span><span class="p">,</span> <span class="n">eprune</span><span class="p">,</span> <span class="n">rprune</span> <span class="o">=</span> <span class="n">prune</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">vprune</span> <span class="ow">or</span> <span class="n">eprune</span> <span class="ow">or</span> <span class="n">rprune</span><span class="p">):</span>
                <span class="n">gv</span> <span class="o">=</span> <span class="n">GraphView</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">skip_vfilt</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                               <span class="n">skip_efilt</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">rprune</span><span class="p">:</span>
                    <span class="n">gv</span><span class="o">.</span><span class="n">set_reversed</span><span class="p">(</span><span class="kc">False</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">gv</span> <span class="o">=</span> <span class="n">g</span>

            <span class="c1"># The filters may or may not not be in the internal property maps</span>
            <span class="n">vfilt</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">get_vertex_filter</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">efilt</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">get_edge_filter</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span>

            <span class="k">if</span> <span class="p">(</span><span class="n">vorder</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="p">((</span><span class="n">vfilt</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">efilt</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">or</span>
                                    <span class="p">(</span><span class="ow">not</span> <span class="n">vprune</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">eprune</span><span class="p">))):</span>
                <span class="c1"># Do a simpler, faster copy.</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">__graph</span> <span class="o">=</span> <span class="n">libcore</span><span class="o">.</span><span class="n">GraphInterface</span><span class="p">(</span><span class="n">gv</span><span class="o">.</span><span class="n">__graph</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span>
                                                      <span class="p">[],</span> <span class="p">[],</span> <span class="kc">None</span><span class="p">)</span>

                <span class="c1"># internal index maps</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">__vertex_index</span> <span class="o">=</span> \
                         <span class="n">PropertyMap</span><span class="p">(</span><span class="n">libcore</span><span class="o">.</span><span class="n">get_vertex_index</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__graph</span><span class="p">),</span> <span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;v&quot;</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">__edge_index</span> <span class="o">=</span> \
                         <span class="n">PropertyMap</span><span class="p">(</span><span class="n">libcore</span><span class="o">.</span><span class="n">get_edge_index</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__graph</span><span class="p">),</span> <span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;e&quot;</span><span class="p">)</span>

                <span class="n">nvfilt</span> <span class="o">=</span> <span class="n">nefilt</span> <span class="o">=</span> <span class="kc">None</span>
                <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">m</span> <span class="ow">in</span> <span class="n">g</span><span class="o">.</span><span class="n">properties</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                    <span class="n">nmap</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy_property</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">g</span><span class="o">=</span><span class="n">gv</span><span class="p">)</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">properties</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">nmap</span>
                    <span class="k">if</span> <span class="n">m</span> <span class="ow">is</span> <span class="n">vfilt</span><span class="p">:</span>
                        <span class="n">nvfilt</span> <span class="o">=</span> <span class="n">nmap</span>
                    <span class="k">if</span> <span class="n">m</span> <span class="ow">is</span> <span class="n">efilt</span><span class="p">:</span>
                        <span class="n">nefilt</span> <span class="o">=</span> <span class="n">nmap</span>
                <span class="k">if</span> <span class="n">vfilt</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">nvfilt</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                        <span class="n">nvfilt</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy_property</span><span class="p">(</span><span class="n">vfilt</span><span class="p">,</span> <span class="n">g</span><span class="o">=</span><span class="n">gv</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">efilt</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">nefilt</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                        <span class="n">nefilt</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy_property</span><span class="p">(</span><span class="n">efilt</span><span class="p">,</span> <span class="n">g</span><span class="o">=</span><span class="n">gv</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">set_filters</span><span class="p">(</span><span class="n">nefilt</span><span class="p">,</span> <span class="n">nvfilt</span><span class="p">,</span>
                                 <span class="n">inverted_edges</span><span class="o">=</span><span class="n">g</span><span class="o">.</span><span class="n">get_edge_filter</span><span class="p">()[</span><span class="mi">1</span><span class="p">],</span>
                                 <span class="n">inverted_vertices</span><span class="o">=</span><span class="n">g</span><span class="o">.</span><span class="n">get_vertex_filter</span><span class="p">()[</span><span class="mi">1</span><span class="p">])</span>
            <span class="k">else</span><span class="p">:</span>

                <span class="c1"># Copy all internal properties from original graph.</span>
                <span class="n">vprops</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="n">eprops</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="n">ef_pos</span> <span class="o">=</span> <span class="n">vf_pos</span> <span class="o">=</span> <span class="kc">None</span>
                <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">m</span> <span class="ow">in</span> <span class="n">gv</span><span class="o">.</span><span class="n">vertex_properties</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="n">m</span><span class="o">.</span><span class="n">is_writable</span><span class="p">():</span>
                        <span class="n">m</span> <span class="o">=</span> <span class="n">m</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="s2">&quot;int32_t&quot;</span><span class="p">)</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="n">vprune</span> <span class="ow">and</span> <span class="n">m</span> <span class="ow">is</span> <span class="n">vfilt</span><span class="p">:</span>
                        <span class="n">vf_pos</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">vprops</span><span class="p">)</span>
                    <span class="n">vprops</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">_prop</span><span class="p">(</span><span class="s2">&quot;v&quot;</span><span class="p">,</span> <span class="n">gv</span><span class="p">,</span> <span class="n">m</span><span class="p">),</span> <span class="n">libcore</span><span class="o">.</span><span class="n">any</span><span class="p">()])</span>
                <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">m</span> <span class="ow">in</span> <span class="n">gv</span><span class="o">.</span><span class="n">edge_properties</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="n">m</span><span class="o">.</span><span class="n">is_writable</span><span class="p">():</span>
                        <span class="n">m</span> <span class="o">=</span> <span class="n">m</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="s2">&quot;int32_t&quot;</span><span class="p">)</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="n">eprune</span> <span class="ow">and</span> <span class="n">m</span> <span class="ow">is</span> <span class="n">efilt</span><span class="p">:</span>
                        <span class="n">ef_pos</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">eprops</span><span class="p">)</span>
                    <span class="n">eprops</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">_prop</span><span class="p">(</span><span class="s2">&quot;e&quot;</span><span class="p">,</span> <span class="n">gv</span><span class="p">,</span> <span class="n">m</span><span class="p">),</span> <span class="n">libcore</span><span class="o">.</span><span class="n">any</span><span class="p">()])</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">vprune</span> <span class="ow">and</span> <span class="n">vf_pos</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">vfilt</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">vf_pos</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">vprops</span><span class="p">)</span>
                    <span class="n">vprops</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">_prop</span><span class="p">(</span><span class="s2">&quot;v&quot;</span><span class="p">,</span> <span class="n">gv</span><span class="p">,</span> <span class="n">vfilt</span><span class="p">),</span> <span class="n">libcore</span><span class="o">.</span><span class="n">any</span><span class="p">()])</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">eprune</span> <span class="ow">and</span> <span class="n">ef_pos</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">efilt</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">ef_pos</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">eprops</span><span class="p">)</span>
                    <span class="n">eprops</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">_prop</span><span class="p">(</span><span class="s2">&quot;e&quot;</span><span class="p">,</span> <span class="n">gv</span><span class="p">,</span> <span class="n">efilt</span><span class="p">),</span> <span class="n">libcore</span><span class="o">.</span><span class="n">any</span><span class="p">()])</span>

                <span class="c1"># The vertex ordering</span>
                <span class="k">if</span> <span class="n">vorder</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">vorder</span> <span class="o">=</span> <span class="n">gv</span><span class="o">.</span><span class="n">new_vertex_property</span><span class="p">(</span><span class="s2">&quot;int&quot;</span><span class="p">)</span>
                    <span class="n">vorder</span><span class="o">.</span><span class="n">fa</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">gv</span><span class="o">.</span><span class="n">num_vertices</span><span class="p">())</span>

                <span class="c1"># The actual copying of the graph and property maps</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">__graph</span> <span class="o">=</span> <span class="n">libcore</span><span class="o">.</span><span class="n">GraphInterface</span><span class="p">(</span><span class="n">gv</span><span class="o">.</span><span class="n">__graph</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span>
                                                      <span class="n">vprops</span><span class="p">,</span>
                                                      <span class="n">eprops</span><span class="p">,</span>
                                                      <span class="n">_prop</span><span class="p">(</span><span class="s2">&quot;v&quot;</span><span class="p">,</span> <span class="n">gv</span><span class="p">,</span> <span class="n">vorder</span><span class="p">))</span>
                <span class="c1"># internal index maps</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">__vertex_index</span> <span class="o">=</span> \
                         <span class="n">PropertyMap</span><span class="p">(</span><span class="n">libcore</span><span class="o">.</span><span class="n">get_vertex_index</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__graph</span><span class="p">),</span> <span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;v&quot;</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">__edge_index</span> <span class="o">=</span> \
                         <span class="n">PropertyMap</span><span class="p">(</span><span class="n">libcore</span><span class="o">.</span><span class="n">get_edge_index</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__graph</span><span class="p">),</span> <span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;e&quot;</span><span class="p">)</span>

                <span class="c1"># Put the copied properties in the internal dictionary</span>
                <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">m</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">gv</span><span class="o">.</span><span class="n">vertex_properties</span><span class="o">.</span><span class="n">items</span><span class="p">()):</span>
                    <span class="n">pmap</span> <span class="o">=</span> <span class="n">new_vertex_property</span><span class="p">(</span><span class="n">m</span><span class="o">.</span><span class="n">value_type</span><span class="p">()</span> <span class="k">if</span> <span class="n">m</span><span class="o">.</span><span class="n">is_writable</span><span class="p">()</span> <span class="k">else</span> <span class="s2">&quot;int32_t&quot;</span><span class="p">,</span>
                                               <span class="bp">self</span><span class="o">.</span><span class="n">__graph</span><span class="o">.</span><span class="n">get_vertex_index</span><span class="p">(),</span>
                                               <span class="n">vprops</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">])</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">vertex_properties</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">PropertyMap</span><span class="p">(</span><span class="n">pmap</span><span class="p">,</span> <span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;v&quot;</span><span class="p">)</span>

                <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">m</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">gv</span><span class="o">.</span><span class="n">edge_properties</span><span class="o">.</span><span class="n">items</span><span class="p">()):</span>
                    <span class="n">pmap</span> <span class="o">=</span> <span class="n">new_edge_property</span><span class="p">(</span><span class="n">m</span><span class="o">.</span><span class="n">value_type</span><span class="p">()</span> <span class="k">if</span> <span class="n">m</span><span class="o">.</span><span class="n">is_writable</span><span class="p">()</span> <span class="k">else</span> <span class="s2">&quot;int32_t&quot;</span><span class="p">,</span>
                                             <span class="bp">self</span><span class="o">.</span><span class="n">__graph</span><span class="o">.</span><span class="n">get_edge_index</span><span class="p">(),</span>
                                             <span class="n">eprops</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">])</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">edge_properties</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">PropertyMap</span><span class="p">(</span><span class="n">pmap</span><span class="p">,</span> <span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;e&quot;</span><span class="p">)</span>

                <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">gv</span><span class="o">.</span><span class="n">graph_properties</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                    <span class="n">new_p</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">new_graph_property</span><span class="p">(</span><span class="n">v</span><span class="o">.</span><span class="n">value_type</span><span class="p">())</span>
                    <span class="n">new_p</span><span class="p">[</span><span class="bp">self</span><span class="p">]</span> <span class="o">=</span> <span class="n">v</span><span class="p">[</span><span class="n">gv</span><span class="p">]</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">graph_properties</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_p</span>

                <span class="n">epmap</span> <span class="o">=</span> <span class="n">vpmap</span> <span class="o">=</span> <span class="kc">None</span>
                <span class="k">if</span> <span class="n">vf_pos</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">vpmap</span> <span class="o">=</span> <span class="n">new_vertex_property</span><span class="p">(</span><span class="s2">&quot;bool&quot;</span><span class="p">,</span>
                                                <span class="bp">self</span><span class="o">.</span><span class="n">__graph</span><span class="o">.</span><span class="n">get_vertex_index</span><span class="p">(),</span>
                                                <span class="n">vprops</span><span class="p">[</span><span class="n">vf_pos</span><span class="p">][</span><span class="mi">1</span><span class="p">])</span>
                    <span class="n">vpmap</span> <span class="o">=</span> <span class="n">PropertyMap</span><span class="p">(</span><span class="n">vpmap</span><span class="p">,</span> <span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;v&quot;</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">ef_pos</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">epmap</span> <span class="o">=</span> <span class="n">new_edge_property</span><span class="p">(</span><span class="s2">&quot;bool&quot;</span><span class="p">,</span>
                                              <span class="bp">self</span><span class="o">.</span><span class="n">__graph</span><span class="o">.</span><span class="n">get_edge_index</span><span class="p">(),</span>
                                              <span class="n">eprops</span><span class="p">[</span><span class="n">ef_pos</span><span class="p">][</span><span class="mi">1</span><span class="p">])</span>
                    <span class="n">epmap</span> <span class="o">=</span> <span class="n">PropertyMap</span><span class="p">(</span><span class="n">epmap</span><span class="p">,</span> <span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;e&quot;</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">set_filters</span><span class="p">(</span><span class="n">epmap</span><span class="p">,</span> <span class="n">vpmap</span><span class="p">,</span>
                                 <span class="n">inverted_edges</span><span class="o">=</span><span class="n">g</span><span class="o">.</span><span class="n">get_edge_filter</span><span class="p">()[</span><span class="mi">1</span><span class="p">],</span>
                                 <span class="n">inverted_vertices</span><span class="o">=</span><span class="n">g</span><span class="o">.</span><span class="n">get_vertex_filter</span><span class="p">()[</span><span class="mi">1</span><span class="p">])</span>

            <span class="k">if</span> <span class="ow">not</span> <span class="n">rprune</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">set_reversed</span><span class="p">(</span><span class="n">g</span><span class="o">.</span><span class="n">is_reversed</span><span class="p">())</span>

            <span class="c1"># directedness is always a filter</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">set_directed</span><span class="p">(</span><span class="n">g</span><span class="o">.</span><span class="n">is_directed</span><span class="p">())</span>

    <span class="k">def</span> <span class="nf">_get_any</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__graph</span><span class="o">.</span><span class="n">get_graph_view</span><span class="p">()</span>

<div class="viewcode-block" id="Graph.copy"><a class="viewcode-back" href="https://graph-tool.skewed.de/static/doc/graph_tool.html#graph_tool.Graph.copy">[docs]</a>    <span class="k">def</span> <span class="nf">copy</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return a deep copy of self. All :ref:`internal property maps &lt;sec_internal_props&gt;`</span>
<span class="sd">        are also copied.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">Graph</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">__copy__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">__deepcopy__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">memo</span><span class="p">):</span>
        <span class="n">g</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">prop</span> <span class="ow">in</span> <span class="p">[</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">g</span><span class="o">.</span><span class="n">properties</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
                        <span class="k">if</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">value_type</span><span class="p">()</span> <span class="o">==</span> <span class="s2">&quot;python::object&quot;</span><span class="p">]:</span>
            <span class="n">g</span><span class="o">.</span><span class="n">properties</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">prop</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">g</span>

    <span class="k">def</span> <span class="nf">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># provide more useful information</span>
        <span class="n">d</span> <span class="o">=</span> <span class="s2">&quot;directed&quot;</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_directed</span><span class="p">()</span> <span class="k">else</span> <span class="s2">&quot;undirected&quot;</span>
        <span class="n">fr</span> <span class="o">=</span> <span class="s2">&quot;, reversed&quot;</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_reversed</span><span class="p">()</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_directed</span><span class="p">()</span> <span class="k">else</span> <span class="s2">&quot;&quot;</span>
        <span class="n">f</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_edge_filter</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">f</span> <span class="o">+=</span> <span class="s2">&quot;, edges filtered by </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">get_edge_filter</span><span class="p">()))</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_vertex_filter</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">f</span> <span class="o">+=</span> <span class="s2">&quot;, vertices filtered by </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">get_vertex_filter</span><span class="p">()))</span>
        <span class="n">n</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_vertices</span><span class="p">()</span>
        <span class="n">e</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_edges</span><span class="p">()</span>
        <span class="k">return</span> <span class="s2">&quot;&lt;</span><span class="si">%s</span><span class="s2"> object, </span><span class="si">%s%s</span><span class="s2">, with </span><span class="si">%d</span><span class="s2"> </span><span class="si">%s</span><span class="s2"> and </span><span class="si">%d</span><span class="s2"> edge</span><span class="si">%s%s</span><span class="s2"> at 0x</span><span class="si">%x</span><span class="s2">&gt;&quot;</span>\
               <span class="o">%</span> <span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="n">fr</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span>
                  <span class="s2">&quot;vertex&quot;</span> <span class="k">if</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">1</span> <span class="k">else</span> <span class="s2">&quot;vertices&quot;</span><span class="p">,</span> <span class="n">e</span><span class="p">,</span> <span class="s2">&quot;&quot;</span> <span class="k">if</span> <span class="n">e</span> <span class="o">==</span> <span class="mi">1</span> <span class="k">else</span> <span class="s2">&quot;s&quot;</span><span class="p">,</span>
                  <span class="n">f</span><span class="p">,</span> <span class="nb">id</span><span class="p">(</span><span class="bp">self</span><span class="p">))</span>

    <span class="c1"># Graph access</span>
    <span class="c1"># ============</span>

<div class="viewcode-block" id="Graph.vertices"><a class="viewcode-back" href="https://graph-tool.skewed.de/static/doc/graph_tool.html#graph_tool.Graph.vertices">[docs]</a>    <span class="k">def</span> <span class="nf">vertices</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return an :meth:`iterator &lt;iterator.__iter__&gt;` over the vertices.</span>

<span class="sd">        .. note::</span>

<span class="sd">           The order of the vertices traversed by the iterator **always**</span>
<span class="sd">           corresponds to the vertex index ordering, as given by the</span>
<span class="sd">           :attr:`~graph_tool.Graph.vertex_index` property map.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; g = gt.Graph()</span>
<span class="sd">        &gt;&gt;&gt; vlist = list(g.add_vertex(5))</span>
<span class="sd">        &gt;&gt;&gt; vlist2 = []</span>
<span class="sd">        &gt;&gt;&gt; for v in g.vertices():</span>
<span class="sd">        ...     vlist2.append(v)</span>
<span class="sd">        ...</span>
<span class="sd">        &gt;&gt;&gt; assert(vlist == vlist2)</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">libcore</span><span class="o">.</span><span class="n">get_vertices</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__graph</span><span class="p">)</span></div>

<div class="viewcode-block" id="Graph.get_vertices"><a class="viewcode-back" href="https://graph-tool.skewed.de/static/doc/graph_tool.html#graph_tool.Graph.get_vertices">[docs]</a>    <span class="k">def</span> <span class="nf">get_vertices</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return a :class:`numpy.ndarray` with the vertex indices.</span>

<span class="sd">        .. note::</span>

<span class="sd">           The order of the vertices is identical to</span>
<span class="sd">           :meth:`~graph_tool.Graph.vertices`.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; g = gt.Graph()</span>
<span class="sd">        &gt;&gt;&gt; g.add_vertex(5)</span>
<span class="sd">        &lt;...&gt;</span>
<span class="sd">        &gt;&gt;&gt; g.get_vertices()</span>
<span class="sd">        array([0, 1, 2, 3, 4], dtype=uint64)</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">libcore</span><span class="o">.</span><span class="n">get_vertex_list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__graph</span><span class="p">)</span></div>

<div class="viewcode-block" id="Graph.vertex"><a class="viewcode-back" href="https://graph-tool.skewed.de/static/doc/graph_tool.html#graph_tool.Graph.vertex">[docs]</a>    <span class="k">def</span> <span class="nf">vertex</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">use_index</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">add_missing</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the vertex with index ``i``. If ``use_index=False``, the</span>
<span class="sd">        ``i``-th vertex is returned (which can differ from the vertex with index</span>
<span class="sd">        ``i`` in case of filtered graphs).</span>

<span class="sd">        If ``add_missing == True``, and the vertex does not exist in the graph,</span>
<span class="sd">        the necessary number of missing vertices are inserted, and the new</span>
<span class="sd">        vertex is returned.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">v</span> <span class="o">=</span> <span class="n">libcore</span><span class="o">.</span><span class="n">get_vertex</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__graph</span><span class="p">,</span> <span class="nb">int</span><span class="p">(</span><span class="n">i</span><span class="p">),</span> <span class="n">use_index</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">v</span><span class="o">.</span><span class="n">is_valid</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">add_missing</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">add_vertex</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_vertices</span><span class="p">(</span><span class="n">use_index</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">vertex</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">i</span><span class="p">),</span> <span class="n">use_index</span><span class="p">)</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Invalid vertex index: </span><span class="si">%d</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="nb">int</span><span class="p">(</span><span class="n">i</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">v</span></div>

<div class="viewcode-block" id="Graph.edge"><a class="viewcode-back" href="https://graph-tool.skewed.de/static/doc/graph_tool.html#graph_tool.Graph.edge">[docs]</a>    <span class="k">def</span> <span class="nf">edge</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">all_edges</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">add_missing</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the edge from vertex ``s`` to ``t``, if it exists. If</span>
<span class="sd">        ``all_edges=True`` then a list is returned with all the parallel edges</span>
<span class="sd">        from ``s`` to ``t``, otherwise only one edge is returned.</span>

<span class="sd">        If ``add_missing == True``, a new edge is created and returned, if none</span>
<span class="sd">        currently exists.</span>

<span class="sd">        This operation will take :math:`O(min(k(s), k(t)))` time, where</span>
<span class="sd">        :math:`k(s)` and :math:`k(t)` are the out-degree and in-degree (or</span>
<span class="sd">        out-degree if undirected) of vertices :math:`s` and :math:`t`.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">s</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">vertex</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">s</span><span class="p">))</span>
        <span class="n">t</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">vertex</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">t</span><span class="p">))</span>
        <span class="n">edges</span> <span class="o">=</span> <span class="n">libcore</span><span class="o">.</span><span class="n">get_edge</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__graph</span><span class="p">,</span> <span class="nb">int</span><span class="p">(</span><span class="n">s</span><span class="p">),</span> <span class="nb">int</span><span class="p">(</span><span class="n">t</span><span class="p">),</span> <span class="n">all_edges</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">add_missing</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">edges</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">edges</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">t</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">all_edges</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">edges</span>
        <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">edges</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">edges</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span></div>

<div class="viewcode-block" id="Graph.edges"><a class="viewcode-back" href="https://graph-tool.skewed.de/static/doc/graph_tool.html#graph_tool.Graph.edges">[docs]</a>    <span class="k">def</span> <span class="nf">edges</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return an :meth:`iterator &lt;iterator.__iter__&gt;` over the edges.</span>

<span class="sd">        .. note::</span>

<span class="sd">           The order of the edges traversed by the iterator **does not**</span>
<span class="sd">           necessarily correspond to the edge index ordering, as given by the</span>
<span class="sd">           :attr:`~graph_tool.Graph.edge_index` property map. This will only</span>
<span class="sd">           happen after :meth:`~graph_tool.Graph.reindex_edges` is called, or in</span>
<span class="sd">           certain situations such as just after a graph is loaded from a</span>
<span class="sd">           file. However, further manipulation of the graph may destroy the</span>
<span class="sd">           ordering.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">libcore</span><span class="o">.</span><span class="n">get_edges</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__graph</span><span class="p">)</span></div>

<div class="viewcode-block" id="Graph.get_edges"><a class="viewcode-back" href="https://graph-tool.skewed.de/static/doc/graph_tool.html#graph_tool.Graph.get_edges">[docs]</a>    <span class="k">def</span> <span class="nf">get_edges</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return a :class:`numpy.ndarray` containing the edges. The shape of</span>
<span class="sd">        the array will be ``(E, 3)``, where ``E`` is the number of edges, and</span>
<span class="sd">        each line will contain the source, target and index of an edge.</span>

<span class="sd">        .. note::</span>

<span class="sd">           The order of the edges is identical to</span>
<span class="sd">           :meth:`~graph_tool.Graph.edges`.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; g = gt.random_graph(6, lambda: 1, directed=False)</span>
<span class="sd">        &gt;&gt;&gt; g.get_edges()</span>
<span class="sd">        array([[2, 1, 2],</span>
<span class="sd">               [3, 4, 0],</span>
<span class="sd">               [5, 0, 1]], dtype=uint64)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">edges</span> <span class="o">=</span> <span class="n">libcore</span><span class="o">.</span><span class="n">get_edge_list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__graph</span><span class="p">)</span>
        <span class="n">E</span> <span class="o">=</span> <span class="n">edges</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">//</span> <span class="mi">3</span>
        <span class="k">return</span> <span class="n">numpy</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">edges</span><span class="p">,</span> <span class="p">(</span><span class="n">E</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span></div>

<div class="viewcode-block" id="Graph.get_out_edges"><a class="viewcode-back" href="https://graph-tool.skewed.de/static/doc/graph_tool.html#graph_tool.Graph.get_out_edges">[docs]</a>    <span class="k">def</span> <span class="nf">get_out_edges</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">v</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return a :class:`numpy.ndarray` containing the out-edges of vertex ``v``. The</span>
<span class="sd">        shape of the array will be ``(k, 3)``, where ``k`` is the out-degree of</span>
<span class="sd">        ``v``, and each line will contain the source, target and index of an</span>
<span class="sd">        edge.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; g = gt.collection.data[&quot;pgp-strong-2009&quot;]</span>
<span class="sd">        &gt;&gt;&gt; g.get_out_edges(66)</span>
<span class="sd">        array([[   66,    63,  5266],</span>
<span class="sd">               [   66, 20369,  5267],</span>
<span class="sd">               [   66, 13980,  5268],</span>
<span class="sd">               [   66,  8687,  5269],</span>
<span class="sd">               [   66, 38674,  5270]], dtype=uint64)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">edges</span> <span class="o">=</span> <span class="n">libcore</span><span class="o">.</span><span class="n">get_out_edge_list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__graph</span><span class="p">,</span> <span class="nb">int</span><span class="p">(</span><span class="n">v</span><span class="p">))</span>
        <span class="n">E</span> <span class="o">=</span> <span class="n">edges</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">//</span> <span class="mi">3</span>
        <span class="k">return</span> <span class="n">numpy</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">edges</span><span class="p">,</span> <span class="p">(</span><span class="n">E</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span></div>

<div class="viewcode-block" id="Graph.get_in_edges"><a class="viewcode-back" href="https://graph-tool.skewed.de/static/doc/graph_tool.html#graph_tool.Graph.get_in_edges">[docs]</a>    <span class="k">def</span> <span class="nf">get_in_edges</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">v</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return a :class:`numpy.ndarray` containing the out-edges of vertex ``v``. The</span>
<span class="sd">        shape of the array will be ``(k, 3)``, where ``k`` is the out-degree of</span>
<span class="sd">        ``v``, and each line will contain the source, target and index of an</span>
<span class="sd">        edge.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; g = gt.collection.data[&quot;pgp-strong-2009&quot;]</span>
<span class="sd">        &gt;&gt;&gt; g.get_in_edges(66)</span>
<span class="sd">        array([[  8687,     66, 179681],</span>
<span class="sd">               [ 20369,     66, 255033],</span>
<span class="sd">               [ 38674,     66, 300230]], dtype=uint64)</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">edges</span> <span class="o">=</span> <span class="n">libcore</span><span class="o">.</span><span class="n">get_in_edge_list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__graph</span><span class="p">,</span> <span class="nb">int</span><span class="p">(</span><span class="n">v</span><span class="p">))</span>
        <span class="n">E</span> <span class="o">=</span> <span class="n">edges</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">//</span> <span class="mi">3</span>
        <span class="k">return</span> <span class="n">numpy</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">edges</span><span class="p">,</span> <span class="p">(</span><span class="n">E</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span></div>

<div class="viewcode-block" id="Graph.get_out_neighbors"><a class="viewcode-back" href="https://graph-tool.skewed.de/static/doc/graph_tool.html#graph_tool.Graph.get_out_neighbors">[docs]</a>    <span class="k">def</span> <span class="nf">get_out_neighbors</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">v</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return a :class:`numpy.ndarray` containing the out-neighbors of vertex</span>
<span class="sd">        ``v``.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; g = gt.collection.data[&quot;pgp-strong-2009&quot;]</span>
<span class="sd">        &gt;&gt;&gt; g.get_out_neighbors(66)</span>
<span class="sd">        array([   63, 20369, 13980,  8687, 38674], dtype=uint64)</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">libcore</span><span class="o">.</span><span class="n">get_out_neighbors_list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__graph</span><span class="p">,</span> <span class="nb">int</span><span class="p">(</span><span class="n">v</span><span class="p">))</span></div>

    <span class="n">get_out_neighbours</span> <span class="o">=</span> <span class="n">get_out_neighbors</span>

<div class="viewcode-block" id="Graph.get_in_neighbors"><a class="viewcode-back" href="https://graph-tool.skewed.de/static/doc/graph_tool.html#graph_tool.Graph.get_in_neighbors">[docs]</a>    <span class="k">def</span> <span class="nf">get_in_neighbors</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">v</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return a :class:`numpy.ndarray` containing the in-neighbors of vertex ``v``.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; g = gt.collection.data[&quot;pgp-strong-2009&quot;]</span>
<span class="sd">        &gt;&gt;&gt; g.get_in_neighbors(66)</span>
<span class="sd">        array([ 8687, 20369, 38674], dtype=uint64)</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">libcore</span><span class="o">.</span><span class="n">get_in_neighbors_list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__graph</span><span class="p">,</span> <span class="nb">int</span><span class="p">(</span><span class="n">v</span><span class="p">))</span></div>

    <span class="n">get_in_neighbours</span> <span class="o">=</span> <span class="n">get_in_neighbors</span>

<div class="viewcode-block" id="Graph.get_out_degrees"><a class="viewcode-back" href="https://graph-tool.skewed.de/static/doc/graph_tool.html#graph_tool.Graph.get_out_degrees">[docs]</a>    <span class="k">def</span> <span class="nf">get_out_degrees</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">vs</span><span class="p">,</span> <span class="n">eweight</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return a :class:`numpy.ndarray` containing the out-degrees of vertex list</span>
<span class="sd">        ``vs``. If supplied, the degrees will be weighted according to the edge</span>
<span class="sd">        :class:`~graph_tool.PropertyMap` ``eweight``.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; g = gt.collection.data[&quot;pgp-strong-2009&quot;]</span>
<span class="sd">        &gt;&gt;&gt; g.get_out_degrees([42, 666])</span>
<span class="sd">        array([20, 38], dtype=uint64)</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">libcore</span><span class="o">.</span><span class="n">get_degree_list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__graph</span><span class="p">,</span>
                                       <span class="n">numpy</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">vs</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="s2">&quot;uint64&quot;</span><span class="p">),</span>
                                       <span class="n">_prop</span><span class="p">(</span><span class="s2">&quot;e&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="p">,</span> <span class="n">eweight</span><span class="p">),</span> <span class="kc">True</span><span class="p">)</span></div>

<div class="viewcode-block" id="Graph.get_in_degrees"><a class="viewcode-back" href="https://graph-tool.skewed.de/static/doc/graph_tool.html#graph_tool.Graph.get_in_degrees">[docs]</a>    <span class="k">def</span> <span class="nf">get_in_degrees</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">vs</span><span class="p">,</span> <span class="n">eweight</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return a :class:`numpy.ndarray` containing the in-degrees of vertex list</span>
<span class="sd">        ``vs``. If supplied, the degrees will be weighted according to the edge</span>
<span class="sd">        :class:`~graph_tool.PropertyMap` ``eweight``.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; g = gt.collection.data[&quot;pgp-strong-2009&quot;]</span>
<span class="sd">        &gt;&gt;&gt; g.get_in_degrees([42, 666])</span>
<span class="sd">        array([20, 39], dtype=uint64)</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">libcore</span><span class="o">.</span><span class="n">get_degree_list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__graph</span><span class="p">,</span>
                                       <span class="n">numpy</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">vs</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="s2">&quot;uint64&quot;</span><span class="p">),</span>
                                       <span class="n">_prop</span><span class="p">(</span><span class="s2">&quot;e&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="p">,</span> <span class="n">eweight</span><span class="p">),</span> <span class="kc">False</span><span class="p">)</span></div>

<div class="viewcode-block" id="Graph.add_vertex"><a class="viewcode-back" href="https://graph-tool.skewed.de/static/doc/graph_tool.html#graph_tool.Graph.add_vertex">[docs]</a>    <span class="k">def</span> <span class="nf">add_vertex</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Add a vertex to the graph, and return it. If ``n != 1``, ``n``</span>
<span class="sd">        vertices are inserted and an iterator over the new vertices is returned.</span>
<span class="sd">        This operation is :math:`O(n)`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">v</span> <span class="o">=</span> <span class="n">libcore</span><span class="o">.</span><span class="n">add_vertex</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__graph</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">v</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">pos</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_vertices</span><span class="p">(</span><span class="kc">True</span><span class="p">)</span> <span class="o">-</span> <span class="n">n</span>
            <span class="k">return</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">vertex</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">pos</span><span class="p">,</span> <span class="n">pos</span> <span class="o">+</span> <span class="n">n</span><span class="p">))</span></div>

<div class="viewcode-block" id="Graph.remove_vertex"><a class="viewcode-back" href="https://graph-tool.skewed.de/static/doc/graph_tool.html#graph_tool.Graph.remove_vertex">[docs]</a>    <span class="k">def</span> <span class="nf">remove_vertex</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">vertex</span><span class="p">,</span> <span class="n">fast</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;Remove a vertex from the graph. If ``vertex`` is an iterable, it</span>
<span class="sd">        should correspond to a sequence of vertices to be removed.</span>

<span class="sd">        .. note::</span>

<span class="sd">           If the option ``fast == False`` is given, this operation is</span>
<span class="sd">           :math:`O(V + E)` (this is the default). Otherwise it is</span>
<span class="sd">           :math:`O(k + k_{\text{last}})`, where :math:`k` is the (total)</span>
<span class="sd">           degree of the vertex being deleted, and :math:`k_{\text{last}}` is</span>
<span class="sd">           the (total) degree of the vertex with the largest index.</span>

<span class="sd">        .. warning::</span>

<span class="sd">           This operation may invalidate vertex descriptors. Vertices are always</span>
<span class="sd">           indexed contiguously in the range :math:`[0, N-1]`, hence vertex</span>
<span class="sd">           descriptors with an index higher than ``vertex`` will be invalidated</span>
<span class="sd">           after removal (if ``fast == False``, otherwise only descriptors</span>
<span class="sd">           pointing to vertices with the largest index will be invalidated).</span>

<span class="sd">           Because of this, the only safe way to remove more than one vertex at</span>
<span class="sd">           once is to sort them in decreasing index order:</span>

<span class="sd">           .. code::</span>

<span class="sd">               # &#39;del_list&#39; is a list of vertex descriptors</span>
<span class="sd">               for v in reversed(sorted(del_list)):</span>
<span class="sd">                   g.remove_vertex(v)</span>

<span class="sd">           Alternatively (and preferably), a list (or iterable) may be passed</span>
<span class="sd">           directly as the ``vertex`` parameter, and the above is performed</span>
<span class="sd">           internally (in C++).</span>

<span class="sd">        .. warning::</span>

<span class="sd">           If ``fast == True``, the vertex being deleted is &#39;swapped&#39; with the</span>
<span class="sd">           last vertex (i.e. with the largest index), which will in turn inherit</span>
<span class="sd">           the index of the vertex being deleted. All property maps associated</span>
<span class="sd">           with the graph will be properly updated, but the index ordering of</span>
<span class="sd">           the graph will no longer be the same.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">back</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__graph</span><span class="o">.</span><span class="n">get_num_vertices</span><span class="p">(</span><span class="kc">False</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
        <span class="n">is_iter</span> <span class="o">=</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">vertex</span><span class="p">,</span> <span class="n">collections</span><span class="o">.</span><span class="n">Iterable</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">is_iter</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">vs</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">vertex</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="s2">&quot;int64&quot;</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
                <span class="n">vs</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">asarray</span><span class="p">([</span><span class="nb">int</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">vertex</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="s2">&quot;int64&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">vs</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">return</span>
            <span class="n">vs</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">vs</span><span class="p">)[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">vmax</span><span class="p">,</span> <span class="n">vmin</span> <span class="o">=</span> <span class="n">vs</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">vs</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">vmax</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">vertex</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">vmax</span> <span class="o">&gt;</span> <span class="n">back</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Vertex index </span><span class="si">%d</span><span class="s2"> is invalid&quot;</span> <span class="o">%</span> <span class="n">vmax</span><span class="p">)</span>

        <span class="c1"># move / shift all known property maps</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">vmax</span><span class="o">-</span><span class="n">vmin</span> <span class="o">&gt;=</span> <span class="nb">len</span><span class="p">(</span><span class="n">vs</span><span class="p">)</span> <span class="k">if</span> <span class="n">is_iter</span> <span class="k">else</span> <span class="n">vmax</span> <span class="o">!=</span> <span class="n">back</span><span class="p">):</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">is_iter</span><span class="p">:</span>
                <span class="n">vs</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">asarray</span><span class="p">((</span><span class="n">vertex</span><span class="p">,),</span> <span class="n">dtype</span><span class="o">=</span><span class="s2">&quot;int64&quot;</span><span class="p">)</span>
            <span class="n">vfilt</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_vertex_filter</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">vfilt</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">vfiltptr</span> <span class="o">=</span> <span class="n">vfilt</span><span class="o">.</span><span class="n">data_ptr</span><span class="p">()</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">vfiltptr</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="k">for</span> <span class="n">pmap_</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">__known_properties</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
                <span class="n">pmap</span> <span class="o">=</span> <span class="n">pmap_</span><span class="p">()</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">pmap</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span>
                    <span class="n">pmap</span><span class="o">.</span><span class="n">key_type</span><span class="p">()</span> <span class="o">==</span> <span class="s2">&quot;v&quot;</span> <span class="ow">and</span>
                    <span class="n">pmap</span><span class="o">.</span><span class="n">is_writable</span><span class="p">()</span> <span class="ow">and</span>
                    <span class="n">pmap</span><span class="o">.</span><span class="n">data_ptr</span><span class="p">()</span> <span class="o">!=</span> <span class="n">vfiltptr</span><span class="p">):</span>
                    <span class="k">if</span> <span class="n">fast</span><span class="p">:</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">__graph</span><span class="o">.</span><span class="n">move_vertex_property</span><span class="p">(</span><span class="n">_prop</span><span class="p">(</span><span class="s2">&quot;v&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="p">,</span> <span class="n">pmap</span><span class="p">),</span> <span class="n">vs</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">__graph</span><span class="o">.</span><span class="n">shift_vertex_property</span><span class="p">(</span><span class="n">_prop</span><span class="p">(</span><span class="s2">&quot;v&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="p">,</span> <span class="n">pmap</span><span class="p">),</span> <span class="n">vs</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">is_iter</span><span class="p">:</span>
            <span class="n">libcore</span><span class="o">.</span><span class="n">remove_vertex_array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__graph</span><span class="p">,</span> <span class="n">vs</span><span class="p">,</span> <span class="n">fast</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">libcore</span><span class="o">.</span><span class="n">remove_vertex</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__graph</span><span class="p">,</span> <span class="n">vertex</span><span class="p">,</span> <span class="n">fast</span><span class="p">)</span></div>

<div class="viewcode-block" id="Graph.clear_vertex"><a class="viewcode-back" href="https://graph-tool.skewed.de/static/doc/graph_tool.html#graph_tool.Graph.clear_vertex">[docs]</a>    <span class="k">def</span> <span class="nf">clear_vertex</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">vertex</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Remove all in and out-edges from the given vertex.&quot;&quot;&quot;</span>
        <span class="n">libcore</span><span class="o">.</span><span class="n">clear_vertex</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__graph</span><span class="p">,</span> <span class="nb">int</span><span class="p">(</span><span class="n">vertex</span><span class="p">))</span></div>

<div class="viewcode-block" id="Graph.add_edge"><a class="viewcode-back" href="https://graph-tool.skewed.de/static/doc/graph_tool.html#graph_tool.Graph.add_edge">[docs]</a>    <span class="k">def</span> <span class="nf">add_edge</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">source</span><span class="p">,</span> <span class="n">target</span><span class="p">,</span> <span class="n">add_missing</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Add a new edge from ``source`` to ``target`` to the graph, and return</span>
<span class="sd">        it. This operation is :math:`O(1)`.</span>

<span class="sd">        If ``add_missing == True``, the source and target vertices are included</span>
<span class="sd">        in the graph if they don&#39;t yet exist.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">e</span> <span class="o">=</span> <span class="n">libcore</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__graph</span><span class="p">,</span>
                             <span class="bp">self</span><span class="o">.</span><span class="n">vertex</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">source</span><span class="p">),</span> <span class="n">add_missing</span><span class="o">=</span><span class="n">add_missing</span><span class="p">),</span>
                             <span class="bp">self</span><span class="o">.</span><span class="n">vertex</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">target</span><span class="p">),</span> <span class="n">add_missing</span><span class="o">=</span><span class="n">add_missing</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">e</span></div>

<div class="viewcode-block" id="Graph.remove_edge"><a class="viewcode-back" href="https://graph-tool.skewed.de/static/doc/graph_tool.html#graph_tool.Graph.remove_edge">[docs]</a>    <span class="k">def</span> <span class="nf">remove_edge</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">edge</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;Remove an edge from the graph.</span>

<span class="sd">        .. note::</span>

<span class="sd">           This operation is normally :math:`O(k_s + k_t)`, where :math:`k_s`</span>
<span class="sd">           and :math:`k_s` are the total degrees of the source and target</span>
<span class="sd">           vertices, respectively. However, if :meth:`~Graph.set_fast_edge_removal`</span>
<span class="sd">           is set to `True`, this operation becomes :math:`O(1)`.</span>

<span class="sd">        .. warning::</span>

<span class="sd">           The relative ordering of the remaining edges in the graph is kept</span>
<span class="sd">           unchanged, unless :meth:`~Graph.set_fast_edge_removal` is set to</span>
<span class="sd">           `True`, in which case it can change.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">libcore</span><span class="o">.</span><span class="n">remove_edge</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__graph</span><span class="p">,</span> <span class="n">edge</span><span class="p">)</span></div>

<div class="viewcode-block" id="Graph.add_edge_list"><a class="viewcode-back" href="https://graph-tool.skewed.de/static/doc/graph_tool.html#graph_tool.Graph.add_edge_list">[docs]</a>    <span class="k">def</span> <span class="nf">add_edge_list</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">edge_list</span><span class="p">,</span> <span class="n">hashed</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">string_vals</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                      <span class="n">eprops</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Add a list of edges to the graph, given by ``edge_list``, which can</span>
<span class="sd">        be an iterator of ``(source, target)`` pairs where both ``source`` and</span>
<span class="sd">        ``target`` are vertex indexes, or a :class:`~numpy.ndarray` of shape</span>
<span class="sd">        ``(E,2)``, where ``E`` is the number of edges, and each line specifies a </span>
<span class="sd">        ``(source, target)`` pair. If the list references vertices which do not</span>
<span class="sd">        exist in the graph, they will be created.</span>

<span class="sd">        Optionally, if ``hashed == True``, the vertex values in the edge list</span>
<span class="sd">        are not assumed to correspond to vertex indices directly. In this case</span>
<span class="sd">        they will be mapped to vertex indices according to the order in which</span>
<span class="sd">        they are encountered, and a vertex property map with the vertex values</span>
<span class="sd">        is returned. If ``string_vals == True``, the algorithm assumes that the</span>
<span class="sd">        vertex values are strings. Otherwise, they will be assumed to be numeric</span>
<span class="sd">        if ``edge_list`` is a :class:`~numpy.ndarray`, or arbitrary python</span>
<span class="sd">        objects if it is not.</span>

<span class="sd">        If given, ``eprops`` should specify an iterable containing edge property</span>
<span class="sd">        maps that will be filled with the remaining values at each row, if there</span>
<span class="sd">        are more than two.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">eprops</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">eprops</span> <span class="o">=</span> <span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">convert</span> <span class="o">=</span> <span class="p">[</span><span class="n">_converter</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">value_type</span><span class="p">())</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">eprops</span><span class="p">]</span>
            <span class="n">eprops</span> <span class="o">=</span> <span class="p">[</span><span class="n">_prop</span><span class="p">(</span><span class="s2">&quot;e&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">eprops</span><span class="p">]</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">edge_list</span><span class="p">,</span> <span class="n">numpy</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
                <span class="k">def</span> <span class="nf">wrap</span><span class="p">(</span><span class="n">elist</span><span class="p">):</span>
                    <span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">elist</span><span class="p">:</span>
                        <span class="k">yield</span> <span class="p">(</span><span class="n">val</span> <span class="k">if</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">2</span> <span class="k">else</span> <span class="n">convert</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">2</span><span class="p">](</span><span class="n">val</span><span class="p">)</span>
                               <span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">val</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">row</span><span class="p">))</span>
                <span class="n">edge_list</span> <span class="o">=</span> <span class="n">wrap</span><span class="p">(</span><span class="n">edge_list</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">hashed</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">edge_list</span><span class="p">,</span> <span class="n">numpy</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
                <span class="n">libcore</span><span class="o">.</span><span class="n">add_edge_list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__graph</span><span class="p">,</span> <span class="n">edge_list</span><span class="p">,</span> <span class="n">eprops</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">libcore</span><span class="o">.</span><span class="n">add_edge_list_iter</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__graph</span><span class="p">,</span> <span class="n">edge_list</span><span class="p">,</span> <span class="n">eprops</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">edge_list</span><span class="p">,</span> <span class="n">numpy</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
                <span class="n">vprop</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">new_vertex_property</span><span class="p">(</span><span class="n">_gt_type</span><span class="p">(</span><span class="n">edge_list</span><span class="o">.</span><span class="n">dtype</span><span class="p">))</span>
            <span class="k">elif</span> <span class="n">string_vals</span><span class="p">:</span>
                <span class="n">vprop</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">new_vertex_property</span><span class="p">(</span><span class="s2">&quot;string&quot;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">vprop</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">new_vertex_property</span><span class="p">(</span><span class="s2">&quot;object&quot;</span><span class="p">)</span>
            <span class="n">libcore</span><span class="o">.</span><span class="n">add_edge_list_hashed</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__graph</span><span class="p">,</span> <span class="n">edge_list</span><span class="p">,</span>
                                         <span class="n">_prop</span><span class="p">(</span><span class="s2">&quot;v&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="p">,</span> <span class="n">vprop</span><span class="p">),</span>
                                         <span class="n">string_vals</span><span class="p">,</span> <span class="n">eprops</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">vprop</span></div>

<div class="viewcode-block" id="Graph.set_fast_edge_removal"><a class="viewcode-back" href="https://graph-tool.skewed.de/static/doc/graph_tool.html#graph_tool.Graph.set_fast_edge_removal">[docs]</a>    <span class="k">def</span> <span class="nf">set_fast_edge_removal</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fast</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;If ``fast == True`` the fast :math:`O(1)` removal of edges will be</span>
<span class="sd">        enabled. This requires an additional data structure of size :math:`O(E)`</span>
<span class="sd">        to be kept at all times.  If ``fast == False``, this data structure is</span>
<span class="sd">        destroyed.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__graph</span><span class="o">.</span><span class="n">set_keep_epos</span><span class="p">(</span><span class="n">fast</span><span class="p">)</span></div>

<div class="viewcode-block" id="Graph.get_fast_edge_removal"><a class="viewcode-back" href="https://graph-tool.skewed.de/static/doc/graph_tool.html#graph_tool.Graph.get_fast_edge_removal">[docs]</a>    <span class="k">def</span> <span class="nf">get_fast_edge_removal</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;Return whether the fast :math:`O(1)` removal of edges is currently</span>
<span class="sd">        enabled.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__graph</span><span class="o">.</span><span class="n">get_keep_epos</span><span class="p">()</span></div>

<div class="viewcode-block" id="Graph.clear"><a class="viewcode-back" href="https://graph-tool.skewed.de/static/doc/graph_tool.html#graph_tool.Graph.clear">[docs]</a>    <span class="k">def</span> <span class="nf">clear</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Remove all vertices and edges from the graph.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__graph</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span></div>

<div class="viewcode-block" id="Graph.clear_edges"><a class="viewcode-back" href="https://graph-tool.skewed.de/static/doc/graph_tool.html#graph_tool.Graph.clear_edges">[docs]</a>    <span class="k">def</span> <span class="nf">clear_edges</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Remove all edges from the graph.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__graph</span><span class="o">.</span><span class="n">clear_edges</span><span class="p">()</span></div>

    <span class="c1"># Internal property maps</span>
    <span class="c1"># ======================</span>

    <span class="n">properties</span> <span class="o">=</span> <span class="nb">property</span><span class="p">(</span><span class="k">lambda</span> <span class="bp">self</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">__properties</span><span class="p">,</span>
                          <span class="n">doc</span><span class="o">=</span>
    <span class="sd">&quot;&quot;&quot;Dictionary of internal properties. Keys must always be a tuple, where the</span>
<span class="sd">    first element if a string from the set {&#39;v&#39;, &#39;e&#39;, &#39;g&#39;}, representing a</span>
<span class="sd">    vertex, edge or graph property, respectively, and the second element is the</span>
<span class="sd">    name of the property map.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; g = gt.Graph()</span>
<span class="sd">    &gt;&gt;&gt; g.properties[(&quot;e&quot;, &quot;foo&quot;)] = g.new_edge_property(&quot;vector&lt;double&gt;&quot;)</span>
<span class="sd">    &gt;&gt;&gt; del g.properties[(&quot;e&quot;, &quot;foo&quot;)]</span>
<span class="sd">    &quot;&quot;&quot;</span><span class="p">)</span>

    <span class="c1"># vertex properties</span>
    <span class="n">vertex_properties</span> <span class="o">=</span> <span class="nb">property</span><span class="p">(</span><span class="k">lambda</span> <span class="bp">self</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">__vertex_properties</span><span class="p">,</span>
                                 <span class="n">doc</span><span class="o">=</span><span class="s2">&quot;Dictionary of internal vertex properties. The keys are the property names.&quot;</span><span class="p">)</span>
    <span class="n">vp</span> <span class="o">=</span> <span class="nb">property</span><span class="p">(</span><span class="k">lambda</span> <span class="bp">self</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">__vertex_properties</span><span class="p">,</span>
                  <span class="n">doc</span><span class="o">=</span><span class="s2">&quot;Alias to :attr:`~Graph.vertex_properties`.&quot;</span><span class="p">)</span>

    <span class="c1"># edge properties</span>
    <span class="n">edge_properties</span> <span class="o">=</span> <span class="nb">property</span><span class="p">(</span><span class="k">lambda</span> <span class="bp">self</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">__edge_properties</span><span class="p">,</span>
                               <span class="n">doc</span><span class="o">=</span><span class="s2">&quot;Dictionary of internal edge properties. The keys are the property names.&quot;</span><span class="p">)</span>
    <span class="n">ep</span> <span class="o">=</span> <span class="nb">property</span><span class="p">(</span><span class="k">lambda</span> <span class="bp">self</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">__edge_properties</span><span class="p">,</span>
                  <span class="n">doc</span><span class="o">=</span><span class="s2">&quot;Alias to :attr:`~Graph.edge_properties`.&quot;</span><span class="p">)</span>

    <span class="c1"># graph properties</span>
    <span class="n">graph_properties</span> <span class="o">=</span> <span class="nb">property</span><span class="p">(</span><span class="k">lambda</span> <span class="bp">self</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">__graph_properties</span><span class="p">,</span>
                                 <span class="n">doc</span><span class="o">=</span><span class="s2">&quot;Dictionary of internal graph properties. The keys are the property names.&quot;</span><span class="p">)</span>
    <span class="n">gp</span> <span class="o">=</span> <span class="nb">property</span><span class="p">(</span><span class="k">lambda</span> <span class="bp">self</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">__graph_properties</span><span class="p">,</span>
                  <span class="n">doc</span><span class="o">=</span><span class="s2">&quot;Alias to :attr:`~Graph.graph_properties`.&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">own_property</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">prop</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return a version of the property map &#39;prop&#39; (possibly belonging to</span>
<span class="sd">        another graph) which is owned by the current graph.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">PropertyMap</span><span class="p">(</span><span class="n">prop</span><span class="o">.</span><span class="n">_PropertyMap__map</span><span class="p">,</span> <span class="bp">self</span><span class="p">,</span> <span class="n">prop</span><span class="o">.</span><span class="n">key_type</span><span class="p">())</span>

<div class="viewcode-block" id="Graph.list_properties"><a class="viewcode-back" href="https://graph-tool.skewed.de/static/doc/graph_tool.html#graph_tool.Graph.list_properties">[docs]</a>    <span class="k">def</span> <span class="nf">list_properties</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Print a list of all internal properties.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; g = gt.Graph()</span>
<span class="sd">        &gt;&gt;&gt; g.properties[(&quot;e&quot;, &quot;foo&quot;)] = g.new_edge_property(&quot;vector&lt;double&gt;&quot;)</span>
<span class="sd">        &gt;&gt;&gt; g.vertex_properties[&quot;foo&quot;] = g.new_vertex_property(&quot;double&quot;)</span>
<span class="sd">        &gt;&gt;&gt; g.vertex_properties[&quot;bar&quot;] = g.new_vertex_property(&quot;python::object&quot;)</span>
<span class="sd">        &gt;&gt;&gt; g.graph_properties[&quot;gnat&quot;] = g.new_graph_property(&quot;string&quot;, &quot;hi there!&quot;)</span>
<span class="sd">        &gt;&gt;&gt; g.list_properties()</span>
<span class="sd">        gnat           (graph)   (type: string, val: hi there!)</span>
<span class="sd">        bar            (vertex)  (type: python::object)</span>
<span class="sd">        foo            (vertex)  (type: double)</span>
<span class="sd">        foo            (edge)    (type: vector&lt;double&gt;)</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__properties</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span>
        <span class="n">w</span> <span class="o">=</span> <span class="nb">max</span><span class="p">([</span><span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__properties</span><span class="o">.</span><span class="n">keys</span><span class="p">())])</span> <span class="o">+</span> <span class="mi">4</span>
        <span class="n">w</span> <span class="o">=</span> <span class="n">w</span> <span class="k">if</span> <span class="n">w</span> <span class="o">&gt;</span> <span class="mi">14</span> <span class="k">else</span> <span class="mi">14</span>

        <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">graph_properties</span><span class="o">.</span><span class="n">items</span><span class="p">(),</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">k</span><span class="p">:</span> <span class="n">k</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
            <span class="n">pref</span><span class="o">=</span><span class="s2">&quot;</span><span class="si">%%</span><span class="s2">-</span><span class="si">%d</span><span class="s2">s (graph)   (type: </span><span class="si">%%</span><span class="s2">s, val: &quot;</span> <span class="o">%</span> <span class="n">w</span> <span class="o">%</span>  <span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">v</span><span class="o">.</span><span class="n">value_type</span><span class="p">())</span>
            <span class="n">val</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">v</span><span class="p">[</span><span class="bp">self</span><span class="p">])</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">val</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1000</span><span class="p">:</span>
                <span class="n">val</span> <span class="o">=</span> <span class="n">val</span><span class="p">[:</span><span class="mi">1000</span><span class="p">]</span> <span class="o">+</span> <span class="s2">&quot;...&quot;</span>
            <span class="n">tw</span> <span class="o">=</span> <span class="n">terminal_size</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">val</span> <span class="o">=</span> <span class="n">textwrap</span><span class="o">.</span><span class="n">fill</span><span class="p">(</span><span class="n">val</span><span class="p">,</span>
                                <span class="n">width</span><span class="o">=</span><span class="nb">max</span><span class="p">(</span><span class="n">tw</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="n">pref</span><span class="p">),</span> <span class="mi">1</span><span class="p">))</span>
            <span class="n">val</span> <span class="o">=</span> <span class="n">val</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">,</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span> <span class="o">+</span> <span class="s2">&quot; &quot;</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">pref</span><span class="p">))</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%s%s</span><span class="s2">)&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">pref</span><span class="p">,</span> <span class="n">val</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">vertex_properties</span><span class="o">.</span><span class="n">items</span><span class="p">(),</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">k</span><span class="p">:</span> <span class="n">k</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%%</span><span class="s2">-</span><span class="si">%d</span><span class="s2">s (vertex)  (type: </span><span class="si">%%</span><span class="s2">s)&quot;</span> <span class="o">%</span> <span class="n">w</span> <span class="o">%</span> <span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">v</span><span class="o">.</span><span class="n">value_type</span><span class="p">()))</span>
        <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">edge_properties</span><span class="o">.</span><span class="n">items</span><span class="p">(),</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">k</span><span class="p">:</span> <span class="n">k</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%%</span><span class="s2">-</span><span class="si">%d</span><span class="s2">s (edge)    (type: </span><span class="si">%%</span><span class="s2">s)&quot;</span> <span class="o">%</span> <span class="n">w</span> <span class="o">%</span> <span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">v</span><span class="o">.</span><span class="n">value_type</span><span class="p">()))</span></div>

    <span class="c1"># index properties</span>

    <span class="k">def</span> <span class="nf">_get_vertex_index</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__vertex_index</span>
    <span class="n">vertex_index</span> <span class="o">=</span> <span class="nb">property</span><span class="p">(</span><span class="n">_get_vertex_index</span><span class="p">,</span>
                            <span class="n">doc</span><span class="o">=</span><span class="s2">&quot;&quot;&quot;Vertex index map.</span>

<span class="s2">                            It maps for each vertex in the graph an unique</span>
<span class="s2">                            integer in the range [0, :meth:`~graph_tool.Graph.num_vertices` - 1].</span>

<span class="s2">                            .. note::</span>

<span class="s2">                                Like :attr:`~graph_tool.Graph.edge_index`, this</span>
<span class="s2">                                is a special instance of a :class:`~graph_tool.PropertyMap`</span>
<span class="s2">                                class, which is **immutable**, and cannot be</span>
<span class="s2">                                accessed as an array.&quot;&quot;&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_get_edge_index</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__edge_index</span>
    <span class="n">edge_index</span> <span class="o">=</span> <span class="nb">property</span><span class="p">(</span><span class="n">_get_edge_index</span><span class="p">,</span> <span class="n">doc</span><span class="o">=</span><span class="s2">&quot;&quot;&quot;Edge index map.</span>

<span class="s2">                            It maps for each edge in the graph an unique</span>
<span class="s2">                            integer.</span>

<span class="s2">                            .. note::</span>

<span class="s2">                                Like :attr:`~graph_tool.Graph.vertex_index`, this</span>
<span class="s2">                                is a special instance of a :class:`~graph_tool.PropertyMap`</span>
<span class="s2">                                class, which is **immutable**, and cannot be</span>
<span class="s2">                                accessed as an array.</span>

<span class="s2">                                Additionally, the indexes may not necessarily</span>
<span class="s2">                                lie in the range [0, :meth:`~graph_tool.Graph.num_edges` - 1].</span>
<span class="s2">                                However this will always happen whenever no</span>
<span class="s2">                                edges are deleted from the graph.&quot;&quot;&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_get_edge_index_range</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__graph</span><span class="o">.</span><span class="n">get_edge_index_range</span><span class="p">()</span>

    <span class="n">edge_index_range</span> <span class="o">=</span> <span class="nb">property</span><span class="p">(</span><span class="n">_get_edge_index_range</span><span class="p">,</span>
                                <span class="n">doc</span><span class="o">=</span><span class="s2">&quot;The size of the range of edge indexes.&quot;</span><span class="p">)</span>

<div class="viewcode-block" id="Graph.reindex_edges"><a class="viewcode-back" href="https://graph-tool.skewed.de/static/doc/graph_tool.html#graph_tool.Graph.reindex_edges">[docs]</a>    <span class="k">def</span> <span class="nf">reindex_edges</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Reset the edge indexes so that they lie in the [0, :meth:`~graph_tool.Graph.num_edges` - 1]</span>
<span class="sd">        range. The index ordering will be compatible with the sequence returned</span>
<span class="sd">        by the :meth:`~graph_tool.Graph.edges` function.</span>

<span class="sd">        .. warning::</span>

<span class="sd">           Calling this function will invalidate all existing edge property</span>
<span class="sd">           maps, if the index ordering is modified! The property maps will still</span>
<span class="sd">           be usable, but their contents will still be tied to the old indexes,</span>
<span class="sd">           and thus may become scrambled.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__graph</span><span class="o">.</span><span class="n">re_index_edges</span><span class="p">()</span></div>


<div class="viewcode-block" id="Graph.shrink_to_fit"><a class="viewcode-back" href="https://graph-tool.skewed.de/static/doc/graph_tool.html#graph_tool.Graph.shrink_to_fit">[docs]</a>    <span class="k">def</span> <span class="nf">shrink_to_fit</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Force the physical capacity of the underlying containers to match the graph&#39;s</span>
<span class="sd">        actual size, potentially freeing memory back to the system.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__graph</span><span class="o">.</span><span class="n">shrink_to_fit</span><span class="p">()</span></div>

    <span class="c1"># Property map creation</span>

<div class="viewcode-block" id="Graph.new_property"><a class="viewcode-back" href="https://graph-tool.skewed.de/static/doc/graph_tool.html#graph_tool.Graph.new_property">[docs]</a>    <span class="k">def</span> <span class="nf">new_property</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key_type</span><span class="p">,</span> <span class="n">value_type</span><span class="p">,</span> <span class="n">vals</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>

        <span class="sd">&quot;&quot;&quot;Create a new (uninitialized) vertex property map of key type</span>
<span class="sd">        ``key_type`` (``v``, ``e`` or ``g``), value type ``value_type``, and</span>
<span class="sd">        return it. If provided, the values will be initialized by ``vals``,</span>
<span class="sd">        which should be a sequence.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">key_type</span> <span class="o">==</span> <span class="s2">&quot;v&quot;</span> <span class="ow">or</span> <span class="n">key_type</span> <span class="o">==</span> <span class="s2">&quot;vertex&quot;</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">new_vertex_property</span><span class="p">(</span><span class="n">value_type</span><span class="p">,</span> <span class="n">vals</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">key_type</span> <span class="o">==</span> <span class="s2">&quot;e&quot;</span> <span class="ow">or</span> <span class="n">key_type</span> <span class="o">==</span> <span class="s2">&quot;edge&quot;</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">new_edge_property</span><span class="p">(</span><span class="n">value_type</span><span class="p">,</span> <span class="n">vals</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">key_type</span> <span class="o">==</span> <span class="s2">&quot;g&quot;</span> <span class="ow">or</span> <span class="n">key_type</span> <span class="o">==</span> <span class="s2">&quot;graph&quot;</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">new_graph_property</span><span class="p">(</span><span class="n">value_type</span><span class="p">,</span> <span class="n">vals</span><span class="p">)</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;unknown key type: &quot;</span> <span class="o">+</span> <span class="n">key_type</span><span class="p">)</span></div>

<div class="viewcode-block" id="Graph.new_vertex_property"><a class="viewcode-back" href="https://graph-tool.skewed.de/static/doc/graph_tool.html#graph_tool.Graph.new_vertex_property">[docs]</a>    <span class="k">def</span> <span class="nf">new_vertex_property</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value_type</span><span class="p">,</span> <span class="n">vals</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">val</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Create a new vertex property map of type ``value_type``, and return it. If</span>
<span class="sd">        provided, the values will be initialized by ``vals``, which should be</span>
<span class="sd">        sequence or by ``val`` which should be  a single value.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">prop</span> <span class="o">=</span> <span class="n">PropertyMap</span><span class="p">(</span><span class="n">new_vertex_property</span><span class="p">(</span><span class="n">_type_alias</span><span class="p">(</span><span class="n">value_type</span><span class="p">),</span>
                                               <span class="bp">self</span><span class="o">.</span><span class="n">__graph</span><span class="o">.</span><span class="n">get_vertex_index</span><span class="p">(),</span>
                                               <span class="n">libcore</span><span class="o">.</span><span class="n">any</span><span class="p">()),</span>
                           <span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;v&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">vals</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">prop</span><span class="o">.</span><span class="n">fa</span> <span class="o">=</span> <span class="n">vals</span>
            <span class="k">except</span> <span class="p">(</span><span class="ne">IndexError</span><span class="p">,</span> <span class="ne">ValueError</span><span class="p">,</span> <span class="ne">TypeError</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">v</span><span class="p">,</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">vertices</span><span class="p">(),</span> <span class="n">vals</span><span class="p">):</span>
                    <span class="n">prop</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">=</span> <span class="n">x</span>
        <span class="k">elif</span> <span class="n">val</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">prop</span><span class="o">.</span><span class="n">set_value</span><span class="p">(</span><span class="n">val</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">prop</span></div>

    <span class="n">new_vp</span> <span class="o">=</span> <span class="n">_copy_func</span><span class="p">(</span><span class="n">new_vertex_property</span><span class="p">,</span> <span class="s2">&quot;new_vp&quot;</span><span class="p">)</span>
    <span class="n">new_vp</span><span class="o">.</span><span class="vm">__doc__</span> <span class="o">=</span> <span class="s2">&quot;Alias to :func:`~graph_tool.Graph.new_vertex_property`.&quot;</span>

<div class="viewcode-block" id="Graph.new_edge_property"><a class="viewcode-back" href="https://graph-tool.skewed.de/static/doc/graph_tool.html#graph_tool.Graph.new_edge_property">[docs]</a>    <span class="k">def</span> <span class="nf">new_edge_property</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value_type</span><span class="p">,</span> <span class="n">vals</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">val</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Create a new edge property map of type ``value_type``, and return it. If</span>
<span class="sd">        provided, the values will be initialized by ``vals``, which should be</span>
<span class="sd">        sequence or by ``val`` which should be a single value.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">prop</span> <span class="o">=</span> <span class="n">PropertyMap</span><span class="p">(</span><span class="n">new_edge_property</span><span class="p">(</span><span class="n">_c_str</span><span class="p">(</span><span class="n">_type_alias</span><span class="p">(</span><span class="n">value_type</span><span class="p">)),</span>
                                             <span class="bp">self</span><span class="o">.</span><span class="n">__graph</span><span class="o">.</span><span class="n">get_edge_index</span><span class="p">(),</span>
                                             <span class="n">libcore</span><span class="o">.</span><span class="n">any</span><span class="p">()),</span>
                           <span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;e&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">vals</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">prop</span><span class="o">.</span><span class="n">fa</span> <span class="o">=</span> <span class="n">vals</span>
            <span class="k">except</span> <span class="p">(</span><span class="ne">IndexError</span><span class="p">,</span> <span class="ne">ValueError</span><span class="p">,</span> <span class="ne">TypeError</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">e</span><span class="p">,</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">edges</span><span class="p">(),</span> <span class="n">vals</span><span class="p">):</span>
                    <span class="n">prop</span><span class="p">[</span><span class="n">e</span><span class="p">]</span> <span class="o">=</span> <span class="n">x</span>
        <span class="k">elif</span> <span class="n">val</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">prop</span><span class="o">.</span><span class="n">set_value</span><span class="p">(</span><span class="n">val</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">prop</span></div>

    <span class="n">new_ep</span> <span class="o">=</span> <span class="n">_copy_func</span><span class="p">(</span><span class="n">new_edge_property</span><span class="p">,</span> <span class="s2">&quot;new_ep&quot;</span><span class="p">)</span>
    <span class="n">new_ep</span><span class="o">.</span><span class="vm">__doc__</span> <span class="o">=</span> <span class="s2">&quot;Alias to :func:`~graph_tool.Graph.new_edge_property`.&quot;</span>

<div class="viewcode-block" id="Graph.new_graph_property"><a class="viewcode-back" href="https://graph-tool.skewed.de/static/doc/graph_tool.html#graph_tool.Graph.new_graph_property">[docs]</a>    <span class="k">def</span> <span class="nf">new_graph_property</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value_type</span><span class="p">,</span> <span class="n">val</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Create a new graph property map of type ``value_type``, and return</span>
<span class="sd">        it. If ``val`` is not None, the property is initialized to its value.&quot;&quot;&quot;</span>
        <span class="n">prop</span> <span class="o">=</span> <span class="n">PropertyMap</span><span class="p">(</span><span class="n">new_graph_property</span><span class="p">(</span><span class="n">_c_str</span><span class="p">(</span><span class="n">_type_alias</span><span class="p">(</span><span class="n">value_type</span><span class="p">)),</span>
                                              <span class="bp">self</span><span class="o">.</span><span class="n">__graph</span><span class="o">.</span><span class="n">get_graph_index</span><span class="p">(),</span>
                                              <span class="n">libcore</span><span class="o">.</span><span class="n">any</span><span class="p">()),</span>
                           <span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;g&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">val</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">prop</span><span class="p">[</span><span class="bp">self</span><span class="p">]</span> <span class="o">=</span> <span class="n">val</span>
        <span class="k">return</span> <span class="n">prop</span></div>

    <span class="n">new_gp</span> <span class="o">=</span> <span class="n">_copy_func</span><span class="p">(</span><span class="n">new_graph_property</span><span class="p">,</span> <span class="s2">&quot;new_gp&quot;</span><span class="p">)</span>
    <span class="n">new_gp</span><span class="o">.</span><span class="vm">__doc__</span> <span class="o">=</span> <span class="s2">&quot;Alias to :func:`~graph_tool.Graph.new_graph_property`.&quot;</span>

    <span class="c1"># property map copying</span>
<div class="viewcode-block" id="Graph.copy_property"><a class="viewcode-back" href="https://graph-tool.skewed.de/static/doc/graph_tool.html#graph_tool.Graph.copy_property">[docs]</a>    <span class="nd">@_require</span><span class="p">(</span><span class="s2">&quot;src&quot;</span><span class="p">,</span> <span class="n">PropertyMap</span><span class="p">)</span>
    <span class="nd">@_require</span><span class="p">(</span><span class="s2">&quot;tgt&quot;</span><span class="p">,</span> <span class="p">(</span><span class="n">PropertyMap</span><span class="p">,</span> <span class="nb">type</span><span class="p">(</span><span class="kc">None</span><span class="p">)))</span>
    <span class="k">def</span> <span class="nf">copy_property</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">src</span><span class="p">,</span> <span class="n">tgt</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">value_type</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">g</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">full</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Copy contents of ``src`` property to ``tgt`` property. If ``tgt`` is None,</span>
<span class="sd">        then a new property map of the same type (or with the type given by the</span>
<span class="sd">        optional ``value_type`` parameter) is created, and returned. The</span>
<span class="sd">        optional parameter ``g`` specifies the source graph to copy properties</span>
<span class="sd">        from (defaults to self). If ``full == False``, in the case of filtered</span>
<span class="sd">        graphs only the unmasked values are copied (with the remaining ones</span>
<span class="sd">        taking the type-dependent default value).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">tgt</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">tgt</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">new_property</span><span class="p">(</span><span class="n">src</span><span class="o">.</span><span class="n">key_type</span><span class="p">(),</span>
                                    <span class="p">(</span><span class="n">src</span><span class="o">.</span><span class="n">value_type</span><span class="p">()</span>
                                     <span class="k">if</span> <span class="n">value_type</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">value_type</span><span class="p">))</span>
            <span class="n">ret</span> <span class="o">=</span> <span class="n">tgt</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">ret</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="k">if</span> <span class="n">src</span><span class="o">.</span><span class="n">key_type</span><span class="p">()</span> <span class="o">!=</span> <span class="n">tgt</span><span class="o">.</span><span class="n">key_type</span><span class="p">():</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;source and target properties must have the same key type&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">g</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">g</span> <span class="o">=</span> <span class="bp">self</span>
        <span class="n">sf</span> <span class="o">=</span> <span class="bp">self</span>

        <span class="k">if</span> <span class="n">full</span><span class="p">:</span>
            <span class="n">g</span> <span class="o">=</span> <span class="n">GraphView</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">skip_properties</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">skip_efilt</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                          <span class="n">skip_vfilt</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">directed</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="n">sf</span> <span class="o">=</span> <span class="n">GraphView</span><span class="p">(</span><span class="n">sf</span><span class="p">,</span> <span class="n">skip_properties</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">skip_efilt</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                           <span class="n">skip_vfilt</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">directed</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">src</span><span class="o">.</span><span class="n">key_type</span><span class="p">()</span> <span class="o">==</span> <span class="s2">&quot;v&quot;</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">g</span><span class="o">.</span><span class="n">num_vertices</span><span class="p">()</span> <span class="o">&gt;</span> <span class="n">sf</span><span class="o">.</span><span class="n">num_vertices</span><span class="p">():</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;graphs with incompatible sizes (</span><span class="si">%d</span><span class="s2">, </span><span class="si">%d</span><span class="s2">)&quot;</span> <span class="o">%</span>
                                 <span class="p">(</span><span class="n">g</span><span class="o">.</span><span class="n">num_vertices</span><span class="p">(),</span> <span class="n">sf</span><span class="o">.</span><span class="n">num_vertices</span><span class="p">()))</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">sf</span><span class="o">.</span><span class="n">__graph</span><span class="o">.</span><span class="n">copy_vertex_property</span><span class="p">(</span><span class="n">g</span><span class="o">.</span><span class="n">__graph</span><span class="p">,</span>
                                                <span class="n">_prop</span><span class="p">(</span><span class="s2">&quot;v&quot;</span><span class="p">,</span> <span class="n">g</span><span class="p">,</span> <span class="n">src</span><span class="p">),</span>
                                                <span class="n">_prop</span><span class="p">(</span><span class="s2">&quot;v&quot;</span><span class="p">,</span> <span class="n">sf</span><span class="p">,</span> <span class="n">tgt</span><span class="p">))</span>
            <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;property maps with the following types are&quot;</span>
                                 <span class="s2">&quot; not convertible: </span><span class="si">%s</span><span class="s2">, </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span>
                                 <span class="p">(</span><span class="n">src</span><span class="o">.</span><span class="n">value_type</span><span class="p">(),</span> <span class="n">tgt</span><span class="o">.</span><span class="n">value_type</span><span class="p">()))</span>
        <span class="k">elif</span> <span class="n">src</span><span class="o">.</span><span class="n">key_type</span><span class="p">()</span> <span class="o">==</span> <span class="s2">&quot;e&quot;</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">g</span><span class="o">.</span><span class="n">num_edges</span><span class="p">()</span> <span class="o">&gt;</span> <span class="n">sf</span><span class="o">.</span><span class="n">num_edges</span><span class="p">():</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;graphs with incompatible sizes (</span><span class="si">%d</span><span class="s2">, </span><span class="si">%d</span><span class="s2">)&quot;</span> <span class="o">%</span>
                                 <span class="p">(</span><span class="n">g</span><span class="o">.</span><span class="n">num_edges</span><span class="p">(),</span> <span class="n">sf</span><span class="o">.</span><span class="n">num_edges</span><span class="p">()))</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">sf</span><span class="o">.</span><span class="n">__graph</span><span class="o">.</span><span class="n">copy_edge_property</span><span class="p">(</span><span class="n">g</span><span class="o">.</span><span class="n">__graph</span><span class="p">,</span>
                                              <span class="n">_prop</span><span class="p">(</span><span class="s2">&quot;e&quot;</span><span class="p">,</span> <span class="n">g</span><span class="p">,</span> <span class="n">src</span><span class="p">),</span>
                                              <span class="n">_prop</span><span class="p">(</span><span class="s2">&quot;e&quot;</span><span class="p">,</span> <span class="n">sf</span><span class="p">,</span> <span class="n">tgt</span><span class="p">))</span>
            <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;property maps with the following types are&quot;</span>
                                 <span class="s2">&quot; not convertible: </span><span class="si">%s</span><span class="s2">, </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span>
                                 <span class="p">(</span><span class="n">src</span><span class="o">.</span><span class="n">value_type</span><span class="p">(),</span> <span class="n">tgt</span><span class="o">.</span><span class="n">value_type</span><span class="p">()))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">tgt</span><span class="p">[</span><span class="n">sf</span><span class="p">]</span> <span class="o">=</span> <span class="n">src</span><span class="p">[</span><span class="n">g</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">ret</span></div>

    <span class="c1"># degree property map</span>
<div class="viewcode-block" id="Graph.degree_property_map"><a class="viewcode-back" href="https://graph-tool.skewed.de/static/doc/graph_tool.html#graph_tool.Graph.degree_property_map">[docs]</a>    <span class="nd">@_limit_args</span><span class="p">({</span><span class="s2">&quot;deg&quot;</span><span class="p">:</span> <span class="p">[</span><span class="s2">&quot;in&quot;</span><span class="p">,</span> <span class="s2">&quot;out&quot;</span><span class="p">,</span> <span class="s2">&quot;total&quot;</span><span class="p">]})</span>
    <span class="k">def</span> <span class="nf">degree_property_map</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">deg</span><span class="p">,</span> <span class="n">weight</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Create and return a vertex property map containing the degree type</span>
<span class="sd">        given by ``deg``, which can be any of ``&quot;in&quot;``, ``&quot;out&quot;``, or ``&quot;total&quot;``.</span>
<span class="sd">        If provided, ``weight`` should be an edge :class:`~graph_tool.PropertyMap`</span>
<span class="sd">        containing the edge weights which should be summed.&quot;&quot;&quot;</span>
        <span class="n">pmap</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__graph</span><span class="o">.</span><span class="n">degree_map</span><span class="p">(</span><span class="n">_to_str</span><span class="p">(</span><span class="n">deg</span><span class="p">),</span> <span class="n">_prop</span><span class="p">(</span><span class="s2">&quot;e&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="p">,</span> <span class="n">weight</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">PropertyMap</span><span class="p">(</span><span class="n">pmap</span><span class="p">,</span> <span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;v&quot;</span><span class="p">)</span></div>

    <span class="c1"># I/O operations</span>
    <span class="c1"># ==============</span>
    <span class="k">def</span> <span class="nf">__get_file_format</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">file_name</span><span class="p">):</span>
        <span class="n">fmt</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;gt&quot;</span><span class="p">,</span> <span class="s2">&quot;graphml&quot;</span><span class="p">,</span> <span class="s2">&quot;xml&quot;</span><span class="p">,</span> <span class="s2">&quot;dot&quot;</span><span class="p">,</span> <span class="s2">&quot;gml&quot;</span><span class="p">]:</span>
            <span class="n">names</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;.&quot;</span> <span class="o">+</span> <span class="n">f</span><span class="p">,</span> <span class="s2">&quot;.</span><span class="si">%s</span><span class="s2">.gz&quot;</span> <span class="o">%</span> <span class="n">f</span><span class="p">,</span> <span class="s2">&quot;.</span><span class="si">%s</span><span class="s2">.bz2&quot;</span> <span class="o">%</span> <span class="n">f</span><span class="p">,</span> <span class="s2">&quot;.</span><span class="si">%s</span><span class="s2">.xz&quot;</span> <span class="o">%</span> <span class="n">f</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">names</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">file_name</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="n">name</span><span class="p">):</span>
                    <span class="n">fmt</span> <span class="o">=</span> <span class="n">f</span>
                    <span class="k">break</span>
        <span class="k">if</span> <span class="n">fmt</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;cannot determine file format of: &quot;</span> <span class="o">+</span> <span class="n">file_name</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">fmt</span>

<div class="viewcode-block" id="Graph.load"><a class="viewcode-back" href="https://graph-tool.skewed.de/static/doc/graph_tool.html#graph_tool.Graph.load">[docs]</a>    <span class="k">def</span> <span class="nf">load</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">file_name</span><span class="p">,</span> <span class="n">fmt</span><span class="o">=</span><span class="s2">&quot;auto&quot;</span><span class="p">,</span> <span class="n">ignore_vp</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">ignore_ep</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
             <span class="n">ignore_gp</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Load graph from ``file_name`` (which can be either a string or a file-like</span>
<span class="sd">        object). The format is guessed from ``file_name``, or can be specified</span>
<span class="sd">        by ``fmt``, which can be either &quot;gt&quot;, &quot;graphml&quot;, &quot;xml&quot;, &quot;dot&quot; or &quot;gml&quot;.</span>
<span class="sd">        (Note that &quot;graphml&quot; and &quot;xml&quot; are synonyms).</span>

<span class="sd">        If provided, the parameters ``ignore_vp``, ``ignore_ep`` and</span>
<span class="sd">        ``ignore_gp``, should contain a list of property names (vertex, edge or</span>
<span class="sd">        graph, respectively) which should be ignored when reading the file.</span>

<span class="sd">        .. warning::</span>

<span class="sd">           The only file formats which are capable of perfectly preserving the</span>
<span class="sd">           internal property maps are &quot;gt&quot; and &quot;graphml&quot;. Because of this,</span>
<span class="sd">           they should be preferred over the other formats whenever possible.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">file_name</span><span class="p">,</span> <span class="p">(</span><span class="nb">str</span><span class="p">,</span> <span class="n">unicode</span><span class="p">)):</span>
            <span class="n">file_name</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">expanduser</span><span class="p">(</span><span class="n">file_name</span><span class="p">)</span>
            <span class="n">f</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="n">file_name</span><span class="p">)</span> <span class="c1"># throw the appropriate exception, if not found</span>
        <span class="k">if</span> <span class="n">fmt</span> <span class="o">==</span> <span class="s1">&#39;auto&#39;</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">file_name</span><span class="p">,</span> <span class="p">(</span><span class="nb">str</span><span class="p">,</span> <span class="n">unicode</span><span class="p">)):</span>
            <span class="n">fmt</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__get_file_format</span><span class="p">(</span><span class="n">file_name</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">fmt</span> <span class="o">==</span> <span class="s2">&quot;auto&quot;</span><span class="p">:</span>
            <span class="n">fmt</span> <span class="o">=</span> <span class="s2">&quot;gt&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">file_name</span><span class="p">,</span> <span class="p">(</span><span class="nb">str</span><span class="p">,</span> <span class="n">unicode</span><span class="p">))</span> <span class="ow">and</span> <span class="n">file_name</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="s2">&quot;.xz&quot;</span><span class="p">):</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">file_name</span> <span class="o">=</span> <span class="n">lzma</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="n">file_name</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s2">&quot;rb&quot;</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">NameError</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;lzma compression is only available in Python &gt;= 3.3&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">fmt</span> <span class="o">==</span> <span class="s2">&quot;graphml&quot;</span><span class="p">:</span>
            <span class="n">fmt</span> <span class="o">=</span> <span class="s2">&quot;xml&quot;</span>
        <span class="k">if</span> <span class="n">ignore_vp</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">ignore_vp</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">if</span> <span class="n">ignore_ep</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">ignore_ep</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">if</span> <span class="n">ignore_gp</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">ignore_gp</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">file_name</span><span class="p">,</span> <span class="p">(</span><span class="nb">str</span><span class="p">,</span> <span class="n">unicode</span><span class="p">)):</span>
            <span class="n">props</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__graph</span><span class="o">.</span><span class="n">read_from_file</span><span class="p">(</span><span class="n">_c_str</span><span class="p">(</span><span class="n">file_name</span><span class="p">),</span> <span class="kc">None</span><span class="p">,</span>
                                                <span class="n">_c_str</span><span class="p">(</span><span class="n">fmt</span><span class="p">),</span> <span class="n">ignore_vp</span><span class="p">,</span>
                                                <span class="n">ignore_ep</span><span class="p">,</span> <span class="n">ignore_gp</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">props</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__graph</span><span class="o">.</span><span class="n">read_from_file</span><span class="p">(</span><span class="s2">&quot;&quot;</span><span class="p">,</span> <span class="n">file_name</span><span class="p">,</span> <span class="n">_c_str</span><span class="p">(</span><span class="n">fmt</span><span class="p">),</span>
                                                <span class="n">ignore_vp</span><span class="p">,</span> <span class="n">ignore_ep</span><span class="p">,</span> <span class="n">ignore_gp</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">prop</span> <span class="ow">in</span> <span class="n">props</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">vertex_properties</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">PropertyMap</span><span class="p">(</span><span class="n">prop</span><span class="p">,</span> <span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;v&quot;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">prop</span> <span class="ow">in</span> <span class="n">props</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">edge_properties</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">PropertyMap</span><span class="p">(</span><span class="n">prop</span><span class="p">,</span> <span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;e&quot;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">prop</span> <span class="ow">in</span> <span class="n">props</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">graph_properties</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">PropertyMap</span><span class="p">(</span><span class="n">prop</span><span class="p">,</span> <span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;g&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="s2">&quot;_Graph__save__vfilter&quot;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">graph_properties</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">set_vertex_filter</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">vertex_properties</span><span class="p">[</span><span class="s2">&quot;_Graph__save__vfilter&quot;</span><span class="p">],</span>
                                   <span class="bp">self</span><span class="o">.</span><span class="n">graph_properties</span><span class="p">[</span><span class="s2">&quot;_Graph__save__vfilter&quot;</span><span class="p">])</span>
            <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">vertex_properties</span><span class="p">[</span><span class="s2">&quot;_Graph__save__vfilter&quot;</span><span class="p">]</span>
            <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">graph_properties</span><span class="p">[</span><span class="s2">&quot;_Graph__save__vfilter&quot;</span><span class="p">]</span>
        <span class="k">if</span> <span class="s2">&quot;_Graph__save__efilter&quot;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">graph_properties</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">set_edge_filter</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">edge_properties</span><span class="p">[</span><span class="s2">&quot;_Graph__save__efilter&quot;</span><span class="p">],</span>
                                 <span class="bp">self</span><span class="o">.</span><span class="n">graph_properties</span><span class="p">[</span><span class="s2">&quot;_Graph__save__efilter&quot;</span><span class="p">])</span>
            <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">edge_properties</span><span class="p">[</span><span class="s2">&quot;_Graph__save__efilter&quot;</span><span class="p">]</span>
            <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">graph_properties</span><span class="p">[</span><span class="s2">&quot;_Graph__save__efilter&quot;</span><span class="p">]</span>
        <span class="k">if</span> <span class="s2">&quot;_Graph__reversed&quot;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">graph_properties</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">set_reversed</span><span class="p">(</span><span class="kc">True</span><span class="p">)</span>
            <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">graph_properties</span><span class="p">[</span><span class="s2">&quot;_Graph__reversed&quot;</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">shrink_to_fit</span><span class="p">()</span></div>

<div class="viewcode-block" id="Graph.save"><a class="viewcode-back" href="https://graph-tool.skewed.de/static/doc/graph_tool.html#graph_tool.Graph.save">[docs]</a>    <span class="k">def</span> <span class="nf">save</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">file_name</span><span class="p">,</span> <span class="n">fmt</span><span class="o">=</span><span class="s2">&quot;auto&quot;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Save graph to ``file_name`` (which can be either a string or a file-like</span>
<span class="sd">        object). The format is guessed from the ``file_name``, or can be</span>
<span class="sd">        specified by ``fmt``, which can be either &quot;gt&quot;, &quot;graphml&quot;, &quot;xml&quot;, &quot;dot&quot;</span>
<span class="sd">        or &quot;gml&quot;.  (Note that &quot;graphml&quot; and &quot;xml&quot; are synonyms).</span>

<span class="sd">        .. warning::</span>

<span class="sd">           The only file formats which are capable of perfectly preserving the</span>
<span class="sd">           internal property maps are &quot;gt&quot; and &quot;graphml&quot;. Because of this,</span>
<span class="sd">           they should be preferred over the other formats whenever possible.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">u</span> <span class="o">=</span> <span class="n">GraphView</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="nb">reversed</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">is_reversed</span><span class="p">(),</span> <span class="n">skip_vfilt</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                      <span class="n">skip_efilt</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_vertex_filter</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">u</span><span class="o">.</span><span class="n">graph_properties</span><span class="p">[</span><span class="s2">&quot;_Graph__save__vfilter&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">new_graph_property</span><span class="p">(</span><span class="s2">&quot;bool&quot;</span><span class="p">)</span>
            <span class="n">u</span><span class="o">.</span><span class="n">vertex_properties</span><span class="p">[</span><span class="s2">&quot;_Graph__save__vfilter&quot;</span><span class="p">]</span> <span class="o">=</span>  <span class="bp">self</span><span class="o">.</span><span class="n">get_vertex_filter</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">u</span><span class="o">.</span><span class="n">graph_properties</span><span class="p">[</span><span class="s2">&quot;_Graph__save__vfilter&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_vertex_filter</span><span class="p">()[</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_edge_filter</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">u</span><span class="o">.</span><span class="n">graph_properties</span><span class="p">[</span><span class="s2">&quot;_Graph__save__efilter&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">new_graph_property</span><span class="p">(</span><span class="s2">&quot;bool&quot;</span><span class="p">)</span>
            <span class="n">u</span><span class="o">.</span><span class="n">edge_properties</span><span class="p">[</span><span class="s2">&quot;_Graph__save__efilter&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_edge_filter</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">u</span><span class="o">.</span><span class="n">graph_properties</span><span class="p">[</span><span class="s2">&quot;_Graph__save__efilter&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_edge_filter</span><span class="p">()[</span><span class="mi">1</span><span class="p">]</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_reversed</span><span class="p">():</span>
            <span class="n">u</span><span class="o">.</span><span class="n">graph_properties</span><span class="p">[</span><span class="s2">&quot;_Graph__reversed&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">new_graph_property</span><span class="p">(</span><span class="s2">&quot;bool&quot;</span><span class="p">)</span>
            <span class="n">u</span><span class="o">.</span><span class="n">graph_properties</span><span class="p">[</span><span class="s2">&quot;_Graph__reversed&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">file_name</span><span class="p">,</span> <span class="p">(</span><span class="nb">str</span><span class="p">,</span> <span class="n">unicode</span><span class="p">)):</span>
            <span class="n">file_name</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">expanduser</span><span class="p">(</span><span class="n">file_name</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">fmt</span> <span class="o">==</span> <span class="s1">&#39;auto&#39;</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">file_name</span><span class="p">,</span> <span class="p">(</span><span class="nb">str</span><span class="p">,</span> <span class="n">unicode</span><span class="p">)):</span>
            <span class="n">fmt</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__get_file_format</span><span class="p">(</span><span class="n">file_name</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">fmt</span> <span class="o">==</span> <span class="s2">&quot;auto&quot;</span><span class="p">:</span>
            <span class="n">fmt</span> <span class="o">=</span> <span class="s2">&quot;gt&quot;</span>
        <span class="k">if</span> <span class="n">fmt</span> <span class="o">==</span> <span class="s2">&quot;graphml&quot;</span><span class="p">:</span>
            <span class="n">fmt</span> <span class="o">=</span> <span class="s2">&quot;xml&quot;</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">file_name</span><span class="p">,</span> <span class="p">(</span><span class="nb">str</span><span class="p">,</span> <span class="n">unicode</span><span class="p">))</span> <span class="ow">and</span> <span class="n">file_name</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="s2">&quot;.xz&quot;</span><span class="p">):</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">file_name</span> <span class="o">=</span> <span class="n">lzma</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="n">file_name</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s2">&quot;wb&quot;</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">NameError</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;lzma compression is only available in Python &gt;= 3.3&quot;</span><span class="p">)</span>

        <span class="n">props</span> <span class="o">=</span> <span class="p">[(</span><span class="n">_c_str</span><span class="p">(</span><span class="n">name</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span> <span class="n">prop</span><span class="o">.</span><span class="n">_PropertyMap__map</span><span class="p">)</span> <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">prop</span> <span class="ow">in</span> \
                 <span class="n">u</span><span class="o">.</span><span class="n">__properties</span><span class="o">.</span><span class="n">items</span><span class="p">()]</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">file_name</span><span class="p">,</span> <span class="p">(</span><span class="nb">str</span><span class="p">,</span> <span class="n">unicode</span><span class="p">)):</span>
            <span class="n">f</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="n">file_name</span><span class="p">,</span> <span class="s2">&quot;w&quot;</span><span class="p">)</span> <span class="c1"># throw the appropriate exception, if</span>
                                     <span class="c1"># unable to open</span>
            <span class="n">f</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
            <span class="n">u</span><span class="o">.</span><span class="n">__graph</span><span class="o">.</span><span class="n">write_to_file</span><span class="p">(</span><span class="n">_c_str</span><span class="p">(</span><span class="n">file_name</span><span class="p">),</span> <span class="kc">None</span><span class="p">,</span> <span class="n">_c_str</span><span class="p">(</span><span class="n">fmt</span><span class="p">),</span> <span class="n">props</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">u</span><span class="o">.</span><span class="n">__graph</span><span class="o">.</span><span class="n">write_to_file</span><span class="p">(</span><span class="s2">&quot;&quot;</span><span class="p">,</span> <span class="n">file_name</span><span class="p">,</span> <span class="n">_c_str</span><span class="p">(</span><span class="n">fmt</span><span class="p">),</span> <span class="n">props</span><span class="p">)</span></div>


    <span class="c1"># Directedness</span>
    <span class="c1"># ============</span>

<div class="viewcode-block" id="Graph.set_directed"><a class="viewcode-back" href="https://graph-tool.skewed.de/static/doc/graph_tool.html#graph_tool.Graph.set_directed">[docs]</a>    <span class="k">def</span> <span class="nf">set_directed</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">is_directed</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Set the directedness of the graph.</span>

<span class="sd">        .. note::</span>

<span class="sd">           This is a :math:`O(1)` operation that does not modify the storage of</span>
<span class="sd">           the graph.</span>

<span class="sd">        .. warning::</span>

<span class="sd">           Changing directedness will invalidate existing vertex and edge</span>
<span class="sd">           descriptors, which will still point to the original graph.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__graph</span><span class="o">.</span><span class="n">set_directed</span><span class="p">(</span><span class="n">is_directed</span><span class="p">)</span></div>

<div class="viewcode-block" id="Graph.is_directed"><a class="viewcode-back" href="https://graph-tool.skewed.de/static/doc/graph_tool.html#graph_tool.Graph.is_directed">[docs]</a>    <span class="k">def</span> <span class="nf">is_directed</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Get the directedness of the graph.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__graph</span><span class="o">.</span><span class="n">get_directed</span><span class="p">()</span></div>

    <span class="c1"># Reversedness</span>
    <span class="c1"># ============</span>

<div class="viewcode-block" id="Graph.set_reversed"><a class="viewcode-back" href="https://graph-tool.skewed.de/static/doc/graph_tool.html#graph_tool.Graph.set_reversed">[docs]</a>    <span class="k">def</span> <span class="nf">set_reversed</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">is_reversed</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Reverse the direction of the edges, if ``is_reversed`` is ``True``,</span>
<span class="sd">        or maintain the original direction otherwise.</span>

<span class="sd">        .. note::</span>

<span class="sd">           This is a :math:`O(1)` operation that does not modify the storage of</span>
<span class="sd">           the graph.</span>

<span class="sd">        .. warning::</span>

<span class="sd">           Reversing the graph will invalidate existing vertex and edge</span>
<span class="sd">           descriptors, which will still point to the original graph.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__graph</span><span class="o">.</span><span class="n">set_reversed</span><span class="p">(</span><span class="n">is_reversed</span><span class="p">)</span></div>

<div class="viewcode-block" id="Graph.is_reversed"><a class="viewcode-back" href="https://graph-tool.skewed.de/static/doc/graph_tool.html#graph_tool.Graph.is_reversed">[docs]</a>    <span class="k">def</span> <span class="nf">is_reversed</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return ``True`` if the edges are reversed, and ``False`` otherwise.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__graph</span><span class="o">.</span><span class="n">get_reversed</span><span class="p">()</span></div>

    <span class="c1"># Filtering</span>
    <span class="c1"># =========</span>

<div class="viewcode-block" id="Graph.set_filters"><a class="viewcode-back" href="https://graph-tool.skewed.de/static/doc/graph_tool.html#graph_tool.Graph.set_filters">[docs]</a>    <span class="k">def</span> <span class="nf">set_filters</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">eprop</span><span class="p">,</span> <span class="n">vprop</span><span class="p">,</span> <span class="n">inverted_edges</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">inverted_vertices</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Set the boolean properties for edge and vertex filters, respectively.  Only</span>
<span class="sd">        the vertices and edges with value different than ``False`` are kept in</span>
<span class="sd">        the filtered graph. If either the ``inverted_edges`` or</span>
<span class="sd">        ``inverted_vertex`` options are supplied with the value ``True``, only</span>
<span class="sd">        the edges or vertices with value ``False`` are kept. If any of the</span>
<span class="sd">        supplied property is ``None``, an empty filter is constructed which</span>
<span class="sd">        allows all edges or vertices.</span>

<span class="sd">        .. note::</span>

<span class="sd">           This is a :math:`O(1)` operation that does not modify the storage of</span>
<span class="sd">           the graph.</span>

<span class="sd">        .. warning::</span>

<span class="sd">           Setting vertex or edge filters will invalidate existing vertex and</span>
<span class="sd">           edge descriptors, which will still point to the unfiltered graph.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">eprop</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">vprop</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span>

        <span class="k">if</span> <span class="n">eprop</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">eprop</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">new_edge_property</span><span class="p">(</span><span class="s2">&quot;bool&quot;</span><span class="p">)</span>
            <span class="n">eprop</span><span class="o">.</span><span class="n">a</span> <span class="o">=</span> <span class="ow">not</span> <span class="n">inverted_edges</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">eprop</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">own_property</span><span class="p">(</span><span class="n">eprop</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">vprop</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">vprop</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">new_vertex_property</span><span class="p">(</span><span class="s2">&quot;bool&quot;</span><span class="p">)</span>
            <span class="n">vprop</span><span class="o">.</span><span class="n">a</span> <span class="o">=</span> <span class="ow">not</span> <span class="n">inverted_vertices</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">vprop</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">own_property</span><span class="p">(</span><span class="n">vprop</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">__graph</span><span class="o">.</span><span class="n">set_vertex_filter_property</span><span class="p">(</span><span class="n">_prop</span><span class="p">(</span><span class="s2">&quot;v&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="p">,</span> <span class="n">vprop</span><span class="p">),</span>
                                                <span class="n">inverted_vertices</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__filter_state</span><span class="p">[</span><span class="s2">&quot;vertex_filter&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">vprop</span><span class="p">,</span> <span class="n">inverted_vertices</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">__graph</span><span class="o">.</span><span class="n">set_edge_filter_property</span><span class="p">(</span><span class="n">_prop</span><span class="p">(</span><span class="s2">&quot;e&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="p">,</span> <span class="n">eprop</span><span class="p">),</span>
                                              <span class="n">inverted_edges</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__filter_state</span><span class="p">[</span><span class="s2">&quot;edge_filter&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">eprop</span><span class="p">,</span> <span class="n">inverted_edges</span><span class="p">)</span></div>

<div class="viewcode-block" id="Graph.set_vertex_filter"><a class="viewcode-back" href="https://graph-tool.skewed.de/static/doc/graph_tool.html#graph_tool.Graph.set_vertex_filter">[docs]</a>    <span class="k">def</span> <span class="nf">set_vertex_filter</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">prop</span><span class="p">,</span> <span class="n">inverted</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Set the vertex boolean filter property. Only the vertices with value</span>
<span class="sd">        different than ``False`` are kept in the filtered graph. If the ``inverted``</span>
<span class="sd">        option is supplied with value ``True``, only the vertices with value</span>
<span class="sd">        ``False`` are kept. If the supplied property is ``None``, the filter is</span>
<span class="sd">        replaced by an uniform filter allowing all vertices.</span>

<span class="sd">        .. note::</span>

<span class="sd">           This is a :math:`O(1)` operation that does not modify the storage of</span>
<span class="sd">           the graph.</span>

<span class="sd">        .. warning::</span>

<span class="sd">           Setting vertex filters will invalidate existing vertex and edge</span>
<span class="sd">           descriptors, which will still point to the unfiltered graph.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">prop</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">prop</span><span class="o">.</span><span class="n">value_type</span><span class="p">()</span> <span class="o">!=</span> <span class="s2">&quot;bool&quot;</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;filter property map must have &#39;bool&#39; type&quot;</span><span class="p">)</span>

        <span class="n">vfilt</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">own_property</span><span class="p">(</span><span class="n">prop</span><span class="p">)</span> <span class="k">if</span> <span class="n">prop</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">prop</span>
        <span class="n">efilt</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="n">eprop</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_edge_filter</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">eprop</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">vfilt</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">efilt</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">new_edge_property</span><span class="p">(</span><span class="s2">&quot;bool&quot;</span><span class="p">)</span>
            <span class="n">efilt</span><span class="o">.</span><span class="n">a</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">if</span> <span class="n">eprop</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">vfilt</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">vfilt</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">new_vertex_property</span><span class="p">(</span><span class="s2">&quot;bool&quot;</span><span class="p">)</span>
            <span class="n">vfilt</span><span class="o">.</span><span class="n">a</span> <span class="o">=</span> <span class="ow">not</span> <span class="n">inverted</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">__graph</span><span class="o">.</span><span class="n">set_vertex_filter_property</span><span class="p">(</span><span class="n">_prop</span><span class="p">(</span><span class="s2">&quot;v&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="p">,</span> <span class="n">vfilt</span><span class="p">),</span>
                                                <span class="n">inverted</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__filter_state</span><span class="p">[</span><span class="s2">&quot;vertex_filter&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">vfilt</span><span class="p">,</span> <span class="n">inverted</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">efilt</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">set_edge_filter</span><span class="p">(</span><span class="n">efilt</span><span class="p">)</span></div>

<div class="viewcode-block" id="Graph.get_vertex_filter"><a class="viewcode-back" href="https://graph-tool.skewed.de/static/doc/graph_tool.html#graph_tool.Graph.get_vertex_filter">[docs]</a>    <span class="k">def</span> <span class="nf">get_vertex_filter</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return a tuple with the vertex filter property and bool value</span>
<span class="sd">        indicating whether or not it is inverted.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__filter_state</span><span class="p">[</span><span class="s2">&quot;vertex_filter&quot;</span><span class="p">]</span></div>

<div class="viewcode-block" id="Graph.set_edge_filter"><a class="viewcode-back" href="https://graph-tool.skewed.de/static/doc/graph_tool.html#graph_tool.Graph.set_edge_filter">[docs]</a>    <span class="k">def</span> <span class="nf">set_edge_filter</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">prop</span><span class="p">,</span> <span class="n">inverted</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Set the edge boolean filter property. Only the edges with value</span>
<span class="sd">        different than ``False`` are kept in the filtered graph. If the ``inverted``</span>
<span class="sd">        option is supplied with value ``True``, only the edges with value ``False``</span>
<span class="sd">        are kept. If the supplied property is ``None``, the filter is</span>
<span class="sd">        replaced by an uniform filter allowing all edges.</span>

<span class="sd">        .. note::</span>

<span class="sd">           This is a :math:`O(1)` operation that does not modify the storage of</span>
<span class="sd">           the graph.</span>

<span class="sd">        .. warning::</span>

<span class="sd">           Setting edge filters will invalidate existing vertex and edge</span>
<span class="sd">           descriptors, which will still point to the unfiltered graph.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">prop</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">prop</span><span class="o">.</span><span class="n">value_type</span><span class="p">()</span> <span class="o">!=</span> <span class="s2">&quot;bool&quot;</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;filter property map must have &#39;bool&#39; type&quot;</span><span class="p">)</span>

        <span class="n">efilt</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">own_property</span><span class="p">(</span><span class="n">prop</span><span class="p">)</span> <span class="k">if</span> <span class="n">prop</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">prop</span>
        <span class="n">vfilt</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="n">vprop</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_vertex_filter</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">vprop</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">efilt</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">vfilt</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">new_vertex_property</span><span class="p">(</span><span class="s2">&quot;bool&quot;</span><span class="p">)</span>
            <span class="n">vfilt</span><span class="o">.</span><span class="n">a</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">if</span> <span class="n">vprop</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">efilt</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">efilt</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">new_edge_property</span><span class="p">(</span><span class="s2">&quot;bool&quot;</span><span class="p">)</span>
            <span class="n">efilt</span><span class="o">.</span><span class="n">a</span> <span class="o">=</span> <span class="ow">not</span> <span class="n">inverted</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__graph</span><span class="o">.</span><span class="n">set_edge_filter_property</span><span class="p">(</span><span class="n">_prop</span><span class="p">(</span><span class="s2">&quot;e&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="p">,</span> <span class="n">efilt</span><span class="p">),</span> <span class="n">inverted</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__filter_state</span><span class="p">[</span><span class="s2">&quot;edge_filter&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">efilt</span><span class="p">,</span> <span class="n">inverted</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">vfilt</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">set_vertex_filter</span><span class="p">(</span><span class="n">vfilt</span><span class="p">)</span></div>

<div class="viewcode-block" id="Graph.get_edge_filter"><a class="viewcode-back" href="https://graph-tool.skewed.de/static/doc/graph_tool.html#graph_tool.Graph.get_edge_filter">[docs]</a>    <span class="k">def</span> <span class="nf">get_edge_filter</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return a tuple with the edge filter property and bool value</span>
<span class="sd">        indicating whether or not it is inverted.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__filter_state</span><span class="p">[</span><span class="s2">&quot;edge_filter&quot;</span><span class="p">]</span></div>

<div class="viewcode-block" id="Graph.clear_filters"><a class="viewcode-back" href="https://graph-tool.skewed.de/static/doc/graph_tool.html#graph_tool.Graph.clear_filters">[docs]</a>    <span class="k">def</span> <span class="nf">clear_filters</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Remove vertex and edge filters, and set the graph to the unfiltered</span>
<span class="sd">        state.</span>

<span class="sd">        .. note::</span>

<span class="sd">           This is a :math:`O(1)` operation that does not modify the storage of</span>
<span class="sd">           the graph.</span>

<span class="sd">        .. warning::</span>

<span class="sd">           Clearing vertex and edge filters will invalidate existing vertex and</span>
<span class="sd">           edge descriptors.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__graph</span><span class="o">.</span><span class="n">set_vertex_filter_property</span><span class="p">(</span><span class="n">_prop</span><span class="p">(</span><span class="s2">&quot;v&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="p">,</span> <span class="kc">None</span><span class="p">),</span> <span class="kc">False</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__filter_state</span><span class="p">[</span><span class="s2">&quot;vertex_filter&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__graph</span><span class="o">.</span><span class="n">set_edge_filter_property</span><span class="p">(</span><span class="n">_prop</span><span class="p">(</span><span class="s2">&quot;e&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="p">,</span> <span class="kc">None</span><span class="p">),</span> <span class="kc">False</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__filter_state</span><span class="p">[</span><span class="s2">&quot;edge_filter&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span></div>

<div class="viewcode-block" id="Graph.purge_vertices"><a class="viewcode-back" href="https://graph-tool.skewed.de/static/doc/graph_tool.html#graph_tool.Graph.purge_vertices">[docs]</a>    <span class="k">def</span> <span class="nf">purge_vertices</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">in_place</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Remove all vertices of the graph which are currently being filtered out. This</span>
<span class="sd">        operation is not reversible.</span>

<span class="sd">        If the option ``in_place == True`` is given, the algorithm will remove</span>
<span class="sd">        the filtered vertices and re-index all property maps which are tied with</span>
<span class="sd">        the graph. This is a slow operation which has an :math:`O(V^2)`</span>
<span class="sd">        complexity.</span>

<span class="sd">        If ``in_place == False``, the graph and its vertex and edge property</span>
<span class="sd">        maps are temporarily copied to a new unfiltered graph, which will</span>
<span class="sd">        replace the contents of the original graph. This is a fast operation</span>
<span class="sd">        with an :math:`O(V + E)` complexity. This is the default behaviour if no</span>
<span class="sd">        option is given.</span>

<span class="sd">        .. note :</span>

<span class="sd">           The graph will remain in a filtered state after this operation, since</span>
<span class="sd">           there might be edge filters present. To return the graph to an</span>
<span class="sd">           unfiltered state, use :meth:`~graph_tool.Graph.clear_filters`.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">in_place</span><span class="p">:</span>
            <span class="n">old_indexes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">vertex_index</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="s2">&quot;int64_t&quot;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__graph</span><span class="o">.</span><span class="n">purge_vertices</span><span class="p">(</span><span class="n">_prop</span><span class="p">(</span><span class="s2">&quot;v&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="p">,</span> <span class="n">old_indexes</span><span class="p">))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">set_vertex_filter</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">pmap</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">__known_properties</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">pmap</span><span class="p">()</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">pmap</span><span class="p">()</span><span class="o">.</span><span class="n">key_type</span><span class="p">()</span> <span class="o">==</span> <span class="s2">&quot;v&quot;</span> <span class="ow">and</span>
                    <span class="n">pmap</span><span class="p">()</span><span class="o">.</span><span class="n">is_writable</span><span class="p">()</span> <span class="ow">and</span>
                    <span class="n">pmap</span><span class="p">()</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">vertex_index</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">edge_index</span><span class="p">]):</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">__graph</span><span class="o">.</span><span class="n">re_index_vertex_property</span><span class="p">(</span><span class="n">_prop</span><span class="p">(</span><span class="s2">&quot;v&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="p">,</span> <span class="n">pmap</span><span class="p">()),</span>
                                                          <span class="n">_prop</span><span class="p">(</span><span class="s2">&quot;v&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="p">,</span> <span class="n">old_indexes</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">stamp</span> <span class="o">=</span> <span class="nb">id</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
            <span class="n">pmaps</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">pmap</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">__known_properties</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">pmap</span><span class="p">()</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">pmap</span><span class="p">()</span><span class="o">.</span><span class="n">key_type</span><span class="p">()</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;v&quot;</span><span class="p">,</span> <span class="s2">&quot;e&quot;</span><span class="p">]</span> <span class="ow">and</span>
                    <span class="n">pmap</span><span class="p">()</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">vertex_index</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">edge_index</span><span class="p">]):</span>
                    <span class="n">pmaps</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">pmap</span><span class="p">())</span>
                    <span class="n">pname</span> <span class="o">=</span> <span class="s2">&quot;__tmp_purge_vertices_</span><span class="si">%d</span><span class="s2">_</span><span class="si">%d</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">stamp</span><span class="p">,</span> <span class="nb">id</span><span class="p">(</span><span class="n">pmaps</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]))</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">properties</span><span class="p">[(</span><span class="n">pmaps</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">key_type</span><span class="p">(),</span> <span class="n">pname</span><span class="p">)]</span> <span class="o">=</span> <span class="n">pmaps</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

            <span class="n">new_g</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">prune</span><span class="o">=</span><span class="p">(</span><span class="kc">True</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="kc">False</span><span class="p">))</span>
            <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;_GraphView__base&quot;</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_GraphView__base</span> <span class="o">=</span> <span class="n">new_g</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__graph</span> <span class="o">=</span> <span class="n">new_g</span><span class="o">.</span><span class="n">__graph</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">set_vertex_filter</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>

            <span class="k">for</span> <span class="n">pmap</span> <span class="ow">in</span> <span class="n">pmaps</span><span class="p">:</span>
                <span class="n">pname</span> <span class="o">=</span> <span class="s2">&quot;__tmp_purge_vertices_</span><span class="si">%d</span><span class="s2">_</span><span class="si">%d</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">stamp</span><span class="p">,</span> <span class="nb">id</span><span class="p">(</span><span class="n">pmap</span><span class="p">))</span>
                <span class="n">new_pmap</span> <span class="o">=</span> <span class="n">new_g</span><span class="o">.</span><span class="n">properties</span><span class="p">[(</span><span class="n">pmap</span><span class="o">.</span><span class="n">key_type</span><span class="p">(),</span> <span class="n">pname</span><span class="p">)]</span>
                <span class="n">pmap</span><span class="o">.</span><span class="n">_PropertyMap__map</span> <span class="o">=</span> <span class="n">new_pmap</span><span class="o">.</span><span class="n">_PropertyMap__map</span>
                <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">properties</span><span class="p">[(</span><span class="n">pmap</span><span class="o">.</span><span class="n">key_type</span><span class="p">(),</span> <span class="n">pname</span><span class="p">)]</span>

            <span class="c1"># update edge filter if set</span>
            <span class="n">efilt</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_edge_filter</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">efilt</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">set_edge_filter</span><span class="p">(</span><span class="n">efilt</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">efilt</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span></div>

<div class="viewcode-block" id="Graph.purge_edges"><a class="viewcode-back" href="https://graph-tool.skewed.de/static/doc/graph_tool.html#graph_tool.Graph.purge_edges">[docs]</a>    <span class="k">def</span> <span class="nf">purge_edges</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Remove all edges of the graph which are currently being filtered out. This</span>
<span class="sd">        operation is not reversible.</span>

<span class="sd">        .. note :</span>

<span class="sd">           The graph will remain in a filtered state after this operation, since</span>
<span class="sd">           there might be vertex filters present. To return the graph to an</span>
<span class="sd">           unfiltered state, use :meth:`~graph_tool.Graph.clear_filters`.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__graph</span><span class="o">.</span><span class="n">purge_edges</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_edge_filter</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">get_filter_state</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return a copy of the filter state of the graph.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__filter_state</span><span class="p">[</span><span class="s2">&quot;directed&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_directed</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__filter_state</span><span class="p">[</span><span class="s2">&quot;reversed&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_reversed</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">copy</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__filter_state</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">set_filter_state</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">state</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Set the filter state of the graph.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">libcore</span><span class="o">.</span><span class="n">graph_filtering_enabled</span><span class="p">():</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">set_vertex_filter</span><span class="p">(</span><span class="n">state</span><span class="p">[</span><span class="s2">&quot;vertex_filter&quot;</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span>
                                   <span class="n">state</span><span class="p">[</span><span class="s2">&quot;vertex_filter&quot;</span><span class="p">][</span><span class="mi">1</span><span class="p">])</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">set_edge_filter</span><span class="p">(</span><span class="n">state</span><span class="p">[</span><span class="s2">&quot;edge_filter&quot;</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span>
                                 <span class="n">state</span><span class="p">[</span><span class="s2">&quot;edge_filter&quot;</span><span class="p">][</span><span class="mi">1</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_directed</span><span class="p">(</span><span class="n">state</span><span class="p">[</span><span class="s2">&quot;directed&quot;</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_reversed</span><span class="p">(</span><span class="n">state</span><span class="p">[</span><span class="s2">&quot;reversed&quot;</span><span class="p">])</span>

    <span class="c1"># Basic graph statistics</span>
    <span class="c1"># ======================</span>

<div class="viewcode-block" id="Graph.num_vertices"><a class="viewcode-back" href="https://graph-tool.skewed.de/static/doc/graph_tool.html#graph_tool.Graph.num_vertices">[docs]</a>    <span class="k">def</span> <span class="nf">num_vertices</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ignore_filter</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Get the number of vertices.</span>

<span class="sd">        If ``ignore_filter == True``, vertex filters are ignored.</span>

<span class="sd">        .. note::</span>

<span class="sd">            If the vertices are being filtered, and ``ignore_filter == False``,</span>
<span class="sd">            this operation is :math:`O(V)`. Otherwise it is :math:`O(1)`.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__graph</span><span class="o">.</span><span class="n">get_num_vertices</span><span class="p">(</span><span class="ow">not</span> <span class="n">ignore_filter</span><span class="p">)</span></div>

<div class="viewcode-block" id="Graph.num_edges"><a class="viewcode-back" href="https://graph-tool.skewed.de/static/doc/graph_tool.html#graph_tool.Graph.num_edges">[docs]</a>    <span class="k">def</span> <span class="nf">num_edges</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ignore_filter</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Get the number of edges.</span>

<span class="sd">        If ``ignore_filter == True``, edge filters are ignored.</span>

<span class="sd">        .. note::</span>

<span class="sd">            If the edges are being filtered, and ``ignore_filter == False``,</span>
<span class="sd">            this operation is :math:`O(E)`. Otherwise it is :math:`O(1)`.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__graph</span><span class="o">.</span><span class="n">get_num_edges</span><span class="p">(</span><span class="ow">not</span> <span class="n">ignore_filter</span><span class="p">)</span></div>

    <span class="c1"># Pickling support</span>
    <span class="c1"># ================</span>

    <span class="k">def</span> <span class="nf">__getstate__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">state</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
        <span class="n">sio</span> <span class="o">=</span> <span class="n">get_bytes_io</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">save</span><span class="p">(</span><span class="n">sio</span><span class="p">,</span> <span class="s2">&quot;gt&quot;</span><span class="p">)</span>
        <span class="n">state</span><span class="p">[</span><span class="s2">&quot;blob&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">sio</span><span class="o">.</span><span class="n">getvalue</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">state</span>

    <span class="k">def</span> <span class="nf">__setstate__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">state</span><span class="p">):</span>
        <span class="n">conv_pickle_state</span><span class="p">(</span><span class="n">state</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="n">blob</span> <span class="o">=</span> <span class="n">state</span><span class="p">[</span><span class="s2">&quot;blob&quot;</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">blob</span> <span class="o">!=</span> <span class="s2">&quot;&quot;</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">sio</span> <span class="o">=</span> <span class="n">get_bytes_io</span><span class="p">(</span><span class="n">blob</span><span class="p">)</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">sio</span><span class="p">,</span> <span class="s2">&quot;gt&quot;</span><span class="p">)</span>
                <span class="k">except</span> <span class="ne">IOError</span><span class="p">:</span>
                    <span class="n">sio</span> <span class="o">=</span> <span class="n">get_bytes_io</span><span class="p">(</span><span class="n">blob</span><span class="p">)</span>
                    <span class="n">stream</span> <span class="o">=</span> <span class="n">gzip</span><span class="o">.</span><span class="n">GzipFile</span><span class="p">(</span><span class="n">fileobj</span><span class="o">=</span><span class="n">sio</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s2">&quot;rb&quot;</span><span class="p">)</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">stream</span><span class="p">,</span> <span class="s2">&quot;gt&quot;</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">IOError</span><span class="p">:</span>
                <span class="n">sio</span> <span class="o">=</span> <span class="n">get_bytes_io</span><span class="p">(</span><span class="n">blob</span><span class="p">)</span>
                <span class="n">stream</span> <span class="o">=</span> <span class="n">gzip</span><span class="o">.</span><span class="n">GzipFile</span><span class="p">(</span><span class="n">fileobj</span><span class="o">=</span><span class="n">sio</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s2">&quot;rb&quot;</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">stream</span><span class="p">,</span> <span class="s2">&quot;xml&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__get_base</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span>
    <span class="n">base</span> <span class="o">=</span> <span class="nb">property</span><span class="p">(</span><span class="n">__get_base</span><span class="p">,</span> <span class="n">doc</span><span class="o">=</span><span class="s2">&quot;Base graph (self).&quot;</span><span class="p">)</span></div>

<div class="viewcode-block" id="load_graph"><a class="viewcode-back" href="https://graph-tool.skewed.de/static/doc/graph_tool.html#graph_tool.load_graph">[docs]</a><span class="k">def</span> <span class="nf">load_graph</span><span class="p">(</span><span class="n">file_name</span><span class="p">,</span> <span class="n">fmt</span><span class="o">=</span><span class="s2">&quot;auto&quot;</span><span class="p">,</span> <span class="n">ignore_vp</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">ignore_ep</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
               <span class="n">ignore_gp</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Load a graph from ``file_name`` (which can be either a string or a file-like object).</span>

<span class="sd">    The format is guessed from ``file_name``, or can be specified by ``fmt``,</span>
<span class="sd">    which can be either &quot;gt&quot;, &quot;graphml&quot;, &quot;xml&quot;, &quot;dot&quot; or &quot;gml&quot;.  (Note that</span>
<span class="sd">    &quot;graphml&quot; and &quot;xml&quot; are synonyms).</span>

<span class="sd">    If provided, the parameters ``ignore_vp``, ``ignore_ep`` and</span>
<span class="sd">    ``ignore_gp``, should contain a list of property names (vertex, edge or</span>
<span class="sd">    graph, respectively) which should be ignored when reading the file.</span>

<span class="sd">    .. warning::</span>

<span class="sd">       The only file formats which are capable of perfectly preserving the</span>
<span class="sd">       internal property maps are &quot;gt&quot; and &quot;graphml&quot;. Because of this,</span>
<span class="sd">       they should be preferred over the other formats whenever possible.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">g</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">()</span>
    <span class="n">g</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">file_name</span><span class="p">,</span> <span class="n">fmt</span><span class="p">,</span> <span class="n">ignore_vp</span><span class="p">,</span> <span class="n">ignore_ep</span><span class="p">,</span> <span class="n">ignore_gp</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">g</span></div>

<div class="viewcode-block" id="load_graph_from_csv"><a class="viewcode-back" href="https://graph-tool.skewed.de/static/doc/graph_tool.html#graph_tool.load_graph_from_csv">[docs]</a><span class="k">def</span> <span class="nf">load_graph_from_csv</span><span class="p">(</span><span class="n">file_name</span><span class="p">,</span> <span class="n">directed</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">eprop_types</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                        <span class="n">eprop_names</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">string_vals</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">hashed</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                        <span class="n">skip_first</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">ecols</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">),</span>
                        <span class="n">csv_options</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;delimiter&quot;</span><span class="p">:</span> <span class="s2">&quot;,&quot;</span><span class="p">,</span><span class="s2">&quot;quotechar&quot;</span><span class="p">:</span> <span class="s1">&#39;&quot;&#39;</span><span class="p">}):</span>
    <span class="sd">&quot;&quot;&quot;Load a graph from a :mod:`csv` file containing a list of edges and edge</span>
<span class="sd">    properties.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    file_name : ``str`` or file-like object</span>
<span class="sd">        File in :mod:``csv`` format, with edges given in each row.</span>
<span class="sd">    directed : ``bool`` (optional, default: ``False``)</span>
<span class="sd">        Whether or not the graph is directed.</span>
<span class="sd">    eprop_types : list of ``str`` (optional, default: ``None``)</span>
<span class="sd">        List of edge property types to be read from remaining columns (if this</span>
<span class="sd">        is ``None``, all properties will be of type ``string``.</span>
<span class="sd">    eprop_names : list of ``str`` (optional, default: ``None``)</span>
<span class="sd">        List of edge property names to be used for the remaining columns (if this</span>
<span class="sd">        is ``None``, the properties will be called &quot;c1, c2, ...&quot;).</span>
<span class="sd">    string_vals : ``bool`` (optional, default: ``True``)</span>
<span class="sd">        If ``True``, the vertex values are assumed to be arbitrary strings,</span>
<span class="sd">        otherwise they will be assumed to correspond to integers.</span>
<span class="sd">    hashed : ``bool`` (optional, default: ``False``)</span>
<span class="sd">        If ``True`` and ``string_vals == False``, the vertex values in the edge</span>
<span class="sd">        list are not assumed to correspond to vertex indices directly. In this</span>
<span class="sd">        case they will be mapped to vertex indices according to the order in</span>
<span class="sd">        which they are encountered, and a vertex property map with the vertex</span>
<span class="sd">        values is returned. If ``string_vals == True``, this automatically means</span>
<span class="sd">        ``hashed = True``.</span>
<span class="sd">    skip_first : ``bool`` (optional, default: ``False``)</span>
<span class="sd">        If ``True`` the first line of the file will be skipped.</span>
<span class="sd">    ecols : pair of ``int`` (optional, default: ``(0,1)``)</span>
<span class="sd">        Line columns used as source and target for the edges.</span>
<span class="sd">    csv_options : ``dict`` (optional, default: ``{&quot;delimiter&quot;: &quot;,&quot;, &quot;quotechar&quot;: &#39;&quot;&#39;}``)</span>
<span class="sd">        Options to be passed to the :func:`csv.reader` parser.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    g : :class:`~graph_tool.Graph`</span>
<span class="sd">        The loaded graph. It will contain additional columns in the file as</span>
<span class="sd">        internal edge property maps. If ``hashed == True``, it will also contain</span>
<span class="sd">        an internal vertex property map with the vertex names.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">file_name</span><span class="p">,</span> <span class="p">(</span><span class="nb">str</span><span class="p">,</span> <span class="n">unicode</span><span class="p">)):</span>
        <span class="k">if</span> <span class="n">file_name</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="s2">&quot;.xz&quot;</span><span class="p">):</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">file_name</span> <span class="o">=</span> <span class="n">lzma</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="n">file_name</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s2">&quot;r&quot;</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">ImportError</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;lzma compression is only available in Python &gt;= 3.3&quot;</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">file_name</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="s2">&quot;.gz&quot;</span><span class="p">):</span>
            <span class="n">file_name</span> <span class="o">=</span> <span class="n">gzip</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="n">file_name</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s2">&quot;r&quot;</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">file_name</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="s2">&quot;.bz2&quot;</span><span class="p">):</span>
            <span class="n">file_name</span> <span class="o">=</span> <span class="n">bz2</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="n">file_name</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s2">&quot;r&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">file_name</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="n">file_name</span><span class="p">,</span> <span class="s2">&quot;r&quot;</span><span class="p">)</span>
    <span class="n">_csv_options</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;delimiter&quot;</span><span class="p">:</span> <span class="s2">&quot;,&quot;</span><span class="p">,</span> <span class="s2">&quot;quotechar&quot;</span><span class="p">:</span> <span class="s1">&#39;&quot;&#39;</span><span class="p">}</span>
    <span class="n">_csv_options</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">csv_options</span><span class="p">)</span>
    <span class="n">r</span> <span class="o">=</span> <span class="n">csv</span><span class="o">.</span><span class="n">reader</span><span class="p">(</span><span class="n">file_name</span><span class="p">,</span> <span class="o">**</span><span class="n">_csv_options</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">skip_first</span><span class="p">:</span>
        <span class="nb">next</span><span class="p">(</span><span class="n">r</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">ecols</span> <span class="o">!=</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">):</span>
        <span class="k">def</span> <span class="nf">reorder</span><span class="p">(</span><span class="n">rows</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">rows</span><span class="p">:</span>
                <span class="n">row</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">row</span><span class="p">)</span>
                <span class="n">s</span> <span class="o">=</span> <span class="n">row</span><span class="p">[</span><span class="n">ecols</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
                <span class="n">t</span> <span class="o">=</span> <span class="n">row</span><span class="p">[</span><span class="n">ecols</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span>
                <span class="k">del</span> <span class="n">row</span><span class="p">[</span><span class="nb">min</span><span class="p">(</span><span class="n">ecols</span><span class="p">)]</span>
                <span class="k">del</span> <span class="n">row</span><span class="p">[</span><span class="nb">max</span><span class="p">(</span><span class="n">ecols</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
                <span class="k">yield</span> <span class="p">[</span><span class="n">s</span><span class="p">,</span> <span class="n">t</span><span class="p">]</span> <span class="o">+</span> <span class="n">row</span>
        <span class="n">r</span> <span class="o">=</span> <span class="n">reorder</span><span class="p">(</span><span class="n">r</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">string_vals</span><span class="p">:</span>
        <span class="k">def</span> <span class="nf">conv</span><span class="p">(</span><span class="n">rows</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">rows</span><span class="p">:</span>
                <span class="n">row</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">row</span><span class="p">)</span>
                <span class="n">row</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">row</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
                <span class="n">row</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">row</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
                <span class="k">yield</span> <span class="n">row</span>
        <span class="n">r</span> <span class="o">=</span> <span class="n">conv</span><span class="p">(</span><span class="n">r</span><span class="p">)</span>
    <span class="n">line</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="n">r</span><span class="p">)</span>
    <span class="n">g</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">(</span><span class="n">directed</span><span class="o">=</span><span class="n">directed</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">eprop_types</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">eprops</span> <span class="o">=</span> <span class="p">[</span><span class="n">g</span><span class="o">.</span><span class="n">new_ep</span><span class="p">(</span><span class="s2">&quot;string&quot;</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">line</span><span class="p">[</span><span class="mi">2</span><span class="p">:]]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">eprops</span> <span class="o">=</span> <span class="p">[</span><span class="n">g</span><span class="o">.</span><span class="n">new_ep</span><span class="p">(</span><span class="n">t</span><span class="p">)</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">eprop_types</span><span class="p">]</span>

    <span class="n">name</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">add_edge_list</span><span class="p">(</span><span class="n">itertools</span><span class="o">.</span><span class="n">chain</span><span class="p">([</span><span class="n">line</span><span class="p">],</span> <span class="n">r</span><span class="p">),</span>
                           <span class="n">string_vals</span><span class="o">=</span><span class="n">string_vals</span><span class="p">,</span>
                           <span class="n">hashed</span><span class="o">=</span><span class="n">hashed</span> <span class="ow">or</span> <span class="n">string_vals</span><span class="p">,</span>
                           <span class="n">eprops</span><span class="o">=</span><span class="n">eprops</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">p</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">eprops</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">eprop_names</span><span class="p">:</span>
            <span class="n">ename</span> <span class="o">=</span> <span class="n">eprop_names</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">ename</span> <span class="o">=</span> <span class="s2">&quot;c</span><span class="si">%d</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">i</span>
        <span class="n">g</span><span class="o">.</span><span class="n">ep</span><span class="p">[</span><span class="n">ename</span><span class="p">]</span> <span class="o">=</span> <span class="n">p</span>

    <span class="k">if</span> <span class="n">name</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">g</span><span class="o">.</span><span class="n">vp</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span>
    <span class="k">return</span> <span class="n">g</span></div>


<div class="viewcode-block" id="GraphView"><a class="viewcode-back" href="https://graph-tool.skewed.de/static/doc/graph_tool.html#graph_tool.GraphView">[docs]</a><span class="k">class</span> <span class="nc">GraphView</span><span class="p">(</span><span class="n">Graph</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;A view of selected vertices or edges of another graph.</span>

<span class="sd">    This class uses shared data from another :class:`~graph_tool.Graph`</span>
<span class="sd">    instance, but allows for local filtering of vertices and/or edges, edge</span>
<span class="sd">    directionality or reversal. See :ref:`sec_graph_views` for more details and</span>
<span class="sd">    examples.</span>

<span class="sd">    The existence of a :class:`~graph_tool.GraphView` object does not affect the</span>
<span class="sd">    original graph, except if the graph view is modified (addition or removal of</span>
<span class="sd">    vertices or edges), in which case the modification is directly reflected in</span>
<span class="sd">    the original graph (and vice-versa), since they both point to the same</span>
<span class="sd">    underlying data. Because of this, instances of</span>
<span class="sd">    :class:`~graph_tool.PropertyMap` can be used interchangeably with a graph</span>
<span class="sd">    and its views.</span>

<span class="sd">    The argument ``g`` must be an instance of a :class:`~graph_tool.Graph`</span>
<span class="sd">    class. If specified, ``vfilt`` and ``efilt`` select which vertices and edges</span>
<span class="sd">    are filtered, respectively. These parameters can either be a boolean-valued</span>
<span class="sd">    :class:`~graph_tool.PropertyMap` or a :class:`~numpy.ndarray`, which specify</span>
<span class="sd">    which vertices/edges are selected, or an unary function that returns</span>
<span class="sd">    ``True`` if a given vertex/edge is to be selected, or ``False`` otherwise.</span>

<span class="sd">    The boolean parameter ``directed`` can be used to set the directionality of</span>
<span class="sd">    the graph view. If ``directed is None``, the directionality is inherited</span>
<span class="sd">    from ``g``.</span>

<span class="sd">    If ``reversed == True``, the direction of the edges is reversed.</span>

<span class="sd">    If ``vfilt`` or ``efilt`` is anything other than a</span>
<span class="sd">    :class:`~graph_tool.PropertyMap` instance, the instantiation running time is</span>
<span class="sd">    :math:`O(V)` and :math:`O(E)`, respectively. Otherwise, the running time is</span>
<span class="sd">    :math:`O(1)`.</span>

<span class="sd">    If either ``skip_properties``, ``skip_vfilt`` or ``skip_efilt`` is ``True``,</span>
<span class="sd">    then the internal properties, vertex filter or edge filter of the original</span>
<span class="sd">    graph are ignored, respectively.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">g</span><span class="p">,</span> <span class="n">vfilt</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">efilt</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">directed</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="nb">reversed</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">skip_properties</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">skip_vfilt</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                 <span class="n">skip_efilt</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__base</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">base</span>
        <span class="n">Graph</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="c1"># copy graph reference</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_Graph__graph</span> <span class="o">=</span> <span class="n">libcore</span><span class="o">.</span><span class="n">GraphInterface</span><span class="p">(</span><span class="n">g</span><span class="o">.</span><span class="n">_Graph__graph</span><span class="p">,</span> <span class="kc">True</span><span class="p">,</span>
                                                    <span class="p">[],</span> <span class="p">[],</span>
                                                    <span class="n">_prop</span><span class="p">(</span><span class="s2">&quot;v&quot;</span><span class="p">,</span> <span class="n">g</span><span class="p">,</span> <span class="n">g</span><span class="o">.</span><span class="n">vertex_index</span><span class="p">))</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">skip_properties</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">g</span><span class="o">.</span><span class="n">properties</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">properties</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">own_property</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>

        <span class="c1"># set already existing filters</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">skip_efilt</span><span class="p">:</span>
            <span class="n">ef</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">g</span><span class="o">.</span><span class="n">get_edge_filter</span><span class="p">())</span>
            <span class="k">if</span> <span class="n">ef</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">ef</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">own_property</span><span class="p">(</span><span class="n">ef</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">())</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">ef</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">,</span> <span class="kc">False</span><span class="p">]</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">skip_vfilt</span><span class="p">:</span>
            <span class="n">vf</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">g</span><span class="o">.</span><span class="n">get_vertex_filter</span><span class="p">())</span>
            <span class="k">if</span> <span class="n">vf</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">vf</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">own_property</span><span class="p">(</span><span class="n">vf</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">())</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">vf</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">,</span> <span class="kc">False</span><span class="p">]</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">set_filters</span><span class="p">(</span><span class="n">ef</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">vf</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">ef</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">vf</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>

        <span class="k">if</span> <span class="n">efilt</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">efilt</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">PropertyMap</span><span class="p">:</span>
                <span class="n">emap</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">new_edge_property</span><span class="p">(</span><span class="s2">&quot;bool&quot;</span><span class="p">)</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">efilt</span><span class="p">,</span> <span class="n">collections</span><span class="o">.</span><span class="n">Iterable</span><span class="p">):</span>
                    <span class="n">emap</span><span class="o">.</span><span class="n">fa</span> <span class="o">=</span> <span class="n">efilt</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">g</span><span class="o">.</span><span class="n">edges</span><span class="p">():</span>
                        <span class="n">emap</span><span class="p">[</span><span class="n">e</span><span class="p">]</span> <span class="o">=</span> <span class="n">efilt</span><span class="p">(</span><span class="n">e</span><span class="p">)</span>
                <span class="n">efilt</span> <span class="o">=</span> <span class="n">emap</span>
            <span class="n">efilt</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">own_property</span><span class="p">(</span><span class="n">efilt</span><span class="p">)</span>
            <span class="n">ef</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_edge_filter</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">ef</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">ef</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
                    <span class="n">ef</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">fa</span> <span class="o">=</span> <span class="n">efilt</span><span class="o">.</span><span class="n">fa</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">ef</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">fa</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">logical_not</span><span class="p">(</span><span class="n">efilt</span><span class="o">.</span><span class="n">fa</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">set_edge_filter</span><span class="p">(</span><span class="n">ef</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">ef</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">set_edge_filter</span><span class="p">(</span><span class="n">efilt</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">vfilt</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">vfilt</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">PropertyMap</span><span class="p">:</span>
                <span class="n">vmap</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">new_vertex_property</span><span class="p">(</span><span class="s2">&quot;bool&quot;</span><span class="p">)</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">vfilt</span><span class="p">,</span> <span class="n">collections</span><span class="o">.</span><span class="n">Iterable</span><span class="p">):</span>
                    <span class="n">vmap</span><span class="o">.</span><span class="n">fa</span> <span class="o">=</span> <span class="n">vfilt</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">g</span><span class="o">.</span><span class="n">vertices</span><span class="p">():</span>
                        <span class="n">vmap</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">=</span> <span class="n">vfilt</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
                <span class="n">vfilt</span> <span class="o">=</span> <span class="n">vmap</span>
            <span class="n">vfilt</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">own_property</span><span class="p">(</span><span class="n">vfilt</span><span class="p">)</span>
            <span class="n">vf</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_vertex_filter</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">vf</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">vf</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
                    <span class="n">vf</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">fa</span> <span class="o">=</span> <span class="n">vfilt</span><span class="o">.</span><span class="n">fa</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">vf</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">fa</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">logical_not</span><span class="p">(</span><span class="n">vfilt</span><span class="o">.</span><span class="n">fa</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">set_vertex_filter</span><span class="p">(</span><span class="n">vf</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">vf</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">set_vertex_filter</span><span class="p">(</span><span class="n">vfilt</span><span class="p">)</span>


        <span class="k">if</span> <span class="n">directed</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">set_directed</span><span class="p">(</span><span class="n">directed</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">reversed</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">set_reversed</span><span class="p">(</span><span class="ow">not</span> <span class="n">g</span><span class="o">.</span><span class="n">is_reversed</span><span class="p">())</span>

    <span class="k">def</span> <span class="nf">__get_base</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__base</span>
    <span class="n">base</span> <span class="o">=</span> <span class="nb">property</span><span class="p">(</span><span class="n">__get_base</span><span class="p">,</span> <span class="n">doc</span><span class="o">=</span><span class="s2">&quot;Base graph.&quot;</span><span class="p">)</span>

    <span class="c1"># pickling support</span>
    <span class="k">def</span> <span class="nf">__getstate__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">Graph</span><span class="o">.</span><span class="n">__getstate__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__setstate__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">state</span><span class="p">):</span>
        <span class="n">g</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">()</span>
        <span class="n">g</span><span class="o">.</span><span class="n">__setstate__</span><span class="p">(</span><span class="n">state</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">g</span><span class="p">)</span></div>


<div class="viewcode-block" id="value_types"><a class="viewcode-back" href="https://graph-tool.skewed.de/static/doc/graph_tool.html#graph_tool.value_types">[docs]</a><span class="k">def</span> <span class="nf">value_types</span><span class="p">():</span>
    <span class="sd">&quot;&quot;&quot;Return a list of possible properties value types.&quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">libcore</span><span class="o">.</span><span class="n">get_property_types</span><span class="p">()</span></div>

<span class="c1"># Vertex and Edge Types</span>
<span class="c1"># =====================</span>
<span class="kn">from</span> <span class="nn">.libgraph_tool_core</span> <span class="k">import</span> <span class="n">Vertex</span><span class="p">,</span> <span class="n">Edge</span><span class="p">,</span> <span class="n">VertexBase</span><span class="p">,</span> <span class="n">EdgeBase</span>

<span class="k">def</span> <span class="nf">_out_neighbors</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Return an iterator over the out-neighbors.&quot;&quot;&quot;</span>
    <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">out_edges</span><span class="p">():</span>
        <span class="k">yield</span> <span class="n">e</span><span class="o">.</span><span class="n">target</span><span class="p">()</span>

<span class="k">def</span> <span class="nf">_in_neighbors</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Return an iterator over the in-neighbors.&quot;&quot;&quot;</span>
    <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">in_edges</span><span class="p">():</span>
        <span class="k">yield</span> <span class="n">e</span><span class="o">.</span><span class="n">source</span><span class="p">()</span>

<span class="k">def</span> <span class="nf">_all_edges</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Return an iterator over all edges (both in or out).&quot;&quot;&quot;</span>
    <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">out_edges</span><span class="p">():</span>
        <span class="k">yield</span> <span class="n">e</span>
    <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">in_edges</span><span class="p">():</span>
        <span class="k">yield</span> <span class="n">e</span>

<span class="k">def</span> <span class="nf">_all_neighbors</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Return an iterator over all neighbors (both in or out).&quot;&quot;&quot;</span>
    <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">out_neighbors</span><span class="p">():</span>
        <span class="k">yield</span> <span class="n">v</span>
    <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">in_neighbors</span><span class="p">():</span>
        <span class="k">yield</span> <span class="n">v</span>

<span class="k">def</span> <span class="nf">_in_degree</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">weight</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Return the in-degree of the vertex. If provided, ``weight`` should be a</span>
<span class="sd">    scalar edge :class:`~graph_tool.PropertyMap`, and the in-degree will</span>
<span class="sd">    correspond to the sum of the weights of the in-edges.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="n">weight</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__in_degree</span><span class="p">()</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__weighted_in_degree</span><span class="p">(</span><span class="n">_prop</span><span class="p">(</span><span class="s2">&quot;e&quot;</span><span class="p">,</span> <span class="n">weight</span><span class="o">.</span><span class="n">get_graph</span><span class="p">(),</span> <span class="n">weight</span><span class="p">))</span>

<span class="k">def</span> <span class="nf">_out_degree</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">weight</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Return the out-degree of the vertex. If provided, ``weight`` should be a</span>
<span class="sd">    scalar edge :class:`~graph_tool.PropertyMap`, and the out-degree will</span>
<span class="sd">    correspond to the sum of the weights of the out-edges.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="n">weight</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__out_degree</span><span class="p">()</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__weighted_out_degree</span><span class="p">(</span><span class="n">_prop</span><span class="p">(</span><span class="s2">&quot;e&quot;</span><span class="p">,</span> <span class="n">weight</span><span class="o">.</span><span class="n">get_graph</span><span class="p">(),</span> <span class="n">weight</span><span class="p">))</span>

<span class="k">def</span> <span class="nf">_vertex_repr</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_valid</span><span class="p">():</span>
        <span class="k">return</span> <span class="s2">&quot;&lt;invalid Vertex object at 0x</span><span class="si">%x</span><span class="s2">&gt;&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="nb">id</span><span class="p">(</span><span class="bp">self</span><span class="p">))</span>
    <span class="k">return</span> <span class="s2">&quot;&lt;Vertex object with index &#39;</span><span class="si">%d</span><span class="s2">&#39; at 0x</span><span class="si">%x</span><span class="s2">&gt;&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="p">),</span> <span class="nb">id</span><span class="p">(</span><span class="bp">self</span><span class="p">))</span>

<span class="n">_vertex_doc</span> <span class="o">=</span> <span class="s2">&quot;&quot;&quot;Vertex descriptor.</span>

<span class="s2">This class represents a vertex in a :class:`~graph_tool.Graph` instance.</span>

<span class="s2">:class:`~graph_tool.Vertex` instances are hashable, and are convertible to</span>
<span class="s2">integers, corresponding to its index (see :attr:`~graph_tool.Graph.vertex_index`).</span>
<span class="s2">&quot;&quot;&quot;</span>

<span class="k">def</span> <span class="nf">_v_eq</span><span class="p">(</span><span class="n">v1</span><span class="p">,</span> <span class="n">v2</span><span class="p">):</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="k">return</span> <span class="nb">int</span><span class="p">(</span><span class="n">v1</span><span class="p">)</span> <span class="o">==</span> <span class="nb">int</span><span class="p">(</span><span class="n">v2</span><span class="p">)</span>
    <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">False</span>

<span class="k">def</span> <span class="nf">_v_ne</span><span class="p">(</span><span class="n">v1</span><span class="p">,</span> <span class="n">v2</span><span class="p">):</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="k">return</span> <span class="nb">int</span><span class="p">(</span><span class="n">v1</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">int</span><span class="p">(</span><span class="n">v2</span><span class="p">)</span>
    <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">True</span>

<span class="k">def</span> <span class="nf">_v_lt</span><span class="p">(</span><span class="n">v1</span><span class="p">,</span> <span class="n">v2</span><span class="p">):</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="k">return</span> <span class="nb">int</span><span class="p">(</span><span class="n">v1</span><span class="p">)</span> <span class="o">&lt;</span> <span class="nb">int</span><span class="p">(</span><span class="n">v2</span><span class="p">)</span>
    <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">False</span>

<span class="k">def</span> <span class="nf">_v_gt</span><span class="p">(</span><span class="n">v1</span><span class="p">,</span> <span class="n">v2</span><span class="p">):</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="k">return</span> <span class="nb">int</span><span class="p">(</span><span class="n">v1</span><span class="p">)</span> <span class="o">&gt;</span> <span class="nb">int</span><span class="p">(</span><span class="n">v2</span><span class="p">)</span>
    <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">False</span>

<span class="k">def</span> <span class="nf">_v_le</span><span class="p">(</span><span class="n">v1</span><span class="p">,</span> <span class="n">v2</span><span class="p">):</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="k">return</span> <span class="nb">int</span><span class="p">(</span><span class="n">v1</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="nb">int</span><span class="p">(</span><span class="n">v2</span><span class="p">)</span>
    <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">False</span>

<span class="k">def</span> <span class="nf">_v_ge</span><span class="p">(</span><span class="n">v1</span><span class="p">,</span> <span class="n">v2</span><span class="p">):</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="k">return</span> <span class="nb">int</span><span class="p">(</span><span class="n">v1</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="nb">int</span><span class="p">(</span><span class="n">v2</span><span class="p">)</span>
    <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">False</span>

<span class="k">if</span> <span class="n">sys</span><span class="o">.</span><span class="n">version_info</span> <span class="o">&lt;</span> <span class="p">(</span><span class="mi">3</span><span class="p">,):</span>
    <span class="k">def</span> <span class="nf">_v_long</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">long</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="p">))</span>

<span class="k">for</span> <span class="n">Vertex</span> <span class="ow">in</span> <span class="n">libcore</span><span class="o">.</span><span class="n">get_vlist</span><span class="p">():</span>
    <span class="n">Vertex</span><span class="o">.</span><span class="vm">__doc__</span> <span class="o">=</span> <span class="n">_vertex_doc</span>
    <span class="n">Vertex</span><span class="o">.</span><span class="n">out_neighbors</span> <span class="o">=</span> <span class="n">_out_neighbors</span>
    <span class="n">Vertex</span><span class="o">.</span><span class="n">out_neighbours</span> <span class="o">=</span> <span class="n">_out_neighbors</span>
    <span class="n">Vertex</span><span class="o">.</span><span class="n">in_neighbors</span> <span class="o">=</span> <span class="n">_in_neighbors</span>
    <span class="n">Vertex</span><span class="o">.</span><span class="n">all_edges</span> <span class="o">=</span> <span class="n">_all_edges</span>
    <span class="n">Vertex</span><span class="o">.</span><span class="n">all_neighbors</span> <span class="o">=</span> <span class="n">_all_neighbors</span>
    <span class="n">Vertex</span><span class="o">.</span><span class="n">all_neighbours</span> <span class="o">=</span> <span class="n">_all_neighbors</span>
    <span class="n">Vertex</span><span class="o">.</span><span class="n">in_degree</span> <span class="o">=</span> <span class="n">_in_degree</span>
    <span class="n">Vertex</span><span class="o">.</span><span class="n">out_degree</span> <span class="o">=</span> <span class="n">_out_degree</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">Vertex</span><span class="o">.</span><span class="n">is_valid</span><span class="o">.</span><span class="vm">__doc__</span> <span class="o">=</span> <span class="s2">&quot;Returns ``True`` if the descriptor corresponds to an existing vertex in the graph, ``False`` otherwise.&quot;</span>
    <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
        <span class="k">pass</span>
    <span class="n">Vertex</span><span class="o">.</span><span class="fm">__repr__</span> <span class="o">=</span> <span class="n">_vertex_repr</span>
    <span class="n">Vertex</span><span class="o">.</span><span class="fm">__eq__</span> <span class="o">=</span> <span class="n">_v_eq</span>
    <span class="n">Vertex</span><span class="o">.</span><span class="fm">__ne__</span> <span class="o">=</span> <span class="n">_v_ne</span>
    <span class="n">Vertex</span><span class="o">.</span><span class="fm">__lt__</span> <span class="o">=</span> <span class="n">_v_lt</span>
    <span class="n">Vertex</span><span class="o">.</span><span class="fm">__gt__</span> <span class="o">=</span> <span class="n">_v_gt</span>
    <span class="n">Vertex</span><span class="o">.</span><span class="fm">__le__</span> <span class="o">=</span> <span class="n">_v_le</span>
    <span class="n">Vertex</span><span class="o">.</span><span class="fm">__ge__</span> <span class="o">=</span> <span class="n">_v_ge</span>
    <span class="k">if</span> <span class="n">sys</span><span class="o">.</span><span class="n">version_info</span> <span class="o">&lt;</span> <span class="p">(</span><span class="mi">3</span><span class="p">,):</span>
        <span class="n">Vertex</span><span class="o">.</span><span class="n">__long__</span> <span class="o">=</span> <span class="n">_v_long</span>

<span class="n">_edge_doc</span> <span class="o">=</span> <span class="s2">&quot;&quot;&quot;Edge descriptor.</span>

<span class="s2">This class represents an edge in a :class:`~graph_tool.Graph`.</span>

<span class="s2">:class:`~graph_tool.Edge` instances are hashable, iterable and thus are</span>
<span class="s2">convertible to a tuple, which contains the source and target vertices.</span>
<span class="s2">&quot;&quot;&quot;</span>

<span class="k">def</span> <span class="nf">_edge_iter</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Iterate over the source and target&quot;&quot;&quot;</span>
    <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">source</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">target</span><span class="p">()):</span>
        <span class="k">yield</span> <span class="n">v</span>

<span class="k">def</span> <span class="nf">_edge_repr</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_valid</span><span class="p">():</span>
        <span class="k">return</span> <span class="s2">&quot;&lt;invalid Edge object at 0x</span><span class="si">%x</span><span class="s2">&gt;&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="nb">id</span><span class="p">(</span><span class="bp">self</span><span class="p">))</span>

    <span class="k">return</span> <span class="p">(</span><span class="s2">&quot;&lt;Edge object with source &#39;</span><span class="si">%d</span><span class="s2">&#39; and target &#39;</span><span class="si">%d</span><span class="s2">&#39;&quot;</span> <span class="o">+</span>
            <span class="s2">&quot; at 0x</span><span class="si">%x</span><span class="s2">&gt;&quot;</span><span class="p">)</span> <span class="o">%</span> <span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">source</span><span class="p">()),</span> <span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">target</span><span class="p">()),</span> <span class="nb">id</span><span class="p">(</span><span class="bp">self</span><span class="p">))</span>

<span class="c1"># There are several edge classes... me must cycle through them all to modify</span>
<span class="c1"># them.</span>

<span class="k">for</span> <span class="n">Edge</span> <span class="ow">in</span> <span class="n">libcore</span><span class="o">.</span><span class="n">get_elist</span><span class="p">():</span>
    <span class="n">Edge</span><span class="o">.</span><span class="fm">__repr__</span> <span class="o">=</span> <span class="n">_edge_repr</span>
    <span class="n">Edge</span><span class="o">.</span><span class="fm">__iter__</span> <span class="o">=</span> <span class="n">_edge_iter</span>
    <span class="n">Edge</span><span class="o">.</span><span class="vm">__doc__</span> <span class="o">=</span> <span class="n">_edge_doc</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">Edge</span><span class="o">.</span><span class="n">is_valid</span><span class="o">.</span><span class="vm">__doc__</span> <span class="o">=</span> <span class="s2">&quot;Returns ``True`` if the descriptor corresponds to an existing edge in the graph, ``False`` otherwise.&quot;</span>
        <span class="n">Edge</span><span class="o">.</span><span class="n">source</span><span class="o">.</span><span class="vm">__doc__</span> <span class="o">=</span> <span class="s2">&quot;Returns the source of the edge (a :class:`~graph_tool.Vertex` instance).&quot;</span>
        <span class="n">Edge</span><span class="o">.</span><span class="n">target</span><span class="o">.</span><span class="vm">__doc__</span> <span class="o">=</span> <span class="s2">&quot;Returns the target of the edge (a :class:`~graph_tool.Vertex` instance).&quot;</span>
    <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
        <span class="k">pass</span>

<span class="c1"># some shenanigans to make it seem there is only a single edge and vertex class</span>
<span class="n">EdgeBase</span><span class="o">.</span><span class="vm">__doc__</span> <span class="o">=</span> <span class="n">Edge</span><span class="o">.</span><span class="vm">__doc__</span>
<span class="n">EdgeBase</span><span class="o">.</span><span class="n">source</span> <span class="o">=</span> <span class="n">Edge</span><span class="o">.</span><span class="n">source</span>
<span class="n">EdgeBase</span><span class="o">.</span><span class="n">target</span> <span class="o">=</span> <span class="n">Edge</span><span class="o">.</span><span class="n">target</span>
<span class="n">EdgeBase</span><span class="o">.</span><span class="n">is_valid</span> <span class="o">=</span> <span class="n">Edge</span><span class="o">.</span><span class="n">is_valid</span>
<span class="n">Edge</span> <span class="o">=</span> <span class="n">EdgeBase</span>
<span class="n">Edge</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">=</span> <span class="s2">&quot;Edge&quot;</span>

<span class="n">VertexBase</span><span class="o">.</span><span class="vm">__doc__</span> <span class="o">=</span> <span class="n">Vertex</span><span class="o">.</span><span class="vm">__doc__</span>
<span class="n">VertexBase</span><span class="o">.</span><span class="n">out_neighbors</span> <span class="o">=</span> <span class="n">Vertex</span><span class="o">.</span><span class="n">out_neighbors</span>
<span class="n">VertexBase</span><span class="o">.</span><span class="n">in_neighbors</span> <span class="o">=</span> <span class="n">Vertex</span><span class="o">.</span><span class="n">in_neighbors</span>
<span class="n">VertexBase</span><span class="o">.</span><span class="n">out_edges</span> <span class="o">=</span> <span class="n">Vertex</span><span class="o">.</span><span class="n">out_edges</span>
<span class="n">VertexBase</span><span class="o">.</span><span class="n">in_edges</span> <span class="o">=</span> <span class="n">Vertex</span><span class="o">.</span><span class="n">in_edges</span>
<span class="n">VertexBase</span><span class="o">.</span><span class="n">all_edges</span> <span class="o">=</span> <span class="n">Vertex</span><span class="o">.</span><span class="n">all_edges</span>
<span class="n">VertexBase</span><span class="o">.</span><span class="n">all_neighbors</span> <span class="o">=</span> <span class="n">Vertex</span><span class="o">.</span><span class="n">all_neighbors</span>
<span class="n">VertexBase</span><span class="o">.</span><span class="n">in_degree</span> <span class="o">=</span> <span class="n">Vertex</span><span class="o">.</span><span class="n">in_degree</span>
<span class="n">VertexBase</span><span class="o">.</span><span class="n">out_degree</span> <span class="o">=</span> <span class="n">Vertex</span><span class="o">.</span><span class="n">out_degree</span>
<span class="n">VertexBase</span><span class="o">.</span><span class="n">is_valid</span> <span class="o">=</span> <span class="n">Vertex</span><span class="o">.</span><span class="n">is_valid</span>
<span class="n">Vertex</span> <span class="o">=</span> <span class="n">VertexBase</span>
<span class="n">Vertex</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">=</span> <span class="s2">&quot;Vertex&quot;</span>

<span class="n">_get_null_vertex</span> <span class="o">=</span> <span class="n">libcore</span><span class="o">.</span><span class="n">get_null_vertex</span>

<span class="c1"># Add convenience function to vector classes</span>
<span class="k">def</span> <span class="nf">_get_array_view</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_array</span><span class="p">()[:]</span>

<span class="k">def</span> <span class="nf">_set_array_view</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">v</span><span class="p">):</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">get_array</span><span class="p">()[:]</span> <span class="o">=</span> <span class="n">v</span>

<span class="k">def</span> <span class="nf">_vt_getstate</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="n">a</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">a</span>
    <span class="k">if</span> <span class="n">a</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">a</span>

<span class="k">def</span> <span class="nf">_vt_setstate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">state</span><span class="p">):</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">resize</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">state</span><span class="p">))</span>
    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">a</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">a</span> <span class="o">=</span> <span class="n">state</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">state</span><span class="p">)):</span>
            <span class="bp">self</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">state</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>

<span class="k">def</span> <span class="nf">_vt_copy</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="n">v</span> <span class="o">=</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)()</span>
    <span class="n">v</span><span class="o">.</span><span class="n">resize</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">))</span>
    <span class="n">_vt_setstate</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">v</span>

<span class="k">def</span> <span class="nf">_vt_init</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">init</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">__base_init__</span><span class="p">()</span>
    <span class="k">if</span> <span class="n">n</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">resize</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">init</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">_vt_setstate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">init</span><span class="p">)</span>

<span class="n">vector_types</span> <span class="o">=</span> <span class="p">[</span><span class="n">Vector_bool</span><span class="p">,</span> <span class="n">Vector_int16_t</span><span class="p">,</span> <span class="n">Vector_int32_t</span><span class="p">,</span> <span class="n">Vector_int64_t</span><span class="p">,</span>
                <span class="n">Vector_double</span><span class="p">,</span> <span class="n">Vector_long_double</span><span class="p">,</span> <span class="n">Vector_size_t</span><span class="p">]</span>

<span class="k">for</span> <span class="n">vt</span> <span class="ow">in</span> <span class="n">vector_types</span><span class="p">:</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">vt</span><span class="p">,</span> <span class="s2">&quot;__base_init__&quot;</span><span class="p">):</span>
        <span class="n">vt</span><span class="o">.</span><span class="n">__base_init__</span> <span class="o">=</span> <span class="n">vt</span><span class="o">.</span><span class="fm">__init__</span>
        <span class="n">vt</span><span class="o">.</span><span class="fm">__init__</span> <span class="o">=</span> <span class="n">_vt_init</span>
    <span class="n">vt</span><span class="o">.</span><span class="n">a</span> <span class="o">=</span> <span class="nb">property</span><span class="p">(</span><span class="n">_get_array_view</span><span class="p">,</span> <span class="n">_set_array_view</span><span class="p">,</span>
                    <span class="n">doc</span><span class="o">=</span><span class="sa">r</span><span class="s2">&quot;&quot;&quot;Shortcut to the `get_array` method as an attribute.&quot;&quot;&quot;</span><span class="p">)</span>
    <span class="n">vt</span><span class="o">.</span><span class="fm">__repr__</span> <span class="o">=</span> <span class="k">lambda</span> <span class="bp">self</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">a</span><span class="o">.</span><span class="fm">__repr__</span><span class="p">()</span>
    <span class="n">vt</span><span class="o">.</span><span class="n">copy</span> <span class="o">=</span> <span class="n">_vt_copy</span>
    <span class="n">vt</span><span class="o">.</span><span class="n">__copy__</span> <span class="o">=</span> <span class="n">vt</span><span class="o">.</span><span class="n">copy</span>
    <span class="n">vt</span><span class="o">.</span><span class="n">__getstate__</span> <span class="o">=</span> <span class="n">_vt_getstate</span>
    <span class="n">vt</span><span class="o">.</span><span class="n">__setstate__</span> <span class="o">=</span> <span class="n">_vt_setstate</span>

<span class="n">Vector_string</span><span class="o">.</span><span class="n">a</span> <span class="o">=</span> <span class="kc">None</span>
<span class="n">Vector_string</span><span class="o">.</span><span class="n">get_array</span> <span class="o">=</span> <span class="k">lambda</span> <span class="bp">self</span><span class="p">:</span> <span class="kc">None</span>
<span class="n">Vector_string</span><span class="o">.</span><span class="fm">__repr__</span> <span class="o">=</span> <span class="k">lambda</span> <span class="bp">self</span><span class="p">:</span> <span class="nb">repr</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="p">))</span>


<span class="c1"># Global RNG</span>

<span class="n">_rng</span> <span class="o">=</span> <span class="n">libcore</span><span class="o">.</span><span class="n">get_rng</span><span class="p">((</span><span class="n">numpy</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">sys</span><span class="o">.</span><span class="n">maxsize</span><span class="p">)</span> <span class="o">+</span> <span class="n">os</span><span class="o">.</span><span class="n">getpid</span><span class="p">())</span> <span class="o">%</span> <span class="n">sys</span><span class="o">.</span><span class="n">maxsize</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">seed_rng</span><span class="p">(</span><span class="n">seed</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Seed the random number generator used by graph-tool&#39;s algorithms&quot;&quot;&quot;</span>
    <span class="kn">import</span> <span class="nn">graph_tool</span>
    <span class="n">graph_tool</span><span class="o">.</span><span class="n">_rng</span> <span class="o">=</span> <span class="n">libcore</span><span class="o">.</span><span class="n">get_rng</span><span class="p">(</span><span class="n">seed</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">_get_rng</span><span class="p">():</span>
    <span class="k">global</span> <span class="n">_rng</span>
    <span class="k">return</span> <span class="n">_rng</span>

<span class="c1"># OpenMP Setup</span>

<div class="viewcode-block" id="openmp_enabled"><a class="viewcode-back" href="https://graph-tool.skewed.de/static/doc/graph_tool.html#graph_tool.openmp_enabled">[docs]</a><span class="k">def</span> <span class="nf">openmp_enabled</span><span class="p">():</span>
    <span class="sd">&quot;&quot;&quot;Return ``True`` if OpenMP was enabled during compilation.&quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">libcore</span><span class="o">.</span><span class="n">openmp_enabled</span><span class="p">()</span></div>

<div class="viewcode-block" id="openmp_get_num_threads"><a class="viewcode-back" href="https://graph-tool.skewed.de/static/doc/graph_tool.html#graph_tool.openmp_get_num_threads">[docs]</a><span class="k">def</span> <span class="nf">openmp_get_num_threads</span><span class="p">():</span>
    <span class="sd">&quot;&quot;&quot;Return the number of OpenMP threads.&quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">libcore</span><span class="o">.</span><span class="n">openmp_get_num_threads</span><span class="p">()</span></div>

<div class="viewcode-block" id="openmp_set_num_threads"><a class="viewcode-back" href="https://graph-tool.skewed.de/static/doc/graph_tool.html#graph_tool.openmp_set_num_threads">[docs]</a><span class="k">def</span> <span class="nf">openmp_set_num_threads</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Set the number of OpenMP threads.&quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">libcore</span><span class="o">.</span><span class="n">openmp_set_num_threads</span><span class="p">(</span><span class="n">n</span><span class="p">)</span></div>

<div class="viewcode-block" id="openmp_get_schedule"><a class="viewcode-back" href="https://graph-tool.skewed.de/static/doc/graph_tool.html#graph_tool.openmp_get_schedule">[docs]</a><span class="k">def</span> <span class="nf">openmp_get_schedule</span><span class="p">():</span>
    <span class="sd">&quot;&quot;&quot;Return the runtime OpenMP schedule and chunk size. The schedule can by</span>
<span class="sd">    any of: ``&quot;static&quot;``, ``&quot;dynamic&quot;``, ``&quot;guided&quot;``, ``&quot;auto&quot;``.&quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">libcore</span><span class="o">.</span><span class="n">openmp_get_schedule</span><span class="p">()</span></div>

<div class="viewcode-block" id="openmp_set_schedule"><a class="viewcode-back" href="https://graph-tool.skewed.de/static/doc/graph_tool.html#graph_tool.openmp_set_schedule">[docs]</a><span class="k">def</span> <span class="nf">openmp_set_schedule</span><span class="p">(</span><span class="n">schedule</span><span class="p">,</span> <span class="n">chunk</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Set the runtime OpenMP schedule and chunk size. The schedule can by</span>
<span class="sd">    any of: ``&quot;static&quot;``, ``&quot;dynamic&quot;``, ``&quot;guided&quot;``, ``&quot;auto&quot;``.&quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">libcore</span><span class="o">.</span><span class="n">openmp_set_schedule</span><span class="p">(</span><span class="n">schedule</span><span class="p">,</span> <span class="n">chunk</span><span class="p">)</span></div>

<span class="k">if</span> <span class="n">openmp_enabled</span><span class="p">()</span> <span class="ow">and</span> <span class="n">os</span><span class="o">.</span><span class="n">environ</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;OMP_SCHEDULE&quot;</span><span class="p">)</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
    <span class="n">openmp_set_schedule</span><span class="p">(</span><span class="s2">&quot;static&quot;</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
</pre></div>

          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="https://graph-tool.skewed.de/static/doc/search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    </div>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="https://graph-tool.skewed.de/static/doc/genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="https://graph-tool.skewed.de/static/doc/py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
    <li><img src="../../../img/graph-icon.png" alt="logo" style="margin-right: 5px; margin-bottom:-2px;" /><a href="https://graph-tool.skewed.de/">Project Homepage</a> &raquo;</li>
    
        <li class="nav-item nav-item-0"><a href="../../../doc">graph-tool 2.27 documentation</a> &#187;</li>

          <li class="nav-item nav-item-1"><a href="index.html" >Module code</a> &#187;</li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright 2018, Tiago de Paula Peixoto &lt;tiago@skewed.de&gt;.
      Last updated on Jun 28, 2018.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.7.5.
    </div>
  </body>
</html>