
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="X-UA-Compatible" content="IE=Edge" />
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>graph_tool.topology - Assessing graph topology &#8212; graph-tool 2.27 documentation</title>
    <link rel="stylesheet" href="https://graph-tool.skewed.de/static/doc/_static/gt_style.css" type="text/css" />
    <link rel="stylesheet" href="https://graph-tool.skewed.de/static/doc/_static/pygments.css" type="text/css" />
    <script type="text/javascript" id="documentation_options" data-url_root="./" src="https://graph-tool.skewed.de/static/doc/_static/documentation_options.js"></script>
    <script type="text/javascript" src="https://graph-tool.skewed.de/static/doc/_static/jquery.js"></script>
    <script type="text/javascript" src="https://graph-tool.skewed.de/static/doc/_static/underscore.js"></script>
    <script type="text/javascript" src="https://graph-tool.skewed.de/static/doc/_static/doctools.js"></script>
    <script type="text/javascript" src="https://graph-tool.skewed.de/static/doc/_static/MathJax/MathJax.js?config=default"></script>
    <link rel="search" type="application/opensearchdescription+xml"
          title="Search within graph-tool 2.27 documentation"
          href="https://graph-tool.skewed.de/static/doc/_static/opensearch.xml"/>
    <link rel="shortcut icon" href="https://graph-tool.skewed.de/static/doc/_static/graph-icon.ico"/>
    <link rel="index" title="Index" href="https://graph-tool.skewed.de/static/doc/genindex.html" />
    <link rel="search" title="Search" href="https://graph-tool.skewed.de/static/doc/search.html" />
    <link rel="next" title="graph_tool.util - Graph utilities" href="../static/doc/util.html" />
    <link rel="prev" title="graph_tool.stats - Miscellaneous statistics" href="stats.html" />
    <script type="text/javascript">
      var _gaq = _gaq || [];
      var pluginUrl =
        '//www.google-analytics.com/plugins/ga/inpage_linkid.js';
      _gaq.push(['_require', 'inpage_linkid', pluginUrl]);
      _gaq.push(['_setAccount', 'UA-248813-2']);
      _gaq.push(['_setDomainName', '.skewed.de']);
      _gaq.push(['_trackPageview']);
      (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
      })();
    </script>
     

  </head><body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="https://graph-tool.skewed.de/static/doc/genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="https://graph-tool.skewed.de/static/doc/py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="../static/doc/util.html" title="graph_tool.util - Graph utilities"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="stats.html" title="graph_tool.stats - Miscellaneous statistics"
             accesskey="P">previous</a> |</li>
    <li><img src="../img/graph-icon.png" alt="logo" style="margin-right: 5px; margin-bottom:-2px;" /><a href="https://graph-tool.skewed.de/">Project Homepage</a> &raquo;</li>
    
        <li class="nav-item nav-item-0"><a href="../doc">graph-tool 2.27 documentation</a> &#187;</li>

          <li class="nav-item nav-item-1"><a href="../static/doc/modules.html" >Module documentation</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="https://graph-tool.skewed.de/static/doc/graph_tool.html" accesskey="U">graph_tool - efficient graph analysis and manipulation</a> &#187;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <span class="target" id="module-graph_tool.topology"></span><div class="section" id="graph-tool-topology-assessing-graph-topology">
<h1><code class="docutils literal notranslate"><span class="pre">graph_tool.topology</span></code> - Assessing graph topology<a class="headerlink" href="topology.html#graph-tool-topology-assessing-graph-topology" title="Permalink to this headline">¶</a></h1>
<div class="section" id="summary">
<h2>Summary<a class="headerlink" href="topology.html#summary" title="Permalink to this headline">¶</a></h2>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="topology.html#graph_tool.topology.shortest_distance" title="graph_tool.topology.shortest_distance"><code class="xref py py-obj docutils literal notranslate"><span class="pre">shortest_distance</span></code></a></td>
<td>Calculate the distance from a source to a target vertex, or to of all vertices from a given source, or the all pairs shortest paths, if the source is not specified.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="topology.html#graph_tool.topology.shortest_path" title="graph_tool.topology.shortest_path"><code class="xref py py-obj docutils literal notranslate"><span class="pre">shortest_path</span></code></a></td>
<td>Return the shortest path from <code class="docutils literal notranslate"><span class="pre">source</span></code> to <code class="docutils literal notranslate"><span class="pre">target</span></code>.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="topology.html#graph_tool.topology.all_shortest_paths" title="graph_tool.topology.all_shortest_paths"><code class="xref py py-obj docutils literal notranslate"><span class="pre">all_shortest_paths</span></code></a></td>
<td>Return an iterator over all shortest paths from <cite>source</cite> to <cite>target</cite>.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="topology.html#graph_tool.topology.all_predecessors" title="graph_tool.topology.all_predecessors"><code class="xref py py-obj docutils literal notranslate"><span class="pre">all_predecessors</span></code></a></td>
<td>Return a property map with all possible predecessors in the search tree     determined by <code class="docutils literal notranslate"><span class="pre">dist_map</span></code> and <code class="docutils literal notranslate"><span class="pre">pred_map</span></code>.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="topology.html#graph_tool.topology.all_paths" title="graph_tool.topology.all_paths"><code class="xref py py-obj docutils literal notranslate"><span class="pre">all_paths</span></code></a></td>
<td>Return an iterator over all paths from <cite>source</cite> to <cite>target</cite>.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="topology.html#graph_tool.topology.all_circuits" title="graph_tool.topology.all_circuits"><code class="xref py py-obj docutils literal notranslate"><span class="pre">all_circuits</span></code></a></td>
<td>Return an iterator over all the cycles in a directed graph.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="topology.html#graph_tool.topology.pseudo_diameter" title="graph_tool.topology.pseudo_diameter"><code class="xref py py-obj docutils literal notranslate"><span class="pre">pseudo_diameter</span></code></a></td>
<td>Compute the pseudo-diameter of the graph.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="topology.html#graph_tool.topology.similarity" title="graph_tool.topology.similarity"><code class="xref py py-obj docutils literal notranslate"><span class="pre">similarity</span></code></a></td>
<td>Return the adjacency similarity between the two graphs.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="topology.html#graph_tool.topology.vertex_similarity" title="graph_tool.topology.vertex_similarity"><code class="xref py py-obj docutils literal notranslate"><span class="pre">vertex_similarity</span></code></a></td>
<td>Return the similarity between pairs of vertices.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="topology.html#graph_tool.topology.isomorphism" title="graph_tool.topology.isomorphism"><code class="xref py py-obj docutils literal notranslate"><span class="pre">isomorphism</span></code></a></td>
<td>Check whether two graphs are isomorphic.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="topology.html#graph_tool.topology.subgraph_isomorphism" title="graph_tool.topology.subgraph_isomorphism"><code class="xref py py-obj docutils literal notranslate"><span class="pre">subgraph_isomorphism</span></code></a></td>
<td>Obtain all subgraph isomorphisms of <cite>sub</cite> in <cite>g</cite> (or at most <cite>max_n</cite> subgraphs, if <cite>max_n &gt; 0</cite>).</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="topology.html#graph_tool.topology.mark_subgraph" title="graph_tool.topology.mark_subgraph"><code class="xref py py-obj docutils literal notranslate"><span class="pre">mark_subgraph</span></code></a></td>
<td>Mark a given subgraph <cite>sub</cite> on the graph <cite>g</cite>.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="topology.html#graph_tool.topology.max_cardinality_matching" title="graph_tool.topology.max_cardinality_matching"><code class="xref py py-obj docutils literal notranslate"><span class="pre">max_cardinality_matching</span></code></a></td>
<td>Find a maximum cardinality matching in the graph.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="topology.html#graph_tool.topology.max_independent_vertex_set" title="graph_tool.topology.max_independent_vertex_set"><code class="xref py py-obj docutils literal notranslate"><span class="pre">max_independent_vertex_set</span></code></a></td>
<td>Find a maximal independent vertex set in the graph.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="topology.html#graph_tool.topology.min_spanning_tree" title="graph_tool.topology.min_spanning_tree"><code class="xref py py-obj docutils literal notranslate"><span class="pre">min_spanning_tree</span></code></a></td>
<td>Return the minimum spanning tree of a given graph.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="topology.html#graph_tool.topology.random_spanning_tree" title="graph_tool.topology.random_spanning_tree"><code class="xref py py-obj docutils literal notranslate"><span class="pre">random_spanning_tree</span></code></a></td>
<td>Return a random spanning tree of a given graph, which can be directed or undirected.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="topology.html#graph_tool.topology.dominator_tree" title="graph_tool.topology.dominator_tree"><code class="xref py py-obj docutils literal notranslate"><span class="pre">dominator_tree</span></code></a></td>
<td>Return a vertex property map the dominator vertices for each vertex.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="topology.html#graph_tool.topology.topological_sort" title="graph_tool.topology.topological_sort"><code class="xref py py-obj docutils literal notranslate"><span class="pre">topological_sort</span></code></a></td>
<td>Return the topological sort of the given graph.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="topology.html#graph_tool.topology.transitive_closure" title="graph_tool.topology.transitive_closure"><code class="xref py py-obj docutils literal notranslate"><span class="pre">transitive_closure</span></code></a></td>
<td>Return the transitive closure graph of g.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="topology.html#graph_tool.topology.tsp_tour" title="graph_tool.topology.tsp_tour"><code class="xref py py-obj docutils literal notranslate"><span class="pre">tsp_tour</span></code></a></td>
<td>Return a traveling salesman tour of the graph, which is guaranteed to be twice as long as the optimal tour in the worst case.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="topology.html#graph_tool.topology.sequential_vertex_coloring" title="graph_tool.topology.sequential_vertex_coloring"><code class="xref py py-obj docutils literal notranslate"><span class="pre">sequential_vertex_coloring</span></code></a></td>
<td>Returns a vertex coloring of the graph.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="topology.html#graph_tool.topology.label_components" title="graph_tool.topology.label_components"><code class="xref py py-obj docutils literal notranslate"><span class="pre">label_components</span></code></a></td>
<td>Label the components to which each vertex in the graph belongs.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="topology.html#graph_tool.topology.label_biconnected_components" title="graph_tool.topology.label_biconnected_components"><code class="xref py py-obj docutils literal notranslate"><span class="pre">label_biconnected_components</span></code></a></td>
<td>Label the edges of biconnected components, and the vertices which are articulation points.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="topology.html#graph_tool.topology.label_largest_component" title="graph_tool.topology.label_largest_component"><code class="xref py py-obj docutils literal notranslate"><span class="pre">label_largest_component</span></code></a></td>
<td>Label the largest component in the graph.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="topology.html#graph_tool.topology.label_out_component" title="graph_tool.topology.label_out_component"><code class="xref py py-obj docutils literal notranslate"><span class="pre">label_out_component</span></code></a></td>
<td>Label the out-component (or simply the component for undirected graphs) of a root vertex.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="topology.html#graph_tool.topology.vertex_percolation" title="graph_tool.topology.vertex_percolation"><code class="xref py py-obj docutils literal notranslate"><span class="pre">vertex_percolation</span></code></a></td>
<td>Compute the size of the largest or second-largest component as vertices are (virtually) removed from the graph.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="topology.html#graph_tool.topology.edge_percolation" title="graph_tool.topology.edge_percolation"><code class="xref py py-obj docutils literal notranslate"><span class="pre">edge_percolation</span></code></a></td>
<td>Compute the size of the largest or second-largest component as edges are (virtually) removed from the graph.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="topology.html#graph_tool.topology.kcore_decomposition" title="graph_tool.topology.kcore_decomposition"><code class="xref py py-obj docutils literal notranslate"><span class="pre">kcore_decomposition</span></code></a></td>
<td>Perform a k-core decomposition of the given graph.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="topology.html#graph_tool.topology.is_bipartite" title="graph_tool.topology.is_bipartite"><code class="xref py py-obj docutils literal notranslate"><span class="pre">is_bipartite</span></code></a></td>
<td>Test if the graph is bipartite.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="topology.html#graph_tool.topology.is_DAG" title="graph_tool.topology.is_DAG"><code class="xref py py-obj docutils literal notranslate"><span class="pre">is_DAG</span></code></a></td>
<td>Return <cite>True</cite> if the graph is a directed acyclic graph (DAG).</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="topology.html#graph_tool.topology.is_planar" title="graph_tool.topology.is_planar"><code class="xref py py-obj docutils literal notranslate"><span class="pre">is_planar</span></code></a></td>
<td>Test if the graph is planar.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="topology.html#graph_tool.topology.make_maximal_planar" title="graph_tool.topology.make_maximal_planar"><code class="xref py py-obj docutils literal notranslate"><span class="pre">make_maximal_planar</span></code></a></td>
<td>Add edges to the graph to make it maximally planar.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="topology.html#graph_tool.topology.edge_reciprocity" title="graph_tool.topology.edge_reciprocity"><code class="xref py py-obj docutils literal notranslate"><span class="pre">edge_reciprocity</span></code></a></td>
<td>Calculate the edge reciprocity of the graph.</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="contents">
<h2>Contents<a class="headerlink" href="topology.html#contents" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="graph_tool.topology.similarity">
<code class="descclassname">graph_tool.topology.</code><code class="descname">similarity</code><span class="sig-paren">(</span><em>g1</em>, <em>g2</em>, <em>eweight1=None</em>, <em>eweight2=None</em>, <em>label1=None</em>, <em>label2=None</em>, <em>norm=True</em>, <em>p=1.0</em>, <em>distance=False</em>, <em>asymmetric=False</em><span class="sig-paren">)</span><a class="reference internal" href="../static/doc/_modules/graph_tool/topology.html#similarity"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="topology.html#graph_tool.topology.similarity" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the adjacency similarity between the two graphs.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>g1</strong> : <a class="reference internal" href="https://graph-tool.skewed.de/static/doc/graph_tool.html#graph_tool.Graph" title="graph_tool.Graph"><code class="xref py py-class docutils literal notranslate"><span class="pre">Graph</span></code></a></p>
<blockquote>
<div><p>First graph to be compared.</p>
</div></blockquote>
<p><strong>g2</strong> : <a class="reference internal" href="https://graph-tool.skewed.de/static/doc/graph_tool.html#graph_tool.Graph" title="graph_tool.Graph"><code class="xref py py-class docutils literal notranslate"><span class="pre">Graph</span></code></a></p>
<blockquote>
<div><p>Second graph to be compared.</p>
</div></blockquote>
<p><strong>eweight1</strong> : <a class="reference internal" href="https://graph-tool.skewed.de/static/doc/graph_tool.html#graph_tool.PropertyMap" title="graph_tool.PropertyMap"><code class="xref py py-class docutils literal notranslate"><span class="pre">PropertyMap</span></code></a> (optional, default: <code class="docutils literal notranslate"><span class="pre">None</span></code>)</p>
<blockquote>
<div><p>Edge weights for the first graph to be used in comparison.</p>
</div></blockquote>
<p><strong>eweight2</strong> : <a class="reference internal" href="https://graph-tool.skewed.de/static/doc/graph_tool.html#graph_tool.PropertyMap" title="graph_tool.PropertyMap"><code class="xref py py-class docutils literal notranslate"><span class="pre">PropertyMap</span></code></a> (optional, default: <code class="docutils literal notranslate"><span class="pre">None</span></code>)</p>
<blockquote>
<div><p>Edge weights for the second graph to be used in comparison.</p>
</div></blockquote>
<p><strong>label1</strong> : <a class="reference internal" href="https://graph-tool.skewed.de/static/doc/graph_tool.html#graph_tool.PropertyMap" title="graph_tool.PropertyMap"><code class="xref py py-class docutils literal notranslate"><span class="pre">PropertyMap</span></code></a> (optional, default: <code class="docutils literal notranslate"><span class="pre">None</span></code>)</p>
<blockquote>
<div><p>Vertex labels for the first graph to be used in comparison. If not
supplied, the vertex indexes are used.</p>
</div></blockquote>
<p><strong>label2</strong> : <a class="reference internal" href="https://graph-tool.skewed.de/static/doc/graph_tool.html#graph_tool.PropertyMap" title="graph_tool.PropertyMap"><code class="xref py py-class docutils literal notranslate"><span class="pre">PropertyMap</span></code></a> (optional, default: <code class="docutils literal notranslate"><span class="pre">None</span></code>)</p>
<blockquote>
<div><p>Vertex labels for the second graph to be used in comparison. If not
supplied, the vertex indexes are used.</p>
</div></blockquote>
<p><strong>norm</strong> : bool (optional, default: <code class="docutils literal notranslate"><span class="pre">True</span></code>)</p>
<blockquote>
<div><p>If <code class="docutils literal notranslate"><span class="pre">True</span></code>, the returned value is normalized by the total number of
edges.</p>
</div></blockquote>
<p><strong>p</strong> : float (optional, default: <code class="docutils literal notranslate"><span class="pre">1.</span></code>)</p>
<blockquote>
<div><p>Exponent of the <span class="math">\(L^p\)</span> distance function.</p>
</div></blockquote>
<p><strong>distance</strong> : bool (optional, default: <code class="docutils literal notranslate"><span class="pre">False</span></code>)</p>
<blockquote>
<div><p>If <code class="docutils literal notranslate"><span class="pre">True</span></code>, the complementary value is returned, i.e. the distance
between the two graphs.</p>
</div></blockquote>
<p><strong>asymmetric</strong> : bool (optional, default: <code class="docutils literal notranslate"><span class="pre">False</span></code>)</p>
<blockquote>
<div><p>If <code class="docutils literal notranslate"><span class="pre">True</span></code>, the asymmetric similarity of <code class="docutils literal notranslate"><span class="pre">g1</span></code> to <code class="docutils literal notranslate"><span class="pre">g2</span></code> will be
computed.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>similarity</strong> : float</p>
<blockquote class="last">
<div><p>Adjacency similarity value.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>In its default parametrization, the adjacency similarity is the sum of equal
non-zero entries in the adjacency matrix, given a vertex ordering determined
by the vertex labels. In other words, it counts the number of edges which
have the same source and target labels in both graphs. This function also
allows for generalized similarities according to an <span class="math">\(L^p\)</span> norm, for
arbitrary <span class="math">\(p\)</span>.</p>
<p>More specifically, it is defined as:</p>
<div class="math">
\[S(\boldsymbol A_1, \boldsymbol A_2) = E - d(\boldsymbol A_1, \boldsymbol A_2)\]</div>
<p>where</p>
<div class="math">
\[d(\boldsymbol A_1, \boldsymbol A_2) = \left(\sum_{i\le j} \left|A_{ij}^{(1)} - A_{ij}^{(2)}\right|^p\right)^{1/p}\]</div>
<p>is the distance between graphs, and <span class="math">\(E=(\sum_{i\le j}|A_{ij}^{(1)}|^p +
|A_{ij}^{(2)}|^p)^{1/p}\)</span>. Unless otherwise stated via the parameter <code class="docutils literal notranslate"><span class="pre">p</span></code>,
the exponent used is <span class="math">\(p=1\)</span>. This definition holds for undirected
graphs, otherwise the sums go over all directed pairs. If weights are
provided, the weighted adjacency matrix is used.</p>
<p>If <code class="docutils literal notranslate"><span class="pre">norm</span> <span class="pre">==</span> <span class="pre">True</span></code> the value returned is <span class="math">\(S(\boldsymbol A_1,
\boldsymbol A_2) / E\)</span>, which lies in the interval <span class="math">\([0,1]\)</span>.</p>
<p>If <code class="docutils literal notranslate"><span class="pre">asymmetric</span> <span class="pre">==</span> <span class="pre">True</span></code>, the above is changed so that the comparison is
made only for entries in <span class="math">\(\boldsymbol A_1\)</span> that are larger than in <span class="math">\(\boldsymbol A_2\)</span>, i.e.</p>
<div class="math">
\[d(\boldsymbol A_1, \boldsymbol A_2) = \left(\sum_{i\le j} \left(A_{ij}^{(1)} - A_{ij}^{(2)}\right)^p H(A_{ij}^{(1)} - A_{ij}^{(2)})\right)^{1/p},\]</div>
<p>where <span class="math">\(H(x)\)</span> is the unit step function, and the total sum is changed
accordingly to <span class="math">\(E=\left(\sum_{i\le j}|A_{ij}^{(1)}|^p\right)^{1/p}\)</span>.</p>
<p>The algorithm runs with complexity <span class="math">\(O(E_1 + V_1 + E_2 + V_2)\)</span>.</p>
<p>If enabled during compilation, and the vertex labels are integers bounded by
the sizes of the graphs, this algorithm runs in parallel.</p>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">g</span> <span class="o">=</span> <span class="n">gt</span><span class="o">.</span><span class="n">random_graph</span><span class="p">(</span><span class="mi">100</span><span class="p">,</span> <span class="k">lambda</span><span class="p">:</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">u</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">gt</span><span class="o">.</span><span class="n">similarity</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">g</span><span class="p">)</span>
<span class="go">1.0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">gt</span><span class="o">.</span><span class="n">random_rewire</span><span class="p">(</span><span class="n">u</span><span class="p">)</span>
<span class="go">22</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">gt</span><span class="o">.</span><span class="n">similarity</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">g</span><span class="p">)</span>
<span class="go">0.04666666666666667</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="graph_tool.topology.vertex_similarity">
<code class="descclassname">graph_tool.topology.</code><code class="descname">vertex_similarity</code><span class="sig-paren">(</span><em>g</em>, <em>sim_type='jaccard'</em>, <em>vertex_pairs=None</em>, <em>self_loops=True</em>, <em>sim_map=None</em><span class="sig-paren">)</span><a class="reference internal" href="../static/doc/_modules/graph_tool/topology.html#vertex_similarity"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="topology.html#graph_tool.topology.vertex_similarity" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the similarity between pairs of vertices.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>g</strong> : <a class="reference internal" href="https://graph-tool.skewed.de/static/doc/graph_tool.html#graph_tool.Graph" title="graph_tool.Graph"><code class="xref py py-class docutils literal notranslate"><span class="pre">Graph</span></code></a></p>
<blockquote>
<div><p>The graph to be used.</p>
</div></blockquote>
<p><strong>sim_type</strong> : <code class="docutils literal notranslate"><span class="pre">str</span></code> (optional, default: <code class="docutils literal notranslate"><span class="pre">&quot;jaccard&quot;</span></code>)</p>
<blockquote>
<div><p>Type of similarity to use. This must be one of <code class="docutils literal notranslate"><span class="pre">&quot;dice&quot;</span></code>, <code class="docutils literal notranslate"><span class="pre">&quot;jaccard&quot;</span></code>
or <code class="docutils literal notranslate"><span class="pre">&quot;inv-log-weight&quot;</span></code>.</p>
</div></blockquote>
<p><strong>vertex_pairs</strong> : iterable of pairs of integers (optional, default: <code class="docutils literal notranslate"><span class="pre">None</span></code>)</p>
<blockquote>
<div><p>Pairs of vertices to compute the similarity. If omitted, all pairs will
be considered.</p>
</div></blockquote>
<p><strong>self_loops</strong> : bool (optional, default: <code class="docutils literal notranslate"><span class="pre">True</span></code>)</p>
<blockquote>
<div><p>If <code class="docutils literal notranslate"><span class="pre">True</span></code>, vertices will be considered adjacent to themselves for the
purpose of the similarity computation.</p>
</div></blockquote>
<p><strong>sim_map</strong> : <a class="reference internal" href="https://graph-tool.skewed.de/static/doc/graph_tool.html#graph_tool.PropertyMap" title="graph_tool.PropertyMap"><code class="xref py py-class docutils literal notranslate"><span class="pre">PropertyMap</span></code></a> (optional, default: <code class="docutils literal notranslate"><span class="pre">None</span></code>)</p>
<blockquote>
<div><p>If provided, and <code class="docutils literal notranslate"><span class="pre">vertex_pairs</span> <span class="pre">is</span> <span class="pre">None</span></code>, the vertex similarities will
be stored in this vector-valued property. Otherwise, a new one will be
created.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>similarities</strong> : <a class="reference external" href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v1.14)"><code class="xref py py-class docutils literal notranslate"><span class="pre">numpy.ndarray</span></code></a> or <a class="reference internal" href="https://graph-tool.skewed.de/static/doc/graph_tool.html#graph_tool.PropertyMap" title="graph_tool.PropertyMap"><code class="xref py py-class docutils literal notranslate"><span class="pre">PropertyMap</span></code></a></p>
<blockquote class="last">
<div><p>If <code class="docutils literal notranslate"><span class="pre">vertex_pairs</span></code> was supplied, this will be a <a class="reference external" href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v1.14)"><code class="xref py py-class docutils literal notranslate"><span class="pre">numpy.ndarray</span></code></a>
with the corresponding similarities, otherwise it will be a
vector-valued vertex <a class="reference internal" href="https://graph-tool.skewed.de/static/doc/graph_tool.html#graph_tool.PropertyMap" title="graph_tool.PropertyMap"><code class="xref py py-class docutils literal notranslate"><span class="pre">PropertyMap</span></code></a>, with the
similarities to all other vertices.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>According to <code class="docutils literal notranslate"><span class="pre">sim_type</span></code>, this function computes the following similarities:</p>
<p><code class="docutils literal notranslate"><span class="pre">sim_type</span> <span class="pre">==</span> <span class="pre">&quot;dice&quot;</span></code></p>
<blockquote>
<div>The Sørensen–Dice similarity <a class="reference internal" href="topology.html#sorensen-dice272" id="id1">[sorensen-dice272]</a> is twice the number of
common neighbors between two vertices divided by the sum of their
degrees.</div></blockquote>
<p><code class="docutils literal notranslate"><span class="pre">sim_type</span> <span class="pre">==</span> <span class="pre">&quot;jaccard&quot;</span></code></p>
<blockquote>
<div>The Jaccard similarity <a class="reference internal" href="topology.html#jaccard272" id="id2">[jaccard272]</a> is the number of common neighbors
between two vertices divided by the size of the set of all neighbors to
both vertices.</div></blockquote>
<p><code class="docutils literal notranslate"><span class="pre">sim_type</span> <span class="pre">==</span> <span class="pre">&quot;inv-log-weight&quot;</span></code></p>
<blockquote>
<div>The inverse log weighted similarity <a class="reference internal" href="topology.html#adamic-friends-2003272" id="id3">[adamic-friends-2003272]</a> is the sum of
the weights of common neighbors between two vertices, where the weights
are computed as <span class="math">\(1/\log(k)\)</span>, with <span class="math">\(k\)</span> being the degree of the
vertex.</div></blockquote>
<p>For directed graphs, only out-neighbors are considered in the above
algorthms (for “inv-log-weight”, the in-degrees are used to compute the
weights). To use the in-neighbors instead, a <a class="reference internal" href="https://graph-tool.skewed.de/static/doc/graph_tool.html#graph_tool.GraphView" title="graph_tool.GraphView"><code class="xref py py-class docutils literal notranslate"><span class="pre">GraphView</span></code></a>
should be used to reverse the graph, e.g. <code class="docutils literal notranslate"><span class="pre">vertex_similarity(GraphView(g,</span>
<span class="pre">reversed=True))</span></code>.</p>
<p>The algorithm runs with complexity <span class="math">\(O(\left&lt;k\right&gt;N^2)\)</span> if
<code class="docutils literal notranslate"><span class="pre">vertex_pairs</span> <span class="pre">is</span> <span class="pre">None</span></code>, otherwise with <span class="math">\(O(\left&lt;k\right&gt;P)\)</span> where
<span class="math">\(P\)</span> is the length of <code class="docutils literal notranslate"><span class="pre">vertex_pairs</span></code>.</p>
<p>If enabled during compilation, this algorithm runs in parallel.</p>
<p class="rubric">References</p>
<table class="docutils citation" frame="void" id="sorensen-dice272" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[sorensen-dice272]</td><td><em>(<a class="fn-backref" href="topology.html#id1">1</a>, <a class="fn-backref" href="topology.html#id4">2</a>)</em> <a class="reference external" href="https://en.wikipedia.org/wiki/S%C3%B8rensen%E2%80%93Dice_coefficient">https://en.wikipedia.org/wiki/S%C3%B8rensen%E2%80%93Dice_coefficient</a></td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="jaccard272" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[jaccard272]</td><td><em>(<a class="fn-backref" href="topology.html#id2">1</a>, <a class="fn-backref" href="topology.html#id5">2</a>)</em> <a class="reference external" href="https://en.wikipedia.org/wiki/Jaccard_index">https://en.wikipedia.org/wiki/Jaccard_index</a></td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="adamic-friends-2003272" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[adamic-friends-2003272]</td><td><em>(<a class="fn-backref" href="topology.html#id3">1</a>, <a class="fn-backref" href="topology.html#id6">2</a>)</em> Lada A. Adamic and Eytan Adar, “Friends and neighbors
on the Web”, Social Networks Volume 25, Issue 3, Pages 211–230 (2003)
<a class="reference external" href="https://dx.doi.org/10.1016/S0378-8733(03)00009-1">DOI: 10.1016/S0378-8733(03)00009-1</a> [<a class="reference external" href="https://sci-hub.tw/10.1016/S0378-8733(03)00009-1">sci-hub</a>, <a class="reference external" href="https://scihub22266oqcxt.onion.link/10.1016/S0378-8733(03)00009-1">&#64;tor</a>]</td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="liben-nowell-link-prediction-2007272" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="topology.html#id7">[liben-nowell-link-prediction-2007272]</a></td><td>David Liben-Nowell and Jon Kleinberg,
“The link-prediction problem for social networks”, Journal of the
American Society for Information Science and Technology, Volume 58, Issue
7, pages 1019–1031 (2007), <a class="reference external" href="https://dx.doi.org/10.1002/asi.20591">DOI: 10.1002/asi.20591</a> [<a class="reference external" href="https://sci-hub.tw/10.1002/asi.20591">sci-hub</a>, <a class="reference external" href="https://scihub22266oqcxt.onion.link/10.1002/asi.20591">&#64;tor</a>]</td></tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">g</span> <span class="o">=</span> <span class="n">gt</span><span class="o">.</span><span class="n">collection</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;polbooks&quot;</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">gt</span><span class="o">.</span><span class="n">vertex_similarity</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="s2">&quot;jaccard&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">color</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">new_vp</span><span class="p">(</span><span class="s2">&quot;double&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">color</span><span class="o">.</span><span class="n">a</span> <span class="o">=</span> <span class="n">s</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">a</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">gt</span><span class="o">.</span><span class="n">graph_draw</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">pos</span><span class="o">=</span><span class="n">g</span><span class="o">.</span><span class="n">vp</span><span class="o">.</span><span class="n">pos</span><span class="p">,</span> <span class="n">vertex_text</span><span class="o">=</span><span class="n">g</span><span class="o">.</span><span class="n">vertex_index</span><span class="p">,</span>
<span class="gp">... </span>              <span class="n">vertex_color</span><span class="o">=</span><span class="n">color</span><span class="p">,</span> <span class="n">vertex_fill_color</span><span class="o">=</span><span class="n">color</span><span class="p">,</span>
<span class="gp">... </span>              <span class="n">vcmap</span><span class="o">=</span><span class="n">matplotlib</span><span class="o">.</span><span class="n">cm</span><span class="o">.</span><span class="n">inferno</span><span class="p">,</span>
<span class="gp">... </span>              <span class="n">output</span><span class="o">=</span><span class="s2">&quot;polbooks-jaccard.pdf&quot;</span><span class="p">)</span>
<span class="go">&lt;...&gt;</span>
</pre></div>
</div>
<div class="figure align-center" id="id81">
<img alt="_images/polbooks-jaccard.png" src="../static/doc/_images/polbooks-jaccard.png" />
<p class="caption"><span class="caption-text">Jaccard similarities to vertex <code class="docutils literal notranslate"><span class="pre">0</span></code> in a political books network.</span></p>
</div>
</dd></dl>

<dl class="function">
<dt id="graph_tool.topology.isomorphism">
<code class="descclassname">graph_tool.topology.</code><code class="descname">isomorphism</code><span class="sig-paren">(</span><em>g1</em>, <em>g2</em>, <em>vertex_inv1=None</em>, <em>vertex_inv2=None</em>, <em>isomap=False</em><span class="sig-paren">)</span><a class="reference internal" href="../static/doc/_modules/graph_tool/topology.html#isomorphism"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="topology.html#graph_tool.topology.isomorphism" title="Permalink to this definition">¶</a></dt>
<dd><p>Check whether two graphs are isomorphic.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>g1</strong> : <a class="reference internal" href="https://graph-tool.skewed.de/static/doc/graph_tool.html#graph_tool.Graph" title="graph_tool.Graph"><code class="xref py py-class docutils literal notranslate"><span class="pre">Graph</span></code></a></p>
<blockquote>
<div><p>First graph.</p>
</div></blockquote>
<p><strong>g2</strong> : <a class="reference internal" href="https://graph-tool.skewed.de/static/doc/graph_tool.html#graph_tool.Graph" title="graph_tool.Graph"><code class="xref py py-class docutils literal notranslate"><span class="pre">Graph</span></code></a></p>
<blockquote>
<div><p>Second graph.</p>
</div></blockquote>
<p><strong>vertex_inv1</strong> : <a class="reference internal" href="https://graph-tool.skewed.de/static/doc/graph_tool.html#graph_tool.PropertyMap" title="graph_tool.PropertyMap"><code class="xref py py-class docutils literal notranslate"><span class="pre">PropertyMap</span></code></a> (optional, default: <cite>None</cite>)</p>
<blockquote>
<div><p>Vertex invariant of the first graph. Only vertices with with the same
invariants are considered in the isomorphism.</p>
</div></blockquote>
<p><strong>vertex_inv2</strong> : <a class="reference internal" href="https://graph-tool.skewed.de/static/doc/graph_tool.html#graph_tool.PropertyMap" title="graph_tool.PropertyMap"><code class="xref py py-class docutils literal notranslate"><span class="pre">PropertyMap</span></code></a> (optional, default: <cite>None</cite>)</p>
<blockquote>
<div><p>Vertex invariant of the second graph. Only vertices with with the same
invariants are considered in the isomorphism.</p>
</div></blockquote>
<p><strong>isomap</strong> : <code class="docutils literal notranslate"><span class="pre">bool</span></code> (optional, default: <code class="docutils literal notranslate"><span class="pre">False</span></code>)</p>
<blockquote>
<div><p>If <code class="docutils literal notranslate"><span class="pre">True</span></code>, a vertex <a class="reference internal" href="https://graph-tool.skewed.de/static/doc/graph_tool.html#graph_tool.PropertyMap" title="graph_tool.PropertyMap"><code class="xref py py-class docutils literal notranslate"><span class="pre">PropertyMap</span></code></a> with the
isomorphism mapping is returned as well.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>is_isomorphism</strong> : <code class="docutils literal notranslate"><span class="pre">bool</span></code></p>
<blockquote>
<div><p><code class="docutils literal notranslate"><span class="pre">True</span></code> if both graphs are isomorphic, otherwise <code class="docutils literal notranslate"><span class="pre">False</span></code>.</p>
</div></blockquote>
<p><strong>isomap</strong> : <a class="reference internal" href="https://graph-tool.skewed.de/static/doc/graph_tool.html#graph_tool.PropertyMap" title="graph_tool.PropertyMap"><code class="xref py py-class docutils literal notranslate"><span class="pre">PropertyMap</span></code></a></p>
<blockquote class="last">
<div><p>Isomorphism mapping corresponding to a property map belonging to the
first graph which maps its vertices to their corresponding vertices of
the second graph.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">g</span> <span class="o">=</span> <span class="n">gt</span><span class="o">.</span><span class="n">random_graph</span><span class="p">(</span><span class="mi">100</span><span class="p">,</span> <span class="k">lambda</span><span class="p">:</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">g2</span> <span class="o">=</span> <span class="n">gt</span><span class="o">.</span><span class="n">Graph</span><span class="p">(</span><span class="n">g</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">gt</span><span class="o">.</span><span class="n">isomorphism</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">g2</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">g</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="n">g</span><span class="o">.</span><span class="n">vertex</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="n">g</span><span class="o">.</span><span class="n">vertex</span><span class="p">(</span><span class="mi">1</span><span class="p">))</span>
<span class="go">&lt;...&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">gt</span><span class="o">.</span><span class="n">isomorphism</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">g2</span><span class="p">)</span>
<span class="go">False</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="graph_tool.topology.subgraph_isomorphism">
<code class="descclassname">graph_tool.topology.</code><code class="descname">subgraph_isomorphism</code><span class="sig-paren">(</span><em>sub</em>, <em>g</em>, <em>max_n=0</em>, <em>vertex_label=None</em>, <em>edge_label=None</em>, <em>induced=False</em>, <em>subgraph=True</em>, <em>generator=False</em><span class="sig-paren">)</span><a class="reference internal" href="../static/doc/_modules/graph_tool/topology.html#subgraph_isomorphism"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="topology.html#graph_tool.topology.subgraph_isomorphism" title="Permalink to this definition">¶</a></dt>
<dd><p>Obtain all subgraph isomorphisms of <cite>sub</cite> in <cite>g</cite> (or at most <cite>max_n</cite> subgraphs, if <cite>max_n &gt; 0</cite>).</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>sub</strong> : <a class="reference internal" href="https://graph-tool.skewed.de/static/doc/graph_tool.html#graph_tool.Graph" title="graph_tool.Graph"><code class="xref py py-class docutils literal notranslate"><span class="pre">Graph</span></code></a></p>
<blockquote>
<div><p>Subgraph for which to be searched.</p>
</div></blockquote>
<p><strong>g</strong> : <a class="reference internal" href="https://graph-tool.skewed.de/static/doc/graph_tool.html#graph_tool.Graph" title="graph_tool.Graph"><code class="xref py py-class docutils literal notranslate"><span class="pre">Graph</span></code></a></p>
<blockquote>
<div><p>Graph in which the search is performed.</p>
</div></blockquote>
<p><strong>max_n</strong> : int (optional, default: <code class="docutils literal notranslate"><span class="pre">0</span></code>)</p>
<blockquote>
<div><p>Maximum number of matches to find. If <cite>max_n == 0</cite>, all matches are
found.</p>
</div></blockquote>
<p><strong>vertex_label</strong> : pair of <a class="reference internal" href="https://graph-tool.skewed.de/static/doc/graph_tool.html#graph_tool.PropertyMap" title="graph_tool.PropertyMap"><code class="xref py py-class docutils literal notranslate"><span class="pre">PropertyMap</span></code></a> (optional, default: <code class="docutils literal notranslate"><span class="pre">None</span></code>)</p>
<blockquote>
<div><p>If provided, this should be a pair of <a class="reference internal" href="https://graph-tool.skewed.de/static/doc/graph_tool.html#graph_tool.PropertyMap" title="graph_tool.PropertyMap"><code class="xref py py-class docutils literal notranslate"><span class="pre">PropertyMap</span></code></a>
objects, belonging to <code class="docutils literal notranslate"><span class="pre">sub</span></code> and <code class="docutils literal notranslate"><span class="pre">g</span></code> (in this order), which specify
vertex labels which should match, in addition to the topological
isomorphism.</p>
</div></blockquote>
<p><strong>edge_label</strong> : pair of <a class="reference internal" href="https://graph-tool.skewed.de/static/doc/graph_tool.html#graph_tool.PropertyMap" title="graph_tool.PropertyMap"><code class="xref py py-class docutils literal notranslate"><span class="pre">PropertyMap</span></code></a> (optional, default: <code class="docutils literal notranslate"><span class="pre">None</span></code>)</p>
<blockquote>
<div><p>If provided, this should be a pair of <a class="reference internal" href="https://graph-tool.skewed.de/static/doc/graph_tool.html#graph_tool.PropertyMap" title="graph_tool.PropertyMap"><code class="xref py py-class docutils literal notranslate"><span class="pre">PropertyMap</span></code></a>
objects, belonging to <code class="docutils literal notranslate"><span class="pre">sub</span></code> and <code class="docutils literal notranslate"><span class="pre">g</span></code> (in this order), which specify
edge labels which should match, in addition to the topological
isomorphism.</p>
</div></blockquote>
<p><strong>induced</strong> : bool (optional, default: <code class="docutils literal notranslate"><span class="pre">False</span></code>)</p>
<blockquote>
<div><p>If <code class="docutils literal notranslate"><span class="pre">True</span></code>, only node-induced subgraphs are found.</p>
</div></blockquote>
<p><strong>subgraph</strong> : bool (optional, default: <code class="docutils literal notranslate"><span class="pre">True</span></code>)</p>
<blockquote>
<div><p>If <code class="docutils literal notranslate"><span class="pre">False</span></code>, all non-subgraph isomorphisms between <cite>sub</cite> and <cite>g</cite> are
found.</p>
</div></blockquote>
<p><strong>generator</strong> : bool (optional, default: <code class="docutils literal notranslate"><span class="pre">False</span></code>)</p>
<blockquote>
<div><p>If <code class="docutils literal notranslate"><span class="pre">True</span></code>, a generator will be returned, instead of a list. This is
useful if the number of isomorphisms is too large to store in memory. If
<code class="docutils literal notranslate"><span class="pre">generator</span> <span class="pre">==</span> <span class="pre">True</span></code>, the option <code class="docutils literal notranslate"><span class="pre">max_n</span></code> is ignored.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>vertex_maps</strong> : list (or generator) of <a class="reference internal" href="https://graph-tool.skewed.de/static/doc/graph_tool.html#graph_tool.PropertyMap" title="graph_tool.PropertyMap"><code class="xref py py-class docutils literal notranslate"><span class="pre">PropertyMap</span></code></a> objects</p>
<blockquote class="last">
<div><p>List (or generator) containing vertex property map objects which
indicate different isomorphism mappings. The property maps vertices in
<cite>sub</cite> to the corresponding vertex index in <cite>g</cite>.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>The implementation is based on the VF2 algorithm, introduced by Cordella et al.
<a class="reference internal" href="topology.html#cordella-improved-2001276" id="id8">[cordella-improved-2001276]</a> <a class="reference internal" href="topology.html#cordella-subgraph-2004276" id="id9">[cordella-subgraph-2004276]</a>. The spatial complexity
is of order <span class="math">\(O(V)\)</span>, where <span class="math">\(V\)</span> is the (maximum) number of vertices
of the two graphs. Time complexity is <span class="math">\(O(V^2)\)</span> in the best case and
<span class="math">\(O(V!\times V)\)</span> in the worst case.</p>
<p class="rubric">References</p>
<table class="docutils citation" frame="void" id="cordella-improved-2001276" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[cordella-improved-2001276]</td><td><em>(<a class="fn-backref" href="topology.html#id8">1</a>, <a class="fn-backref" href="topology.html#id10">2</a>)</em> L. P. Cordella, P. Foggia, C. Sansone, and M. Vento,
“An improved algorithm for matching large graphs.”, 3rd IAPR-TC15 Workshop
on Graph-based Representations in Pattern Recognition, pp. 149-159, Cuen, 2001.
<a class="reference external" href="http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.101.5342">http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.101.5342</a></td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="cordella-subgraph-2004276" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[cordella-subgraph-2004276]</td><td><em>(<a class="fn-backref" href="topology.html#id9">1</a>, <a class="fn-backref" href="topology.html#id11">2</a>)</em> L. P. Cordella, P. Foggia, C. Sansone, and M. Vento,
“A (Sub)Graph Isomorphism Algorithm for Matching Large Graphs.”,
IEEE Trans. Pattern Anal. Mach. Intell., vol. 26, no. 10, pp. 1367-1372, 2004.
<a class="reference external" href="https://dx.doi.org/10.1109/TPAMI.2004.75">DOI: 10.1109/TPAMI.2004.75</a> [<a class="reference external" href="https://sci-hub.tw/10.1109/TPAMI.2004.75">sci-hub</a>, <a class="reference external" href="https://scihub22266oqcxt.onion.link/10.1109/TPAMI.2004.75">&#64;tor</a>]</td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="boost-subgraph-iso276" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="topology.html#id12">[boost-subgraph-iso276]</a></td><td><a class="reference external" href="http://www.boost.org/libs/graph/doc/vf2_sub_graph_iso.html">http://www.boost.org/libs/graph/doc/vf2_sub_graph_iso.html</a></td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="subgraph-isormophism-wikipedia276" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="topology.html#id13">[subgraph-isormophism-wikipedia276]</a></td><td><a class="reference external" href="http://en.wikipedia.org/wiki/Subgraph_isomorphism_problem">http://en.wikipedia.org/wiki/Subgraph_isomorphism_problem</a></td></tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">numpy.random</span> <span class="k">import</span> <span class="n">poisson</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">g</span> <span class="o">=</span> <span class="n">gt</span><span class="o">.</span><span class="n">complete_graph</span><span class="p">(</span><span class="mi">30</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sub</span> <span class="o">=</span> <span class="n">gt</span><span class="o">.</span><span class="n">complete_graph</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">vm</span> <span class="o">=</span> <span class="n">gt</span><span class="o">.</span><span class="n">subgraph_isomorphism</span><span class="p">(</span><span class="n">sub</span><span class="p">,</span> <span class="n">g</span><span class="p">,</span> <span class="n">max_n</span><span class="o">=</span><span class="mi">100</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">vm</span><span class="p">))</span>
<span class="go">100</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">vm</span><span class="p">)):</span>
<span class="gp">... </span>  <span class="n">g</span><span class="o">.</span><span class="n">set_vertex_filter</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>
<span class="gp">... </span>  <span class="n">g</span><span class="o">.</span><span class="n">set_edge_filter</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>
<span class="gp">... </span>  <span class="n">vmask</span><span class="p">,</span> <span class="n">emask</span> <span class="o">=</span> <span class="n">gt</span><span class="o">.</span><span class="n">mark_subgraph</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">sub</span><span class="p">,</span> <span class="n">vm</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
<span class="gp">... </span>  <span class="n">g</span><span class="o">.</span><span class="n">set_vertex_filter</span><span class="p">(</span><span class="n">vmask</span><span class="p">)</span>
<span class="gp">... </span>  <span class="n">g</span><span class="o">.</span><span class="n">set_edge_filter</span><span class="p">(</span><span class="n">emask</span><span class="p">)</span>
<span class="gp">... </span>  <span class="k">assert</span> <span class="n">gt</span><span class="o">.</span><span class="n">isomorphism</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">sub</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">g</span><span class="o">.</span><span class="n">set_vertex_filter</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">g</span><span class="o">.</span><span class="n">set_edge_filter</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ewidth</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">copy_property</span><span class="p">(</span><span class="n">emask</span><span class="p">,</span> <span class="n">value_type</span><span class="o">=</span><span class="s2">&quot;double&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ewidth</span><span class="o">.</span><span class="n">a</span> <span class="o">+=</span> <span class="mf">0.5</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ewidth</span><span class="o">.</span><span class="n">a</span> <span class="o">*=</span> <span class="mi">2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">gt</span><span class="o">.</span><span class="n">graph_draw</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">vertex_fill_color</span><span class="o">=</span><span class="n">vmask</span><span class="p">,</span> <span class="n">edge_color</span><span class="o">=</span><span class="n">emask</span><span class="p">,</span>
<span class="gp">... </span>              <span class="n">edge_pen_width</span><span class="o">=</span><span class="n">ewidth</span><span class="p">,</span> <span class="n">output_size</span><span class="o">=</span><span class="p">(</span><span class="mi">200</span><span class="p">,</span> <span class="mi">200</span><span class="p">),</span>
<span class="gp">... </span>              <span class="n">output</span><span class="o">=</span><span class="s2">&quot;subgraph-iso-embed.pdf&quot;</span><span class="p">)</span>
<span class="go">&lt;...&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">gt</span><span class="o">.</span><span class="n">graph_draw</span><span class="p">(</span><span class="n">sub</span><span class="p">,</span> <span class="n">output_size</span><span class="o">=</span><span class="p">(</span><span class="mi">200</span><span class="p">,</span> <span class="mi">200</span><span class="p">),</span> <span class="n">output</span><span class="o">=</span><span class="s2">&quot;subgraph-iso.pdf&quot;</span><span class="p">)</span>
<span class="go">&lt;...&gt;</span>
</pre></div>
</div>
<img alt="_images/subgraph-iso.png" src="https://graph-tool.skewed.de/static/doc/_images/subgraph-iso.png" />
<img alt="_images/subgraph-iso-embed.png" src="https://graph-tool.skewed.de/static/doc/_images/subgraph-iso-embed.png" />
<p><strong>Left:</strong> Subgraph searched, <strong>Right:</strong> One isomorphic subgraph found in main graph.</p>
</dd></dl>

<dl class="function">
<dt id="graph_tool.topology.mark_subgraph">
<code class="descclassname">graph_tool.topology.</code><code class="descname">mark_subgraph</code><span class="sig-paren">(</span><em>g</em>, <em>sub</em>, <em>vmap</em>, <em>vmask=None</em>, <em>emask=None</em><span class="sig-paren">)</span><a class="reference internal" href="../static/doc/_modules/graph_tool/topology.html#mark_subgraph"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="topology.html#graph_tool.topology.mark_subgraph" title="Permalink to this definition">¶</a></dt>
<dd><p>Mark a given subgraph <cite>sub</cite> on the graph <cite>g</cite>.</p>
<p>The mapping must be provided by the <cite>vmap</cite> and <cite>emap</cite> parameters,
which map vertices/edges of <cite>sub</cite> to indexes of the corresponding
vertices/edges in <cite>g</cite>.</p>
<p>This returns a vertex and an edge property map, with value type ‘bool’,
indicating whether or not a vertex/edge in <cite>g</cite> corresponds to the subgraph
<cite>sub</cite>.</p>
</dd></dl>

<dl class="function">
<dt id="graph_tool.topology.min_spanning_tree">
<code class="descclassname">graph_tool.topology.</code><code class="descname">min_spanning_tree</code><span class="sig-paren">(</span><em>g</em>, <em>weights=None</em>, <em>root=None</em>, <em>tree_map=None</em><span class="sig-paren">)</span><a class="reference internal" href="../static/doc/_modules/graph_tool/topology.html#min_spanning_tree"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="topology.html#graph_tool.topology.min_spanning_tree" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the minimum spanning tree of a given graph.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>g</strong> : <a class="reference internal" href="https://graph-tool.skewed.de/static/doc/graph_tool.html#graph_tool.Graph" title="graph_tool.Graph"><code class="xref py py-class docutils literal notranslate"><span class="pre">Graph</span></code></a></p>
<blockquote>
<div><p>Graph to be used.</p>
</div></blockquote>
<p><strong>weights</strong> : <a class="reference internal" href="https://graph-tool.skewed.de/static/doc/graph_tool.html#graph_tool.PropertyMap" title="graph_tool.PropertyMap"><code class="xref py py-class docutils literal notranslate"><span class="pre">PropertyMap</span></code></a> (optional, default: <cite>None</cite>)</p>
<blockquote>
<div><p>The edge weights. If provided, the minimum spanning tree will minimize
the edge weights.</p>
</div></blockquote>
<p><strong>root</strong> : <a class="reference internal" href="https://graph-tool.skewed.de/static/doc/graph_tool.html#graph_tool.Vertex" title="graph_tool.Vertex"><code class="xref py py-class docutils literal notranslate"><span class="pre">Vertex</span></code></a> (optional, default: <cite>None</cite>)</p>
<blockquote>
<div><p>Root of the minimum spanning tree. If this is provided, Prim’s algorithm
is used. Otherwise, Kruskal’s algorithm is used.</p>
</div></blockquote>
<p><strong>tree_map</strong> : <a class="reference internal" href="https://graph-tool.skewed.de/static/doc/graph_tool.html#graph_tool.PropertyMap" title="graph_tool.PropertyMap"><code class="xref py py-class docutils literal notranslate"><span class="pre">PropertyMap</span></code></a> (optional, default: <cite>None</cite>)</p>
<blockquote>
<div><p>If provided, the edge tree map will be written in this property map.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>tree_map</strong> : <a class="reference internal" href="https://graph-tool.skewed.de/static/doc/graph_tool.html#graph_tool.PropertyMap" title="graph_tool.PropertyMap"><code class="xref py py-class docutils literal notranslate"><span class="pre">PropertyMap</span></code></a></p>
<blockquote class="last">
<div><p>Edge property map with mark the tree edges: 1 for tree edge, 0
otherwise.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>The algorithm runs with <span class="math">\(O(E\log E)\)</span> complexity, or <span class="math">\(O(E\log V)\)</span>
if <cite>root</cite> is specified.</p>
<p class="rubric">References</p>
<table class="docutils citation" frame="void" id="kruskal-shortest-1956280" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="topology.html#id14">[kruskal-shortest-1956280]</a></td><td>J. B. Kruskal.  “On the shortest spanning subtree
of a graph and the traveling salesman problem”,  In Proceedings of the
American Mathematical Society, volume 7, pages 48-50, 1956.
<a class="reference external" href="https://dx.doi.org/10.1090/S0002-9939-1956-0078686-7">DOI: 10.1090/S0002-9939-1956-0078686-7</a> [<a class="reference external" href="https://sci-hub.tw/10.1090/S0002-9939-1956-0078686-7">sci-hub</a>, <a class="reference external" href="https://scihub22266oqcxt.onion.link/10.1090/S0002-9939-1956-0078686-7">&#64;tor</a>]</td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="prim-shortest-1957280" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="topology.html#id15">[prim-shortest-1957280]</a></td><td>R. Prim.  “Shortest connection networks and some
generalizations”,  Bell System Technical Journal, 36:1389-1401, 1957.</td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="boost-mst280" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="topology.html#id16">[boost-mst280]</a></td><td><a class="reference external" href="http://www.boost.org/libs/graph/doc/graph_theory_review.html#sec:minimum-spanning-tree">http://www.boost.org/libs/graph/doc/graph_theory_review.html#sec:minimum-spanning-tree</a></td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="mst-wiki280" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="topology.html#id17">[mst-wiki280]</a></td><td><a class="reference external" href="http://en.wikipedia.org/wiki/Minimum_spanning_tree">http://en.wikipedia.org/wiki/Minimum_spanning_tree</a></td></tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">numpy.random</span> <span class="k">import</span> <span class="n">random</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">g</span><span class="p">,</span> <span class="n">pos</span> <span class="o">=</span> <span class="n">gt</span><span class="o">.</span><span class="n">triangulation</span><span class="p">(</span><span class="n">random</span><span class="p">((</span><span class="mi">400</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span> <span class="o">*</span> <span class="mi">10</span><span class="p">,</span> <span class="nb">type</span><span class="o">=</span><span class="s2">&quot;delaunay&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">weight</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">new_edge_property</span><span class="p">(</span><span class="s2">&quot;double&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">g</span><span class="o">.</span><span class="n">edges</span><span class="p">():</span>
<span class="gp">... </span>   <span class="n">weight</span><span class="p">[</span><span class="n">e</span><span class="p">]</span> <span class="o">=</span> <span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">pos</span><span class="p">[</span><span class="n">e</span><span class="o">.</span><span class="n">target</span><span class="p">()]</span><span class="o">.</span><span class="n">a</span> <span class="o">-</span> <span class="n">pos</span><span class="p">[</span><span class="n">e</span><span class="o">.</span><span class="n">source</span><span class="p">()]</span><span class="o">.</span><span class="n">a</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">tree</span> <span class="o">=</span> <span class="n">gt</span><span class="o">.</span><span class="n">min_spanning_tree</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">weights</span><span class="o">=</span><span class="n">weight</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">gt</span><span class="o">.</span><span class="n">graph_draw</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">pos</span><span class="o">=</span><span class="n">pos</span><span class="p">,</span> <span class="n">output</span><span class="o">=</span><span class="s2">&quot;triang_orig.pdf&quot;</span><span class="p">)</span>
<span class="go">&lt;...&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">u</span> <span class="o">=</span> <span class="n">gt</span><span class="o">.</span><span class="n">GraphView</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">efilt</span><span class="o">=</span><span class="n">tree</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">gt</span><span class="o">.</span><span class="n">graph_draw</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">pos</span><span class="o">=</span><span class="n">pos</span><span class="p">,</span> <span class="n">output</span><span class="o">=</span><span class="s2">&quot;triang_min_span_tree.pdf&quot;</span><span class="p">)</span>
<span class="go">&lt;...&gt;</span>
</pre></div>
</div>
<a class="reference internal image-reference" href="../static/doc/_images/triang_orig.png"><img alt="_images/triang_orig.png" src="../static/doc/_images/triang_orig.png" style="width: 400px;" /></a>
<a class="reference internal image-reference" href="../static/doc/_images/triang_min_span_tree.png"><img alt="_images/triang_min_span_tree.png" src="../static/doc/_images/triang_min_span_tree.png" style="width: 400px;" /></a>
<p><em>Left:</em> Original graph, <em>Right:</em> The minimum spanning tree.</p>
</dd></dl>

<dl class="function">
<dt id="graph_tool.topology.random_spanning_tree">
<code class="descclassname">graph_tool.topology.</code><code class="descname">random_spanning_tree</code><span class="sig-paren">(</span><em>g</em>, <em>weights=None</em>, <em>root=None</em>, <em>tree_map=None</em><span class="sig-paren">)</span><a class="reference internal" href="../static/doc/_modules/graph_tool/topology.html#random_spanning_tree"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="topology.html#graph_tool.topology.random_spanning_tree" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a random spanning tree of a given graph, which can be directed or
undirected.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>g</strong> : <a class="reference internal" href="https://graph-tool.skewed.de/static/doc/graph_tool.html#graph_tool.Graph" title="graph_tool.Graph"><code class="xref py py-class docutils literal notranslate"><span class="pre">Graph</span></code></a></p>
<blockquote>
<div><p>Graph to be used.</p>
</div></blockquote>
<p><strong>weights</strong> : <a class="reference internal" href="https://graph-tool.skewed.de/static/doc/graph_tool.html#graph_tool.PropertyMap" title="graph_tool.PropertyMap"><code class="xref py py-class docutils literal notranslate"><span class="pre">PropertyMap</span></code></a> (optional, default: <cite>None</cite>)</p>
<blockquote>
<div><p>The edge weights. If provided, the probability of a particular spanning
tree being selected is the product of its edge weights.</p>
</div></blockquote>
<p><strong>root</strong> : <a class="reference internal" href="https://graph-tool.skewed.de/static/doc/graph_tool.html#graph_tool.Vertex" title="graph_tool.Vertex"><code class="xref py py-class docutils literal notranslate"><span class="pre">Vertex</span></code></a> (optional, default: <cite>None</cite>)</p>
<blockquote>
<div><p>Root of the spanning tree. If not provided, it will be selected randomly.</p>
</div></blockquote>
<p><strong>tree_map</strong> : <a class="reference internal" href="https://graph-tool.skewed.de/static/doc/graph_tool.html#graph_tool.PropertyMap" title="graph_tool.PropertyMap"><code class="xref py py-class docutils literal notranslate"><span class="pre">PropertyMap</span></code></a> (optional, default: <cite>None</cite>)</p>
<blockquote>
<div><p>If provided, the edge tree map will be written in this property map.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>tree_map</strong> : <a class="reference internal" href="https://graph-tool.skewed.de/static/doc/graph_tool.html#graph_tool.PropertyMap" title="graph_tool.PropertyMap"><code class="xref py py-class docutils literal notranslate"><span class="pre">PropertyMap</span></code></a></p>
<blockquote class="last">
<div><p>Edge property map with mark the tree edges: 1 for tree edge, 0
otherwise.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>The running time for this algorithm is <span class="math">\(O(\tau)\)</span>, with <span class="math">\(\tau\)</span>
being the mean hitting time of a random walk on the graph. In the worse case,
we have <span class="math">\(\tau \sim O(V^3)\)</span>, with <span class="math">\(V\)</span> being the number of
vertices in the graph. However, in much more typical cases (e.g. sparse
random graphs) the running time is simply <span class="math">\(O(V)\)</span>.</p>
<p class="rubric">References</p>
<table class="docutils citation" frame="void" id="wilson-generating-1996284" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="topology.html#id18">[wilson-generating-1996284]</a></td><td>David Bruce Wilson, “Generating random spanning
trees more quickly than the cover time”, Proceedings of the twenty-eighth
annual ACM symposium on Theory of computing, Pages 296-303, ACM New York,
1996, <a class="reference external" href="https://dx.doi.org/10.1145/237814.237880">DOI: 10.1145/237814.237880</a> [<a class="reference external" href="https://sci-hub.tw/10.1145/237814.237880">sci-hub</a>, <a class="reference external" href="https://scihub22266oqcxt.onion.link/10.1145/237814.237880">&#64;tor</a>]</td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="boost-rst284" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="topology.html#id19">[boost-rst284]</a></td><td><a class="reference external" href="http://www.boost.org/libs/graph/doc/random_spanning_tree.html">http://www.boost.org/libs/graph/doc/random_spanning_tree.html</a></td></tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">numpy.random</span> <span class="k">import</span> <span class="n">random</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">g</span><span class="p">,</span> <span class="n">pos</span> <span class="o">=</span> <span class="n">gt</span><span class="o">.</span><span class="n">triangulation</span><span class="p">(</span><span class="n">random</span><span class="p">((</span><span class="mi">400</span><span class="p">,</span> <span class="mi">2</span><span class="p">)),</span> <span class="nb">type</span><span class="o">=</span><span class="s2">&quot;delaunay&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">weight</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">new_edge_property</span><span class="p">(</span><span class="s2">&quot;double&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">g</span><span class="o">.</span><span class="n">edges</span><span class="p">():</span>
<span class="gp">... </span>   <span class="n">weight</span><span class="p">[</span><span class="n">e</span><span class="p">]</span> <span class="o">=</span> <span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">pos</span><span class="p">[</span><span class="n">e</span><span class="o">.</span><span class="n">target</span><span class="p">()]</span><span class="o">.</span><span class="n">a</span> <span class="o">-</span> <span class="n">pos</span><span class="p">[</span><span class="n">e</span><span class="o">.</span><span class="n">source</span><span class="p">()]</span><span class="o">.</span><span class="n">a</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">tree</span> <span class="o">=</span> <span class="n">gt</span><span class="o">.</span><span class="n">random_spanning_tree</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">weights</span><span class="o">=</span><span class="n">weight</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">tree2</span> <span class="o">=</span> <span class="n">gt</span><span class="o">.</span><span class="n">random_spanning_tree</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">weights</span><span class="o">=</span><span class="n">weight</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">gt</span><span class="o">.</span><span class="n">graph_draw</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">pos</span><span class="o">=</span><span class="n">pos</span><span class="p">,</span> <span class="n">output</span><span class="o">=</span><span class="s2">&quot;rtriang_orig.pdf&quot;</span><span class="p">)</span>
<span class="go">&lt;...&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">u</span> <span class="o">=</span> <span class="n">gt</span><span class="o">.</span><span class="n">GraphView</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">efilt</span><span class="o">=</span><span class="n">tree</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">gt</span><span class="o">.</span><span class="n">graph_draw</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">pos</span><span class="o">=</span><span class="n">pos</span><span class="p">,</span> <span class="n">output</span><span class="o">=</span><span class="s2">&quot;triang_random_span_tree.pdf&quot;</span><span class="p">)</span>
<span class="go">&lt;...&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">u2</span> <span class="o">=</span> <span class="n">gt</span><span class="o">.</span><span class="n">GraphView</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">efilt</span><span class="o">=</span><span class="n">tree2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">gt</span><span class="o">.</span><span class="n">graph_draw</span><span class="p">(</span><span class="n">u2</span><span class="p">,</span> <span class="n">pos</span><span class="o">=</span><span class="n">pos</span><span class="p">,</span> <span class="n">output</span><span class="o">=</span><span class="s2">&quot;triang_random_span_tree2.pdf&quot;</span><span class="p">)</span>
<span class="go">&lt;...&gt;</span>
</pre></div>
</div>
<a class="reference internal image-reference" href="../static/doc/_images/rtriang_orig.png"><img alt="_images/rtriang_orig.png" src="../static/doc/_images/rtriang_orig.png" style="width: 300px;" /></a>
<a class="reference internal image-reference" href="../static/doc/_images/triang_random_span_tree.png"><img alt="_images/triang_random_span_tree.png" src="../static/doc/_images/triang_random_span_tree.png" style="width: 300px;" /></a>
<a class="reference internal image-reference" href="../static/doc/_images/triang_random_span_tree2.png"><img alt="_images/triang_random_span_tree2.png" src="../static/doc/_images/triang_random_span_tree2.png" style="width: 300px;" /></a>
<p><em>Left:</em> Original graph, <em>Middle:</em> A random spanning tree, <em>Right:</em> Another
random spanning tree</p>
</dd></dl>

<dl class="function">
<dt id="graph_tool.topology.dominator_tree">
<code class="descclassname">graph_tool.topology.</code><code class="descname">dominator_tree</code><span class="sig-paren">(</span><em>g</em>, <em>root</em>, <em>dom_map=None</em><span class="sig-paren">)</span><a class="reference internal" href="../static/doc/_modules/graph_tool/topology.html#dominator_tree"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="topology.html#graph_tool.topology.dominator_tree" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a vertex property map the dominator vertices for each vertex.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>g</strong> : <a class="reference internal" href="https://graph-tool.skewed.de/static/doc/graph_tool.html#graph_tool.Graph" title="graph_tool.Graph"><code class="xref py py-class docutils literal notranslate"><span class="pre">Graph</span></code></a></p>
<blockquote>
<div><p>Graph to be used.</p>
</div></blockquote>
<p><strong>root</strong> : <a class="reference internal" href="https://graph-tool.skewed.de/static/doc/graph_tool.html#graph_tool.Vertex" title="graph_tool.Vertex"><code class="xref py py-class docutils literal notranslate"><span class="pre">Vertex</span></code></a></p>
<blockquote>
<div><p>The root vertex.</p>
</div></blockquote>
<p><strong>dom_map</strong> : <a class="reference internal" href="https://graph-tool.skewed.de/static/doc/graph_tool.html#graph_tool.PropertyMap" title="graph_tool.PropertyMap"><code class="xref py py-class docutils literal notranslate"><span class="pre">PropertyMap</span></code></a> (optional, default: None)</p>
<blockquote>
<div><p>If provided, the dominator map will be written in this property map.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>dom_map</strong> : <a class="reference internal" href="https://graph-tool.skewed.de/static/doc/graph_tool.html#graph_tool.PropertyMap" title="graph_tool.PropertyMap"><code class="xref py py-class docutils literal notranslate"><span class="pre">PropertyMap</span></code></a></p>
<blockquote class="last">
<div><p>The dominator map. It contains for each vertex, the index of its
dominator vertex.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>A vertex u dominates a vertex v, if every path of directed graph from the
entry to v must go through u.</p>
<p>The algorithm runs with <span class="math">\(O((V+E)\log (V+E))\)</span> complexity.</p>
<p class="rubric">References</p>
<table class="docutils citation" frame="void" id="dominator-bgl286" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="topology.html#id20">[dominator-bgl286]</a></td><td><a class="reference external" href="http://www.boost.org/libs/graph/doc/lengauer_tarjan_dominator.htm">http://www.boost.org/libs/graph/doc/lengauer_tarjan_dominator.htm</a></td></tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">g</span> <span class="o">=</span> <span class="n">gt</span><span class="o">.</span><span class="n">random_graph</span><span class="p">(</span><span class="mi">100</span><span class="p">,</span> <span class="k">lambda</span><span class="p">:</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">tree</span> <span class="o">=</span> <span class="n">gt</span><span class="o">.</span><span class="n">min_spanning_tree</span><span class="p">(</span><span class="n">g</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">g</span><span class="o">.</span><span class="n">set_edge_filter</span><span class="p">(</span><span class="n">tree</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">root</span> <span class="o">=</span> <span class="p">[</span><span class="n">v</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">g</span><span class="o">.</span><span class="n">vertices</span><span class="p">()</span> <span class="k">if</span> <span class="n">v</span><span class="o">.</span><span class="n">in_degree</span><span class="p">()</span> <span class="o">==</span> <span class="mi">0</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dom</span> <span class="o">=</span> <span class="n">gt</span><span class="o">.</span><span class="n">dominator_tree</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">root</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">dom</span><span class="o">.</span><span class="n">a</span><span class="p">)</span>
<span class="go">[ 0  0  0  0  0  0  0 74  0  0  0 97  0  0  0  0  0  0  0  0  0  0  0  0</span>
<span class="go">  0  0  0  0  0 97  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0</span>
<span class="go">  0  0  0  0  0  0  0  0  0  0  0  0 64 67  0  0 67  0  0 74  0  0  0  0</span>
<span class="go"> 23  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0</span>
<span class="go">  0  7  0  0]</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="graph_tool.topology.topological_sort">
<code class="descclassname">graph_tool.topology.</code><code class="descname">topological_sort</code><span class="sig-paren">(</span><em>g</em><span class="sig-paren">)</span><a class="reference internal" href="../static/doc/_modules/graph_tool/topology.html#topological_sort"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="topology.html#graph_tool.topology.topological_sort" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the topological sort of the given graph. It is returned as an array
of vertex indexes, in the sort order.</p>
<p class="rubric">Notes</p>
<p>The topological sort algorithm creates a linear ordering of the vertices
such that if edge (u,v) appears in the graph, then u comes before v in the
ordering. The graph must be a directed acyclic graph (DAG).</p>
<p>The time complexity is <span class="math">\(O(V + E)\)</span>.</p>
<p class="rubric">References</p>
<table class="docutils citation" frame="void" id="topological-boost287" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="topology.html#id21">[topological-boost287]</a></td><td><a class="reference external" href="http://www.boost.org/libs/graph/doc/topological_sort.html">http://www.boost.org/libs/graph/doc/topological_sort.html</a></td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="topological-wiki287" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="topology.html#id22">[topological-wiki287]</a></td><td><a class="reference external" href="http://en.wikipedia.org/wiki/Topological_sorting">http://en.wikipedia.org/wiki/Topological_sorting</a></td></tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">g</span> <span class="o">=</span> <span class="n">gt</span><span class="o">.</span><span class="n">random_graph</span><span class="p">(</span><span class="mi">30</span><span class="p">,</span> <span class="k">lambda</span><span class="p">:</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">tree</span> <span class="o">=</span> <span class="n">gt</span><span class="o">.</span><span class="n">min_spanning_tree</span><span class="p">(</span><span class="n">g</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">g</span><span class="o">.</span><span class="n">set_edge_filter</span><span class="p">(</span><span class="n">tree</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sort</span> <span class="o">=</span> <span class="n">gt</span><span class="o">.</span><span class="n">topological_sort</span><span class="p">(</span><span class="n">g</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">sort</span><span class="p">)</span>
<span class="go">[28 26 29 27 23 22 18 17 16 20 21 15 12 11 10 25 14  9  8  7  5  3  2 24</span>
<span class="go">  4  6  1  0 19 13]</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="graph_tool.topology.transitive_closure">
<code class="descclassname">graph_tool.topology.</code><code class="descname">transitive_closure</code><span class="sig-paren">(</span><em>g</em><span class="sig-paren">)</span><a class="reference internal" href="../static/doc/_modules/graph_tool/topology.html#transitive_closure"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="topology.html#graph_tool.topology.transitive_closure" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the transitive closure graph of g.</p>
<p class="rubric">Notes</p>
<p>The transitive closure of a graph G = (V,E) is a graph G* = (V,E*) such that
E* contains an edge (u,v) if and only if G contains a path (of at least one
edge) from u to v. The transitive_closure() function transforms the input
graph g into the transitive closure graph tc.</p>
<p>The time complexity (worst-case) is <span class="math">\(O(VE)\)</span>.</p>
<p class="rubric">References</p>
<table class="docutils citation" frame="void" id="transitive-boost289" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="topology.html#id23">[transitive-boost289]</a></td><td><a class="reference external" href="http://www.boost.org/libs/graph/doc/transitive_closure.html">http://www.boost.org/libs/graph/doc/transitive_closure.html</a></td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="transitive-wiki289" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="topology.html#id24">[transitive-wiki289]</a></td><td><a class="reference external" href="http://en.wikipedia.org/wiki/Transitive_closure">http://en.wikipedia.org/wiki/Transitive_closure</a></td></tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">g</span> <span class="o">=</span> <span class="n">gt</span><span class="o">.</span><span class="n">random_graph</span><span class="p">(</span><span class="mi">30</span><span class="p">,</span> <span class="k">lambda</span><span class="p">:</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">tc</span> <span class="o">=</span> <span class="n">gt</span><span class="o">.</span><span class="n">transitive_closure</span><span class="p">(</span><span class="n">g</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="graph_tool.topology.label_components">
<code class="descclassname">graph_tool.topology.</code><code class="descname">label_components</code><span class="sig-paren">(</span><em>g</em>, <em>vprop=None</em>, <em>directed=None</em>, <em>attractors=False</em><span class="sig-paren">)</span><a class="reference internal" href="../static/doc/_modules/graph_tool/topology.html#label_components"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="topology.html#graph_tool.topology.label_components" title="Permalink to this definition">¶</a></dt>
<dd><p>Label the components to which each vertex in the graph belongs. If the
graph is directed, it finds the strongly connected components.</p>
<p>A property map with the component labels is returned, together with an
histogram of component labels.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>g</strong> : <a class="reference internal" href="https://graph-tool.skewed.de/static/doc/graph_tool.html#graph_tool.Graph" title="graph_tool.Graph"><code class="xref py py-class docutils literal notranslate"><span class="pre">Graph</span></code></a></p>
<blockquote>
<div><p>Graph to be used.</p>
</div></blockquote>
<p><strong>vprop</strong> : <a class="reference internal" href="https://graph-tool.skewed.de/static/doc/graph_tool.html#graph_tool.PropertyMap" title="graph_tool.PropertyMap"><code class="xref py py-class docutils literal notranslate"><span class="pre">PropertyMap</span></code></a> (optional, default: <code class="docutils literal notranslate"><span class="pre">None</span></code>)</p>
<blockquote>
<div><p>Vertex property to store the component labels. If none is supplied, one
is created.</p>
</div></blockquote>
<p><strong>directed</strong> : bool (optional, default: <code class="docutils literal notranslate"><span class="pre">None</span></code>)</p>
<blockquote>
<div><p>Treat graph as directed or not, independently of its actual
directionality.</p>
</div></blockquote>
<p><strong>attractors</strong> : bool (optional, default: <code class="docutils literal notranslate"><span class="pre">False</span></code>)</p>
<blockquote>
<div><p>If <code class="docutils literal notranslate"><span class="pre">True</span></code>, and the graph is directed, an additional array with Boolean
values is returned, specifying if the strongly connected components are
attractors or not.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>comp</strong> : <a class="reference internal" href="https://graph-tool.skewed.de/static/doc/graph_tool.html#graph_tool.PropertyMap" title="graph_tool.PropertyMap"><code class="xref py py-class docutils literal notranslate"><span class="pre">PropertyMap</span></code></a></p>
<blockquote>
<div><p>Vertex property map with component labels.</p>
</div></blockquote>
<p><strong>hist</strong> : <a class="reference external" href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v1.14)"><code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code></a></p>
<blockquote>
<div><p>Histogram of component labels.</p>
</div></blockquote>
<p><strong>is_attractor</strong> : <a class="reference external" href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v1.14)"><code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code></a></p>
<blockquote class="last">
<div><p>A Boolean array specifying if the strongly connected components are
attractors or not. This returned only if <code class="docutils literal notranslate"><span class="pre">attractors</span> <span class="pre">==</span> <span class="pre">True</span></code>, and the
graph is directed.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>The components are arbitrarily labeled from 0 to N-1, where N is the total
number of components.</p>
<p>The algorithm runs in <span class="math">\(O(V + E)\)</span> time.</p>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">g</span> <span class="o">=</span> <span class="n">gt</span><span class="o">.</span><span class="n">random_graph</span><span class="p">(</span><span class="mi">100</span><span class="p">,</span> <span class="k">lambda</span><span class="p">:</span> <span class="p">(</span><span class="n">poisson</span><span class="p">(</span><span class="mi">2</span><span class="p">),</span> <span class="n">poisson</span><span class="p">(</span><span class="mi">2</span><span class="p">)))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">comp</span><span class="p">,</span> <span class="n">hist</span><span class="p">,</span> <span class="n">is_attractor</span> <span class="o">=</span> <span class="n">gt</span><span class="o">.</span><span class="n">label_components</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">attractors</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">comp</span><span class="o">.</span><span class="n">a</span><span class="p">)</span>
<span class="go">[ 9  9  9  9 10  1  9 11 12  9  9  9  9  9  9 13  9  9  9  0  9  9 16  9</span>
<span class="go">  9  3  9  9  4 17  9  9 18  9  9 19 20  9  9  9 14  5  9  9  6  9  9  9</span>
<span class="go"> 21  9  9  9  9  9  9  9  9  9  9  9  9  9  9  2  9  8  9 22 15  9  9  9</span>
<span class="go">  9  9 23 25  9  9 26 27 28 29 30  9  9  9  9  9  9 31  9  9  9  9  9 32</span>
<span class="go">  9  9  7 24]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">hist</span><span class="p">)</span>
<span class="go">[ 1  1  1  1  1  1  1  1  1 68  1  1  1  1  1  1  1  1  1  1  1  1  1  1</span>
<span class="go">  1  1  1  1  1  1  1  1  1]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">is_attractor</span><span class="p">)</span>
<span class="go">[ True  True  True  True  True  True  True  True  True False  True False</span>
<span class="go"> False False False False False False False False False False False False</span>
<span class="go"> False False False False  True False  True False False]</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="graph_tool.topology.label_largest_component">
<code class="descclassname">graph_tool.topology.</code><code class="descname">label_largest_component</code><span class="sig-paren">(</span><em>g</em>, <em>directed=None</em><span class="sig-paren">)</span><a class="reference internal" href="../static/doc/_modules/graph_tool/topology.html#label_largest_component"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="topology.html#graph_tool.topology.label_largest_component" title="Permalink to this definition">¶</a></dt>
<dd><p>Label the largest component in the graph. If the graph is directed, then the
largest strongly connected component is labelled.</p>
<p>A property map with a boolean label is returned.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>g</strong> : <a class="reference internal" href="https://graph-tool.skewed.de/static/doc/graph_tool.html#graph_tool.Graph" title="graph_tool.Graph"><code class="xref py py-class docutils literal notranslate"><span class="pre">Graph</span></code></a></p>
<blockquote>
<div><p>Graph to be used.</p>
</div></blockquote>
<p><strong>directed</strong> : bool (optional, default:None)</p>
<blockquote>
<div><p>Treat graph as directed or not, independently of its actual
directionality.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>comp</strong> : <a class="reference internal" href="https://graph-tool.skewed.de/static/doc/graph_tool.html#graph_tool.PropertyMap" title="graph_tool.PropertyMap"><code class="xref py py-class docutils literal notranslate"><span class="pre">PropertyMap</span></code></a></p>
<blockquote class="last">
<div><p>Boolean vertex property map which labels the largest component.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>The algorithm runs in <span class="math">\(O(V + E)\)</span> time.</p>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">g</span> <span class="o">=</span> <span class="n">gt</span><span class="o">.</span><span class="n">random_graph</span><span class="p">(</span><span class="mi">100</span><span class="p">,</span> <span class="k">lambda</span><span class="p">:</span> <span class="n">poisson</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span> <span class="n">directed</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">l</span> <span class="o">=</span> <span class="n">gt</span><span class="o">.</span><span class="n">label_largest_component</span><span class="p">(</span><span class="n">g</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">l</span><span class="o">.</span><span class="n">a</span><span class="p">)</span>
<span class="go">[0 0 0 0 1 0 0 0 0 1 0 1 0 0 0 0 0 0 0 0 0 0 1 0 1 0 0 1 0 1 0 0 0 0 0 0 0</span>
<span class="go"> 0 0 0 0 1 0 0 0 1 0 0 0 1 0 0 1 0 0 0 1 0 1 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0</span>
<span class="go"> 0 0 0 0 0 0 0 0 1 0 0 1 0 1 0 0 0 0 0 0 0 0 0 1 0 0]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">u</span> <span class="o">=</span> <span class="n">gt</span><span class="o">.</span><span class="n">GraphView</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">vfilt</span><span class="o">=</span><span class="n">l</span><span class="p">)</span>   <span class="c1"># extract the largest component as a graph</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">u</span><span class="o">.</span><span class="n">num_vertices</span><span class="p">())</span>
<span class="go">18</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="graph_tool.topology.label_out_component">
<code class="descclassname">graph_tool.topology.</code><code class="descname">label_out_component</code><span class="sig-paren">(</span><em>g</em>, <em>root</em>, <em>label=None</em><span class="sig-paren">)</span><a class="reference internal" href="../static/doc/_modules/graph_tool/topology.html#label_out_component"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="topology.html#graph_tool.topology.label_out_component" title="Permalink to this definition">¶</a></dt>
<dd><p>Label the out-component (or simply the component for undirected graphs) of a
root vertex.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>g</strong> : <a class="reference internal" href="https://graph-tool.skewed.de/static/doc/graph_tool.html#graph_tool.Graph" title="graph_tool.Graph"><code class="xref py py-class docutils literal notranslate"><span class="pre">Graph</span></code></a></p>
<blockquote>
<div><p>Graph to be used.</p>
</div></blockquote>
<p><strong>root</strong> : <a class="reference internal" href="https://graph-tool.skewed.de/static/doc/graph_tool.html#graph_tool.Vertex" title="graph_tool.Vertex"><code class="xref py py-class docutils literal notranslate"><span class="pre">Vertex</span></code></a></p>
<blockquote>
<div><p>The root vertex.</p>
</div></blockquote>
<p><strong>label</strong> : <a class="reference internal" href="https://graph-tool.skewed.de/static/doc/graph_tool.html#graph_tool.PropertyMap" title="graph_tool.PropertyMap"><code class="xref py py-class docutils literal notranslate"><span class="pre">PropertyMap</span></code></a> (optional, default: <code class="docutils literal notranslate"><span class="pre">None</span></code>)</p>
<blockquote>
<div><p>If provided, this must be an initialized Boolean vertex property map
where the out-component will be labeled.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>label</strong> : <a class="reference internal" href="https://graph-tool.skewed.de/static/doc/graph_tool.html#graph_tool.PropertyMap" title="graph_tool.PropertyMap"><code class="xref py py-class docutils literal notranslate"><span class="pre">PropertyMap</span></code></a></p>
<blockquote class="last">
<div><p>Boolean vertex property map which labels the out-component.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>The algorithm runs in <span class="math">\(O(V + E)\)</span> time.</p>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">g</span> <span class="o">=</span> <span class="n">gt</span><span class="o">.</span><span class="n">random_graph</span><span class="p">(</span><span class="mi">100</span><span class="p">,</span> <span class="k">lambda</span><span class="p">:</span> <span class="n">poisson</span><span class="p">(</span><span class="mf">2.2</span><span class="p">),</span> <span class="n">directed</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">l</span> <span class="o">=</span> <span class="n">gt</span><span class="o">.</span><span class="n">label_out_component</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">g</span><span class="o">.</span><span class="n">vertex</span><span class="p">(</span><span class="mi">2</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">l</span><span class="o">.</span><span class="n">a</span><span class="p">)</span>
<span class="go">[1 1 1 1 1 1 0 1 1 1 0 0 1 1 1 1 1 1 0 1 1 1 0 1 1 1 1 1 1 1 0 0 0 1 1 1 1</span>
<span class="go"> 1 1 0 0 1 1 1 1 1 1 1 1 1 1 1 1 1 0 1 1 1 1 1 0 1 1 1 1 0 0 1 0 1 1 1 0 1</span>
<span class="go"> 1 1 0 0 1 1 1 1 1 1 1 1 1 0 1 1 1 0 1 1 1 0 1 1 1 0]</span>
</pre></div>
</div>
<p>The in-component can be obtained by reversing the graph.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">l</span> <span class="o">=</span> <span class="n">gt</span><span class="o">.</span><span class="n">label_out_component</span><span class="p">(</span><span class="n">gt</span><span class="o">.</span><span class="n">GraphView</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="nb">reversed</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">directed</span><span class="o">=</span><span class="kc">True</span><span class="p">),</span>
<span class="gp">... </span>                           <span class="n">g</span><span class="o">.</span><span class="n">vertex</span><span class="p">(</span><span class="mi">1</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">l</span><span class="o">.</span><span class="n">a</span><span class="p">)</span>
<span class="go">[0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0</span>
<span class="go"> 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0</span>
<span class="go"> 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0]</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="graph_tool.topology.label_biconnected_components">
<code class="descclassname">graph_tool.topology.</code><code class="descname">label_biconnected_components</code><span class="sig-paren">(</span><em>g</em>, <em>eprop=None</em>, <em>vprop=None</em><span class="sig-paren">)</span><a class="reference internal" href="../static/doc/_modules/graph_tool/topology.html#label_biconnected_components"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="topology.html#graph_tool.topology.label_biconnected_components" title="Permalink to this definition">¶</a></dt>
<dd><p>Label the edges of biconnected components, and the vertices which are
articulation points.</p>
<p>An edge property map with the component labels is returned, together a
boolean vertex map marking the articulation points, and an histogram of
component labels.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>g</strong> : <a class="reference internal" href="https://graph-tool.skewed.de/static/doc/graph_tool.html#graph_tool.Graph" title="graph_tool.Graph"><code class="xref py py-class docutils literal notranslate"><span class="pre">Graph</span></code></a></p>
<blockquote>
<div><p>Graph to be used.</p>
</div></blockquote>
<p><strong>eprop</strong> : <a class="reference internal" href="https://graph-tool.skewed.de/static/doc/graph_tool.html#graph_tool.PropertyMap" title="graph_tool.PropertyMap"><code class="xref py py-class docutils literal notranslate"><span class="pre">PropertyMap</span></code></a> (optional, default: None)</p>
<blockquote>
<div><p>Edge property to label the biconnected components.</p>
</div></blockquote>
<p><strong>vprop</strong> : <a class="reference internal" href="https://graph-tool.skewed.de/static/doc/graph_tool.html#graph_tool.PropertyMap" title="graph_tool.PropertyMap"><code class="xref py py-class docutils literal notranslate"><span class="pre">PropertyMap</span></code></a> (optional, default: None)</p>
<blockquote>
<div><p>Vertex property to mark the articulation points. If none is supplied,
one is created.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>bicomp</strong> : <a class="reference internal" href="https://graph-tool.skewed.de/static/doc/graph_tool.html#graph_tool.PropertyMap" title="graph_tool.PropertyMap"><code class="xref py py-class docutils literal notranslate"><span class="pre">PropertyMap</span></code></a></p>
<blockquote>
<div><p>Edge property map with the biconnected component labels.</p>
</div></blockquote>
<p><strong>articulation</strong> : <a class="reference internal" href="https://graph-tool.skewed.de/static/doc/graph_tool.html#graph_tool.PropertyMap" title="graph_tool.PropertyMap"><code class="xref py py-class docutils literal notranslate"><span class="pre">PropertyMap</span></code></a></p>
<blockquote>
<div><p>Boolean vertex property map which has value 1 for each vertex which is
an articulation point, and zero otherwise.</p>
</div></blockquote>
<p><strong>nc</strong> : int</p>
<blockquote class="last">
<div><p>Number of biconnected components.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>A connected graph is biconnected if the removal of any single vertex (and
all edges incident on that vertex) can not disconnect the graph. More
generally, the biconnected components of a graph are the maximal subsets of
vertices such that the removal of a vertex from a particular component will
not disconnect the component. Unlike connected components, vertices may
belong to multiple biconnected components: those vertices that belong to
more than one biconnected component are called “articulation points” or,
equivalently, “cut vertices”. Articulation points are vertices whose removal
would increase the number of connected components in the graph. Thus, a
graph without articulation points is biconnected. Vertices can be present in
multiple biconnected components, but each edge can only be contained in a
single biconnected component.</p>
<p>The algorithm runs in <span class="math">\(O(V + E)\)</span> time.</p>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">g</span> <span class="o">=</span> <span class="n">gt</span><span class="o">.</span><span class="n">random_graph</span><span class="p">(</span><span class="mi">100</span><span class="p">,</span> <span class="k">lambda</span><span class="p">:</span> <span class="n">poisson</span><span class="p">(</span><span class="mi">2</span><span class="p">),</span> <span class="n">directed</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">comp</span><span class="p">,</span> <span class="n">art</span><span class="p">,</span> <span class="n">hist</span> <span class="o">=</span> <span class="n">gt</span><span class="o">.</span><span class="n">label_biconnected_components</span><span class="p">(</span><span class="n">g</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">comp</span><span class="o">.</span><span class="n">a</span><span class="p">)</span>
<span class="go">[26 26 26 26 26 26 26 26 19 25 26 26 23 26 26 26 26  6 26 24 18 26 26 13</span>
<span class="go"> 26 26 26 26 26 26 26 26 26 26 26 16 29 26 26 26 26 26 26 15 26 26 26 26</span>
<span class="go"> 26  0 26 26 12  2 26 26 26 26 26 26 26 26  9  3 26 28 26 26  8 26  4 26</span>
<span class="go"> 26 26 14 26 26 26 26 30 11 26 26 26 20 26 26 27 26 33 26 22 17  7  5 32</span>
<span class="go"> 21 26  1 10 31]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">art</span><span class="o">.</span><span class="n">a</span><span class="p">)</span>
<span class="go">[1 0 1 1 0 0 0 0 0 0 0 0 1 0 0 1 1 0 0 0 0 0 0 0 0 0 0 0 1 1 0 0 0 0 1 1 0</span>
<span class="go"> 1 1 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 1 1 0 1 0 0 0 0 1 0 0 1 0 0 0 0 0 0 0 0</span>
<span class="go"> 1 0 0 1 0 0 0 1 1 0 0 1 0 0 1 1 0 0 0 1 0 0 1 0 0 0]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">hist</span><span class="p">)</span>
<span class="go">[ 1  1  1  1  1  1  1  1  1  1  1  1  1  1  1  1  1  1  1  1  1  1  1  1</span>
<span class="go">  1  1 68  1  1  1  1  1  1  1]</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="graph_tool.topology.vertex_percolation">
<code class="descclassname">graph_tool.topology.</code><code class="descname">vertex_percolation</code><span class="sig-paren">(</span><em>g</em>, <em>vertices</em>, <em>second=False</em><span class="sig-paren">)</span><a class="reference internal" href="../static/doc/_modules/graph_tool/topology.html#vertex_percolation"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="topology.html#graph_tool.topology.vertex_percolation" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the size of the largest or second-largest component as vertices
are (virtually)
removed from the graph.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>g</strong> : <a class="reference internal" href="https://graph-tool.skewed.de/static/doc/graph_tool.html#graph_tool.Graph" title="graph_tool.Graph"><code class="xref py py-class docutils literal notranslate"><span class="pre">Graph</span></code></a></p>
<blockquote>
<div><p>Graph to be used.</p>
</div></blockquote>
<p><strong>vertices</strong> : <a class="reference external" href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v1.14)"><code class="xref py py-class docutils literal notranslate"><span class="pre">numpy.ndarray</span></code></a> or iterable of ints</p>
<blockquote>
<div><p>List of vertices in reversed order of removal.</p>
</div></blockquote>
<p><strong>second</strong> : bool (optional, default: <code class="docutils literal notranslate"><span class="pre">False</span></code>)</p>
<blockquote>
<div><p>If <code class="docutils literal notranslate"><span class="pre">True</span></code>, the size of the second-largest component will be computed.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>size</strong> : <a class="reference external" href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v1.14)"><code class="xref py py-class docutils literal notranslate"><span class="pre">numpy.ndarray</span></code></a></p>
<blockquote>
<div><p>Size of the largest (or second-largest) component prior to removal of
each vertex.</p>
</div></blockquote>
<p><strong>comp</strong> : <a class="reference internal" href="https://graph-tool.skewed.de/static/doc/graph_tool.html#graph_tool.PropertyMap" title="graph_tool.PropertyMap"><code class="xref py py-class docutils literal notranslate"><span class="pre">PropertyMap</span></code></a></p>
<blockquote class="last">
<div><p>Vertex property map with component labels.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>The algorithm runs in <span class="math">\(O(V + E)\)</span> time.</p>
<p class="rubric">References</p>
<table class="docutils citation" frame="void" id="newman-ziff291" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="topology.html#id25">[newman-ziff291]</a></td><td>M. E. J. Newman, R. M. Ziff, “A fast Monte Carlo algorithm
for site or bond percolation”, Phys. Rev. E 64, 016706 (2001)
<a class="reference external" href="https://dx.doi.org/10.1103/PhysRevE.64.016706">DOI: 10.1103/PhysRevE.64.016706</a> [<a class="reference external" href="https://sci-hub.tw/10.1103/PhysRevE.64.016706">sci-hub</a>, <a class="reference external" href="https://scihub22266oqcxt.onion.link/10.1103/PhysRevE.64.016706">&#64;tor</a>], <a class="reference external" href="https://arxiv.org/abs/cond-mat/0101295">arXiv: cond-mat/0101295</a></td></tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">g</span> <span class="o">=</span> <span class="n">gt</span><span class="o">.</span><span class="n">random_graph</span><span class="p">(</span><span class="mi">10000</span><span class="p">,</span> <span class="k">lambda</span><span class="p">:</span> <span class="n">geometric</span><span class="p">(</span><span class="mf">1.</span><span class="o">/</span><span class="mi">4</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">directed</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">vertices</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">([</span><span class="n">v</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">g</span><span class="o">.</span><span class="n">vertices</span><span class="p">()],</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">v</span><span class="p">:</span> <span class="n">v</span><span class="o">.</span><span class="n">out_degree</span><span class="p">())</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sizes</span><span class="p">,</span> <span class="n">comp</span> <span class="o">=</span> <span class="n">gt</span><span class="o">.</span><span class="n">vertex_percolation</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">vertices</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">numpy</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">shuffle</span><span class="p">(</span><span class="n">vertices</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sizes2</span><span class="p">,</span> <span class="n">comp</span> <span class="o">=</span> <span class="n">gt</span><span class="o">.</span><span class="n">vertex_percolation</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">vertices</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">figure</span><span class="p">()</span>
<span class="go">&lt;...&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plot</span><span class="p">(</span><span class="n">sizes</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s2">&quot;Targeted&quot;</span><span class="p">)</span>
<span class="go">[...]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plot</span><span class="p">(</span><span class="n">sizes2</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s2">&quot;Random&quot;</span><span class="p">)</span>
<span class="go">[...]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">xlabel</span><span class="p">(</span><span class="s2">&quot;Vertices remaining&quot;</span><span class="p">)</span>
<span class="go">Text(...)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ylabel</span><span class="p">(</span><span class="s2">&quot;Size of largest component&quot;</span><span class="p">)</span>
<span class="go">Text(...)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">legend</span><span class="p">(</span><span class="n">loc</span><span class="o">=</span><span class="s2">&quot;lower right&quot;</span><span class="p">)</span>
<span class="go">&lt;...&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">savefig</span><span class="p">(</span><span class="s2">&quot;vertex-percolation.svg&quot;</span><span class="p">)</span>
</pre></div>
</div>
<div class="figure align-center" id="id82">
<img alt="_images/vertex-percolation.svg" src="../static/doc/_images/vertex-percolation.svg" /><p class="caption"><span class="caption-text">Targeted and random vertex percolation of a random graph with an
exponential degree distribution.</span></p>
</div>
</dd></dl>

<dl class="function">
<dt id="graph_tool.topology.edge_percolation">
<code class="descclassname">graph_tool.topology.</code><code class="descname">edge_percolation</code><span class="sig-paren">(</span><em>g</em>, <em>edges</em>, <em>second=False</em><span class="sig-paren">)</span><a class="reference internal" href="../static/doc/_modules/graph_tool/topology.html#edge_percolation"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="topology.html#graph_tool.topology.edge_percolation" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the size of the largest or second-largest component as edges are
(virtually) removed from the graph.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>g</strong> : <a class="reference internal" href="https://graph-tool.skewed.de/static/doc/graph_tool.html#graph_tool.Graph" title="graph_tool.Graph"><code class="xref py py-class docutils literal notranslate"><span class="pre">Graph</span></code></a></p>
<blockquote>
<div><p>Graph to be used.</p>
</div></blockquote>
<p><strong>edges</strong> : <a class="reference external" href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v1.14)"><code class="xref py py-class docutils literal notranslate"><span class="pre">numpy.ndarray</span></code></a> or iterable of pairs of ints</p>
<blockquote>
<div><p>List of edges in reversed order of removal. If the type is
<a class="reference external" href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v1.14)"><code class="xref py py-class docutils literal notranslate"><span class="pre">numpy.ndarray</span></code></a>, it should have a shape <code class="docutils literal notranslate"><span class="pre">(E,</span> <span class="pre">2)</span></code>, where <code class="docutils literal notranslate"><span class="pre">E</span></code>
is the number of edges, such that <code class="docutils literal notranslate"><span class="pre">edges[i,0]</span></code> and <code class="docutils literal notranslate"><span class="pre">edges[i,1]</span></code> are
the both endpoints of edge <code class="docutils literal notranslate"><span class="pre">i</span></code>.</p>
</div></blockquote>
<p><strong>second</strong> : bool (optional, default: <code class="docutils literal notranslate"><span class="pre">False</span></code>)</p>
<blockquote>
<div><p>If <code class="docutils literal notranslate"><span class="pre">True</span></code>, the size of the second-largest component will be computed.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>size</strong> : <a class="reference external" href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v1.14)"><code class="xref py py-class docutils literal notranslate"><span class="pre">numpy.ndarray</span></code></a></p>
<blockquote>
<div><p>Size of the largest (or second-largest) component prior to removal of
each edge.</p>
</div></blockquote>
<p><strong>comp</strong> : <a class="reference internal" href="https://graph-tool.skewed.de/static/doc/graph_tool.html#graph_tool.PropertyMap" title="graph_tool.PropertyMap"><code class="xref py py-class docutils literal notranslate"><span class="pre">PropertyMap</span></code></a></p>
<blockquote class="last">
<div><p>Vertex property map with component labels.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>The algorithm runs in <span class="math">\(O(E)\)</span> time.</p>
<p class="rubric">References</p>
<table class="docutils citation" frame="void" id="newman-ziff292" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="topology.html#id26">[newman-ziff292]</a></td><td>M. E. J. Newman, R. M. Ziff, “A fast Monte Carlo algorithm
for site or bond percolation”, Phys. Rev. E 64, 016706 (2001)
<a class="reference external" href="https://dx.doi.org/10.1103/PhysRevE.64.016706">DOI: 10.1103/PhysRevE.64.016706</a> [<a class="reference external" href="https://sci-hub.tw/10.1103/PhysRevE.64.016706">sci-hub</a>, <a class="reference external" href="https://scihub22266oqcxt.onion.link/10.1103/PhysRevE.64.016706">&#64;tor</a>], <a class="reference external" href="https://arxiv.org/abs/cond-mat/0101295">arXiv: cond-mat/0101295</a></td></tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">g</span> <span class="o">=</span> <span class="n">gt</span><span class="o">.</span><span class="n">random_graph</span><span class="p">(</span><span class="mi">10000</span><span class="p">,</span> <span class="k">lambda</span><span class="p">:</span> <span class="n">geometric</span><span class="p">(</span><span class="mf">1.</span><span class="o">/</span><span class="mi">4</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">directed</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">edges</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">([(</span><span class="n">e</span><span class="o">.</span><span class="n">source</span><span class="p">(),</span> <span class="n">e</span><span class="o">.</span><span class="n">target</span><span class="p">())</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">g</span><span class="o">.</span><span class="n">edges</span><span class="p">()],</span>
<span class="gp">... </span>               <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">e</span><span class="p">:</span> <span class="n">e</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">out_degree</span><span class="p">()</span> <span class="o">*</span> <span class="n">e</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">out_degree</span><span class="p">())</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sizes</span><span class="p">,</span> <span class="n">comp</span> <span class="o">=</span> <span class="n">gt</span><span class="o">.</span><span class="n">edge_percolation</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">edges</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">numpy</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">shuffle</span><span class="p">(</span><span class="n">edges</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sizes2</span><span class="p">,</span> <span class="n">comp</span> <span class="o">=</span> <span class="n">gt</span><span class="o">.</span><span class="n">edge_percolation</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">edges</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">figure</span><span class="p">()</span>
<span class="go">&lt;...&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plot</span><span class="p">(</span><span class="n">sizes</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s2">&quot;Targeted&quot;</span><span class="p">)</span>
<span class="go">[...]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plot</span><span class="p">(</span><span class="n">sizes2</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s2">&quot;Random&quot;</span><span class="p">)</span>
<span class="go">[...]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">xlabel</span><span class="p">(</span><span class="s2">&quot;Edges remaining&quot;</span><span class="p">)</span>
<span class="go">Text(...)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ylabel</span><span class="p">(</span><span class="s2">&quot;Size of largest component&quot;</span><span class="p">)</span>
<span class="go">Text(...)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">legend</span><span class="p">(</span><span class="n">loc</span><span class="o">=</span><span class="s2">&quot;lower right&quot;</span><span class="p">)</span>
<span class="go">&lt;...&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">savefig</span><span class="p">(</span><span class="s2">&quot;edge-percolation.svg&quot;</span><span class="p">)</span>
</pre></div>
</div>
<div class="figure align-center" id="id83">
<img alt="_images/edge-percolation.svg" src="../static/doc/_images/edge-percolation.svg" /><p class="caption"><span class="caption-text">Targeted and random edge percolation of a random graph with an
exponential degree distribution.</span></p>
</div>
</dd></dl>

<dl class="function">
<dt id="graph_tool.topology.kcore_decomposition">
<code class="descclassname">graph_tool.topology.</code><code class="descname">kcore_decomposition</code><span class="sig-paren">(</span><em>g</em>, <em>vprop=None</em><span class="sig-paren">)</span><a class="reference internal" href="../static/doc/_modules/graph_tool/topology.html#kcore_decomposition"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="topology.html#graph_tool.topology.kcore_decomposition" title="Permalink to this definition">¶</a></dt>
<dd><p>Perform a k-core decomposition of the given graph.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>g</strong> : <a class="reference internal" href="https://graph-tool.skewed.de/static/doc/graph_tool.html#graph_tool.Graph" title="graph_tool.Graph"><code class="xref py py-class docutils literal notranslate"><span class="pre">Graph</span></code></a></p>
<blockquote>
<div><p>Graph to be used.</p>
</div></blockquote>
<p><strong>vprop</strong> : <a class="reference internal" href="https://graph-tool.skewed.de/static/doc/graph_tool.html#graph_tool.PropertyMap" title="graph_tool.PropertyMap"><code class="xref py py-class docutils literal notranslate"><span class="pre">PropertyMap</span></code></a> (optional, default: <code class="docutils literal notranslate"><span class="pre">None</span></code>)</p>
<blockquote>
<div><p>Vertex property to store the decomposition. If <code class="docutils literal notranslate"><span class="pre">None</span></code> is supplied,
one is created.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>kval</strong> : <a class="reference internal" href="https://graph-tool.skewed.de/static/doc/graph_tool.html#graph_tool.PropertyMap" title="graph_tool.PropertyMap"><code class="xref py py-class docutils literal notranslate"><span class="pre">PropertyMap</span></code></a></p>
<blockquote class="last">
<div><p>Vertex property map with the k-core decomposition, i.e. a given vertex v
belongs to the <code class="docutils literal notranslate"><span class="pre">kval[v]</span></code>-core.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>The k-core is a maximal set of vertices such that its induced subgraph only
contains vertices with degree larger than or equal to k.</p>
<p>For directed graphs, the degree is assumed to be the total (in + out)
degree.</p>
<p>The algorithm accepts graphs with parallel edges and self loops, in which
case these edges contribute to the degree in the usual fashion.</p>
<p>This algorithm is described in <a class="reference internal" href="topology.html#batagelk-algorithm293" id="id27">[batagelk-algorithm293]</a> and runs in <span class="math">\(O(V + E)\)</span>
time.</p>
<p class="rubric">References</p>
<table class="docutils citation" frame="void" id="k-core293" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="topology.html#id28">[k-core293]</a></td><td><a class="reference external" href="http://en.wikipedia.org/wiki/Degeneracy_%28graph_theory%29">http://en.wikipedia.org/wiki/Degeneracy_%28graph_theory%29</a></td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="batagelk-algorithm293" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[batagelk-algorithm293]</td><td><em>(<a class="fn-backref" href="topology.html#id27">1</a>, <a class="fn-backref" href="topology.html#id29">2</a>)</em> Vladimir Batagelj, Matjaž Zaveršnik, “Fast
algorithms for determining (generalized) core groups in social
networks”, Advances in Data Analysis and Classification
Volume 5, Issue 2, pp 129-145 (2011), <a class="reference external" href="https://dx.doi.org/10.1007/s11634-010-0079-y">DOI: 10.1007/s11634-010-0079-y</a> [<a class="reference external" href="https://sci-hub.tw/10.1007/s11634-010-0079-y">sci-hub</a>, <a class="reference external" href="https://scihub22266oqcxt.onion.link/10.1007/s11634-010-0079-y">&#64;tor</a>],
<a class="reference external" href="https://arxiv.org/abs/cs/0310049">arXiv: cs/0310049</a></td></tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">g</span> <span class="o">=</span> <span class="n">gt</span><span class="o">.</span><span class="n">collection</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;netscience&quot;</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">g</span> <span class="o">=</span> <span class="n">gt</span><span class="o">.</span><span class="n">GraphView</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">vfilt</span><span class="o">=</span><span class="n">gt</span><span class="o">.</span><span class="n">label_largest_component</span><span class="p">(</span><span class="n">g</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">kcore</span> <span class="o">=</span> <span class="n">gt</span><span class="o">.</span><span class="n">kcore_decomposition</span><span class="p">(</span><span class="n">g</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">gt</span><span class="o">.</span><span class="n">graph_draw</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">pos</span><span class="o">=</span><span class="n">g</span><span class="o">.</span><span class="n">vp</span><span class="p">[</span><span class="s2">&quot;pos&quot;</span><span class="p">],</span> <span class="n">vertex_fill_color</span><span class="o">=</span><span class="n">kcore</span><span class="p">,</span> <span class="n">vertex_text</span><span class="o">=</span><span class="n">kcore</span><span class="p">,</span> <span class="n">output</span><span class="o">=</span><span class="s2">&quot;netsci-kcore.pdf&quot;</span><span class="p">)</span>
<span class="go">&lt;...&gt;</span>
</pre></div>
</div>
<div class="figure align-center" id="id84">
<img alt="_images/netsci-kcore.png" src="https://graph-tool.skewed.de/static/doc/_images/netsci-kcore.png" />
<p class="caption"><span class="caption-text">K-core decomposition of a network of network scientists.</span></p>
</div>
</dd></dl>

<dl class="function">
<dt id="graph_tool.topology.shortest_distance">
<code class="descclassname">graph_tool.topology.</code><code class="descname">shortest_distance</code><span class="sig-paren">(</span><em>g</em>, <em>source=None</em>, <em>target=None</em>, <em>weights=None</em>, <em>negative_weights=False</em>, <em>max_dist=None</em>, <em>directed=None</em>, <em>dense=False</em>, <em>dist_map=None</em>, <em>pred_map=False</em>, <em>return_reached=False</em><span class="sig-paren">)</span><a class="reference internal" href="../static/doc/_modules/graph_tool/topology.html#shortest_distance"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="topology.html#graph_tool.topology.shortest_distance" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the distance from a source to a target vertex, or to of all
vertices from a given source, or the all pairs shortest paths, if the source
is not specified.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>g</strong> : <a class="reference internal" href="https://graph-tool.skewed.de/static/doc/graph_tool.html#graph_tool.Graph" title="graph_tool.Graph"><code class="xref py py-class docutils literal notranslate"><span class="pre">Graph</span></code></a></p>
<blockquote>
<div><p>Graph to be used.</p>
</div></blockquote>
<p><strong>source</strong> : <a class="reference internal" href="https://graph-tool.skewed.de/static/doc/graph_tool.html#graph_tool.Vertex" title="graph_tool.Vertex"><code class="xref py py-class docutils literal notranslate"><span class="pre">Vertex</span></code></a> (optional, default: <code class="docutils literal notranslate"><span class="pre">None</span></code>)</p>
<blockquote>
<div><p>Source vertex of the search. If unspecified, the all pairs shortest
distances are computed.</p>
</div></blockquote>
<p><strong>target</strong> : <a class="reference internal" href="https://graph-tool.skewed.de/static/doc/graph_tool.html#graph_tool.Vertex" title="graph_tool.Vertex"><code class="xref py py-class docutils literal notranslate"><span class="pre">Vertex</span></code></a> or iterable of such objects (optional, default: <code class="docutils literal notranslate"><span class="pre">None</span></code>)</p>
<blockquote>
<div><p>Target vertex (or vertices) of the search. If unspecified, the distance
to all vertices from the source will be computed.</p>
</div></blockquote>
<p><strong>weights</strong> : <a class="reference internal" href="https://graph-tool.skewed.de/static/doc/graph_tool.html#graph_tool.PropertyMap" title="graph_tool.PropertyMap"><code class="xref py py-class docutils literal notranslate"><span class="pre">PropertyMap</span></code></a> (optional, default: <code class="docutils literal notranslate"><span class="pre">None</span></code>)</p>
<blockquote>
<div><p>The edge weights. If provided, the shortest path will correspond to the
minimal sum of weights.</p>
</div></blockquote>
<p><strong>negative_weights</strong> : <code class="docutils literal notranslate"><span class="pre">bool</span></code> (optional, default: <code class="docutils literal notranslate"><span class="pre">False</span></code>)</p>
<blockquote>
<div><p>If <cite>True</cite>, this will trigger the use of the Bellman-Ford algorithm.
Ignored if <code class="docutils literal notranslate"><span class="pre">source</span></code> is <code class="docutils literal notranslate"><span class="pre">None</span></code>.</p>
</div></blockquote>
<p><strong>max_dist</strong> : scalar value (optional, default: <code class="docutils literal notranslate"><span class="pre">None</span></code>)</p>
<blockquote>
<div><p>If specified, this limits the maximum distance of the vertices
searched. This parameter has no effect if source is <code class="docutils literal notranslate"><span class="pre">None</span></code>, or if
<cite>negative_weights=True</cite>.</p>
</div></blockquote>
<p><strong>directed</strong> : <code class="docutils literal notranslate"><span class="pre">bool</span></code> (optional, default:<code class="docutils literal notranslate"><span class="pre">None</span></code>)</p>
<blockquote>
<div><p>Treat graph as directed or not, independently of its actual
directionality.</p>
</div></blockquote>
<p><strong>dense</strong> : <code class="docutils literal notranslate"><span class="pre">bool</span></code> (optional, default: <code class="docutils literal notranslate"><span class="pre">False</span></code>)</p>
<blockquote>
<div><p>If <code class="docutils literal notranslate"><span class="pre">True</span></code>, and source is <code class="docutils literal notranslate"><span class="pre">None</span></code>, the Floyd-Warshall algorithm is used,
otherwise the Johnson algorithm is used. If source is not <code class="docutils literal notranslate"><span class="pre">None</span></code>, this option
has no effect.</p>
</div></blockquote>
<p><strong>dist_map</strong> : <a class="reference internal" href="https://graph-tool.skewed.de/static/doc/graph_tool.html#graph_tool.PropertyMap" title="graph_tool.PropertyMap"><code class="xref py py-class docutils literal notranslate"><span class="pre">PropertyMap</span></code></a> (optional, default: <code class="docutils literal notranslate"><span class="pre">None</span></code>)</p>
<blockquote>
<div><p>Vertex property to store the distances. If none is supplied, one
is created.</p>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p>If this parameter is supplied, the user is responsible for
initializing it to infinity. This can be done as:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">dist_map</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">new_vp</span><span class="p">(</span><span class="s2">&quot;double&quot;</span><span class="p">,</span> <span class="n">numpy</span><span class="o">.</span><span class="n">inf</span><span class="p">)</span>
</pre></div>
</div>
<p>or</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">dist_map</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">new_vp</span><span class="p">(</span><span class="s2">&quot;int32_t&quot;</span><span class="p">,</span> <span class="n">numpy</span><span class="o">.</span><span class="n">iinfo</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span><span class="o">.</span><span class="n">max</span><span class="p">)</span>
</pre></div>
</div>
<p class="last">depending on the distance type.</p>
</div>
</div></blockquote>
<p><strong>pred_map</strong> : <code class="docutils literal notranslate"><span class="pre">bool</span></code> or <a class="reference internal" href="https://graph-tool.skewed.de/static/doc/graph_tool.html#graph_tool.PropertyMap" title="graph_tool.PropertyMap"><code class="xref py py-class docutils literal notranslate"><span class="pre">PropertyMap</span></code></a> (optional, default: <code class="docutils literal notranslate"><span class="pre">False</span></code>)</p>
<blockquote>
<div><p>If <code class="docutils literal notranslate"><span class="pre">True</span></code>, a vertex property map with the predecessors is returned.
If a <a class="reference internal" href="https://graph-tool.skewed.de/static/doc/graph_tool.html#graph_tool.PropertyMap" title="graph_tool.PropertyMap"><code class="xref py py-class docutils literal notranslate"><span class="pre">PropertyMap</span></code></a> is passed, it must be of value
<code class="docutils literal notranslate"><span class="pre">int64_t</span></code> and it will be used to store the predecessors.  Ignored if
<code class="docutils literal notranslate"><span class="pre">source</span></code> is <code class="docutils literal notranslate"><span class="pre">None</span></code>.</p>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p>If a property map is supplied, the user is responsible for
initializing to the identity map. This can be done as:</p>
<div class="last highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">pred_map</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">vertex_index</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
</pre></div>
</div>
</div>
</div></blockquote>
<p><strong>return_reached</strong> : <code class="docutils literal notranslate"><span class="pre">bool</span></code> (optional, default: <code class="docutils literal notranslate"><span class="pre">False</span></code>)</p>
<blockquote>
<div><p>If <code class="docutils literal notranslate"><span class="pre">True</span></code>, return an array of visited vertices.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>dist_map</strong> : <a class="reference internal" href="https://graph-tool.skewed.de/static/doc/graph_tool.html#graph_tool.PropertyMap" title="graph_tool.PropertyMap"><code class="xref py py-class docutils literal notranslate"><span class="pre">PropertyMap</span></code></a> or <a class="reference external" href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v1.14)"><code class="xref py py-class docutils literal notranslate"><span class="pre">numpy.ndarray</span></code></a></p>
<blockquote>
<div><p>Vertex property map with the distances from source. If <code class="docutils literal notranslate"><span class="pre">source</span></code> is
<code class="docutils literal notranslate"><span class="pre">None</span></code>, it will have a vector value type, with the distances to every
vertex. If <code class="docutils literal notranslate"><span class="pre">target</span></code> is an iterable, instead of
<a class="reference internal" href="https://graph-tool.skewed.de/static/doc/graph_tool.html#graph_tool.PropertyMap" title="graph_tool.PropertyMap"><code class="xref py py-class docutils literal notranslate"><span class="pre">PropertyMap</span></code></a>, this will be of type
<a class="reference external" href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v1.14)"><code class="xref py py-class docutils literal notranslate"><span class="pre">numpy.ndarray</span></code></a>, and contain only the distances to those specific
targets.</p>
</div></blockquote>
<p><strong>pred_map</strong> : <a class="reference internal" href="https://graph-tool.skewed.de/static/doc/graph_tool.html#graph_tool.PropertyMap" title="graph_tool.PropertyMap"><code class="xref py py-class docutils literal notranslate"><span class="pre">PropertyMap</span></code></a> (optional, if <code class="docutils literal notranslate"><span class="pre">pred_map</span> <span class="pre">==</span> <span class="pre">True</span></code>)</p>
<blockquote>
<div><p>Vertex property map with the predecessors in the search tree.</p>
</div></blockquote>
<p><strong>pred_map</strong> : <a class="reference external" href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v1.14)"><code class="xref py py-class docutils literal notranslate"><span class="pre">numpy.ndarray</span></code></a> (optional, if <code class="docutils literal notranslate"><span class="pre">return_reached</span> <span class="pre">==</span> <span class="pre">True</span></code>)</p>
<blockquote class="last">
<div><p>Array containing vertices visited during the search.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>If a source is given, the distances are calculated with a breadth-first
search (BFS) or Dijkstra’s algorithm <a class="reference internal" href="topology.html#dijkstra295" id="id30">[dijkstra295]</a>, if weights are given. If
<code class="docutils literal notranslate"><span class="pre">negative_weights</span> <span class="pre">==</span> <span class="pre">True</span></code>, the Bellman-Ford algorithm is used
<a class="reference internal" href="topology.html#bellman-ford295" id="id31">[bellman-ford295]</a>, which accepts negative weights, as long as there are no
negative loops. If source is not given, the distances are calculated with
Johnson’s algorithm <a class="reference internal" href="topology.html#johnson-apsp295" id="id32">[johnson-apsp295]</a>. If dense=True, the Floyd-Warshall
algorithm <a class="reference internal" href="topology.html#floyd-warshall-apsp295" id="id33">[floyd-warshall-apsp295]</a> is used instead.</p>
<p>If there is no path between two vertices, the computed distance will
correspond to the maximum value allowed by the value type of <code class="docutils literal notranslate"><span class="pre">dist_map</span></code>,
or <code class="docutils literal notranslate"><span class="pre">inf</span></code> in case of floating point types.</p>
<p>If source is specified, the algorithm runs in <span class="math">\(O(V + E)\)</span> time, or
<span class="math">\(O(V \log V)\)</span> if weights are given. If <code class="docutils literal notranslate"><span class="pre">negative_weights</span> <span class="pre">==</span> <span class="pre">True</span></code>,
the complexity is <span class="math">\(O(VE)\)</span>. If source is not specified, it runs in
<span class="math">\(O(VE\log V)\)</span> time, or <span class="math">\(O(V^3)\)</span> if dense == True.</p>
<p class="rubric">References</p>
<table class="docutils citation" frame="void" id="bfs295" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="topology.html#id34">[bfs295]</a></td><td>Edward Moore, “The shortest path through a maze”, International
Symposium on the Theory of Switching (1959), Harvard University Press.</td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="bfs-boost295" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="topology.html#id35">[bfs-boost295]</a></td><td><a class="reference external" href="http://www.boost.org/libs/graph/doc/breadth_first_search.html">http://www.boost.org/libs/graph/doc/breadth_first_search.html</a></td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="dijkstra295" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[dijkstra295]</td><td><em>(<a class="fn-backref" href="topology.html#id30">1</a>, <a class="fn-backref" href="topology.html#id36">2</a>)</em> E. Dijkstra, “A note on two problems in connexion with
graphs.” Numerische Mathematik, 1:269-271, 1959.</td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="dijkstra-boost295" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="topology.html#id37">[dijkstra-boost295]</a></td><td><a class="reference external" href="http://www.boost.org/libs/graph/doc/dijkstra_shortest_paths.html">http://www.boost.org/libs/graph/doc/dijkstra_shortest_paths.html</a></td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="johnson-apsp295" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[johnson-apsp295]</td><td><em>(<a class="fn-backref" href="topology.html#id32">1</a>, <a class="fn-backref" href="topology.html#id38">2</a>)</em> <a class="reference external" href="http://www.boost.org/libs/graph/doc/johnson_all_pairs_shortest.html">http://www.boost.org/libs/graph/doc/johnson_all_pairs_shortest.html</a></td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="floyd-warshall-apsp295" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[floyd-warshall-apsp295]</td><td><em>(<a class="fn-backref" href="topology.html#id33">1</a>, <a class="fn-backref" href="topology.html#id39">2</a>)</em> <a class="reference external" href="http://www.boost.org/libs/graph/doc/floyd_warshall_shortest.html">http://www.boost.org/libs/graph/doc/floyd_warshall_shortest.html</a></td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="bellman-ford295" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[bellman-ford295]</td><td><em>(<a class="fn-backref" href="topology.html#id31">1</a>, <a class="fn-backref" href="topology.html#id40">2</a>)</em> <a class="reference external" href="http://www.boost.org/libs/graph/doc/bellman_ford_shortest.html">http://www.boost.org/libs/graph/doc/bellman_ford_shortest.html</a></td></tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">numpy.random</span> <span class="k">import</span> <span class="n">poisson</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">g</span> <span class="o">=</span> <span class="n">gt</span><span class="o">.</span><span class="n">random_graph</span><span class="p">(</span><span class="mi">100</span><span class="p">,</span> <span class="k">lambda</span><span class="p">:</span> <span class="p">(</span><span class="n">poisson</span><span class="p">(</span><span class="mi">3</span><span class="p">),</span> <span class="n">poisson</span><span class="p">(</span><span class="mi">3</span><span class="p">)))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dist</span> <span class="o">=</span> <span class="n">gt</span><span class="o">.</span><span class="n">shortest_distance</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">source</span><span class="o">=</span><span class="n">g</span><span class="o">.</span><span class="n">vertex</span><span class="p">(</span><span class="mi">0</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">dist</span><span class="o">.</span><span class="n">a</span><span class="p">)</span>
<span class="go">[         0          4          5          6 2147483647          5</span>
<span class="go">          4          3 2147483647          4          4          6</span>
<span class="go">          6          5          5          4          4          2</span>
<span class="go">          5          1 2147483647          6          5          5</span>
<span class="go">          5          7          5          4          6          5</span>
<span class="go">          5          4          1          4          4          3</span>
<span class="go">          5 2147483647          5          1 2147483647          2</span>
<span class="go">          2          7          4          5          5          5</span>
<span class="go">          6          5          5          3          2          7</span>
<span class="go">          5          4          3          5          4          6</span>
<span class="go">          3          5          5          3          4          4</span>
<span class="go">          6          4          4          5 2147483647 2147483647</span>
<span class="go">          2          5          7          3 2147483647 2147483647</span>
<span class="go">          5          6          4          7          4          4</span>
<span class="go">          3          4          6          4          3 2147483647</span>
<span class="go">          5          6          3          4          6          5</span>
<span class="go">          5          3          4          5]</span>
<span class="go">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dist</span> <span class="o">=</span> <span class="n">gt</span><span class="o">.</span><span class="n">shortest_distance</span><span class="p">(</span><span class="n">g</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">dist</span><span class="p">[</span><span class="n">g</span><span class="o">.</span><span class="n">vertex</span><span class="p">(</span><span class="mi">0</span><span class="p">)]</span><span class="o">.</span><span class="n">a</span><span class="p">)</span>
<span class="go">[         0          4          5          6 2147483647          5</span>
<span class="go">          4          3 2147483647          4          4          6</span>
<span class="go">          6          5          5          4          4          2</span>
<span class="go">          5          1 2147483647          6          5          5</span>
<span class="go">          5          7          5          4          6          5</span>
<span class="go">          5          4          1          4          4          3</span>
<span class="go">          5 2147483647          5          1 2147483647          2</span>
<span class="go">          2          7          4          5          5          5</span>
<span class="go">          6          5          5          3          2          7</span>
<span class="go">          5          4          3          5          4          6</span>
<span class="go">          3          5          5          3          4          4</span>
<span class="go">          6          4          4          5 2147483647 2147483647</span>
<span class="go">          2          5          7          3 2147483647 2147483647</span>
<span class="go">          5          6          4          7          4          4</span>
<span class="go">          3          4          6          4          3 2147483647</span>
<span class="go">          5          6          3          4          6          5</span>
<span class="go">          5          3          4          5]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dist</span> <span class="o">=</span> <span class="n">gt</span><span class="o">.</span><span class="n">shortest_distance</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">source</span><span class="o">=</span><span class="n">g</span><span class="o">.</span><span class="n">vertex</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="n">target</span><span class="o">=</span><span class="n">g</span><span class="o">.</span><span class="n">vertex</span><span class="p">(</span><span class="mi">2</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">dist</span><span class="p">)</span>
<span class="go">5</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dist</span> <span class="o">=</span> <span class="n">gt</span><span class="o">.</span><span class="n">shortest_distance</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">source</span><span class="o">=</span><span class="n">g</span><span class="o">.</span><span class="n">vertex</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="n">target</span><span class="o">=</span><span class="p">[</span><span class="n">g</span><span class="o">.</span><span class="n">vertex</span><span class="p">(</span><span class="mi">2</span><span class="p">),</span> <span class="n">g</span><span class="o">.</span><span class="n">vertex</span><span class="p">(</span><span class="mi">6</span><span class="p">)])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">dist</span><span class="p">)</span>
<span class="go">[5 4]</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="graph_tool.topology.shortest_path">
<code class="descclassname">graph_tool.topology.</code><code class="descname">shortest_path</code><span class="sig-paren">(</span><em>g</em>, <em>source</em>, <em>target</em>, <em>weights=None</em>, <em>negative_weights=False</em>, <em>pred_map=None</em><span class="sig-paren">)</span><a class="reference internal" href="../static/doc/_modules/graph_tool/topology.html#shortest_path"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="topology.html#graph_tool.topology.shortest_path" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the shortest path from <code class="docutils literal notranslate"><span class="pre">source</span></code> to <code class="docutils literal notranslate"><span class="pre">target</span></code>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>g</strong> : <a class="reference internal" href="https://graph-tool.skewed.de/static/doc/graph_tool.html#graph_tool.Graph" title="graph_tool.Graph"><code class="xref py py-class docutils literal notranslate"><span class="pre">Graph</span></code></a></p>
<blockquote>
<div><p>Graph to be used.</p>
</div></blockquote>
<p><strong>source</strong> : <a class="reference internal" href="https://graph-tool.skewed.de/static/doc/graph_tool.html#graph_tool.Vertex" title="graph_tool.Vertex"><code class="xref py py-class docutils literal notranslate"><span class="pre">Vertex</span></code></a></p>
<blockquote>
<div><p>Source vertex of the search.</p>
</div></blockquote>
<p><strong>target</strong> : <a class="reference internal" href="https://graph-tool.skewed.de/static/doc/graph_tool.html#graph_tool.Vertex" title="graph_tool.Vertex"><code class="xref py py-class docutils literal notranslate"><span class="pre">Vertex</span></code></a></p>
<blockquote>
<div><p>Target vertex of the search.</p>
</div></blockquote>
<p><strong>weights</strong> : <a class="reference internal" href="https://graph-tool.skewed.de/static/doc/graph_tool.html#graph_tool.PropertyMap" title="graph_tool.PropertyMap"><code class="xref py py-class docutils literal notranslate"><span class="pre">PropertyMap</span></code></a> (optional, default: None)</p>
<blockquote>
<div><p>The edge weights.</p>
</div></blockquote>
<p><strong>negative_weights</strong> : <code class="docutils literal notranslate"><span class="pre">bool</span></code> (optional, default: <code class="docutils literal notranslate"><span class="pre">False</span></code>)</p>
<blockquote>
<div><p>If <code class="docutils literal notranslate"><span class="pre">True</span></code>, this will trigger the use of the Bellman-Ford algorithm.</p>
</div></blockquote>
<p><strong>pred_map</strong> :  <a class="reference internal" href="https://graph-tool.skewed.de/static/doc/graph_tool.html#graph_tool.PropertyMap" title="graph_tool.PropertyMap"><code class="xref py py-class docutils literal notranslate"><span class="pre">PropertyMap</span></code></a> (optional, default: None)</p>
<blockquote>
<div><p>Vertex property map with the predecessors in the search tree. If this is
provided, the shortest paths are not computed, and are obtained directly
from this map.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>vertex_list</strong> : list of <a class="reference internal" href="https://graph-tool.skewed.de/static/doc/graph_tool.html#graph_tool.Vertex" title="graph_tool.Vertex"><code class="xref py py-class docutils literal notranslate"><span class="pre">Vertex</span></code></a></p>
<blockquote>
<div><p>List of vertices from <cite>source</cite> to <cite>target</cite> in the shortest path.</p>
</div></blockquote>
<p><strong>edge_list</strong> : list of <a class="reference internal" href="https://graph-tool.skewed.de/static/doc/graph_tool.html#graph_tool.Edge" title="graph_tool.Edge"><code class="xref py py-class docutils literal notranslate"><span class="pre">Edge</span></code></a></p>
<blockquote class="last">
<div><p>List of edges from <cite>source</cite> to <cite>target</cite> in the shortest path.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>The paths are computed with a breadth-first search (BFS) or Dijkstra’s
algorithm <a class="reference internal" href="topology.html#dijkstra302" id="id41">[dijkstra302]</a>, if weights are given. If <code class="docutils literal notranslate"><span class="pre">negative_weights</span> <span class="pre">==</span>
<span class="pre">True</span></code>, the Bellman-Ford algorithm is used <a class="reference internal" href="topology.html#bellman-ford302" id="id42">[bellman-ford302]</a>, which accepts
negative weights, as long as there are no negative loops.</p>
<p>The algorithm runs in <span class="math">\(O(V + E)\)</span> time, or <span class="math">\(O(V \log V)\)</span> if
weights are given.</p>
<p class="rubric">References</p>
<table class="docutils citation" frame="void" id="bfs302" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="topology.html#id43">[bfs302]</a></td><td>Edward Moore, “The shortest path through a maze”, International
Symposium on the Theory of Switching (1959), Harvard University
Press</td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="bfs-boost302" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="topology.html#id44">[bfs-boost302]</a></td><td><a class="reference external" href="http://www.boost.org/libs/graph/doc/breadth_first_search.html">http://www.boost.org/libs/graph/doc/breadth_first_search.html</a></td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="dijkstra302" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[dijkstra302]</td><td><em>(<a class="fn-backref" href="topology.html#id41">1</a>, <a class="fn-backref" href="topology.html#id45">2</a>)</em> E. Dijkstra, “A note on two problems in connexion with
graphs.” Numerische Mathematik, 1:269-271, 1959.</td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="dijkstra-boost302" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="topology.html#id46">[dijkstra-boost302]</a></td><td><a class="reference external" href="http://www.boost.org/libs/graph/doc/dijkstra_shortest_paths.html">http://www.boost.org/libs/graph/doc/dijkstra_shortest_paths.html</a></td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="bellman-ford302" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[bellman-ford302]</td><td><em>(<a class="fn-backref" href="topology.html#id42">1</a>, <a class="fn-backref" href="topology.html#id47">2</a>)</em> <a class="reference external" href="http://www.boost.org/libs/graph/doc/bellman_ford_shortest.html">http://www.boost.org/libs/graph/doc/bellman_ford_shortest.html</a></td></tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">numpy.random</span> <span class="k">import</span> <span class="n">poisson</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">g</span> <span class="o">=</span> <span class="n">gt</span><span class="o">.</span><span class="n">random_graph</span><span class="p">(</span><span class="mi">300</span><span class="p">,</span> <span class="k">lambda</span><span class="p">:</span> <span class="p">(</span><span class="n">poisson</span><span class="p">(</span><span class="mi">4</span><span class="p">),</span> <span class="n">poisson</span><span class="p">(</span><span class="mi">4</span><span class="p">)))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">vlist</span><span class="p">,</span> <span class="n">elist</span> <span class="o">=</span> <span class="n">gt</span><span class="o">.</span><span class="n">shortest_path</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">g</span><span class="o">.</span><span class="n">vertex</span><span class="p">(</span><span class="mi">10</span><span class="p">),</span> <span class="n">g</span><span class="o">.</span><span class="n">vertex</span><span class="p">(</span><span class="mi">11</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">([</span><span class="nb">str</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">vlist</span><span class="p">])</span>
<span class="go">[&#39;10&#39;, &#39;131&#39;, &#39;118&#39;, &#39;207&#39;, &#39;195&#39;, &#39;11&#39;]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">([</span><span class="nb">str</span><span class="p">(</span><span class="n">e</span><span class="p">)</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">elist</span><span class="p">])</span>
<span class="go">[&#39;(10, 131)&#39;, &#39;(131, 118)&#39;, &#39;(118, 207)&#39;, &#39;(207, 195)&#39;, &#39;(195, 11)&#39;]</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="graph_tool.topology.all_predecessors">
<code class="descclassname">graph_tool.topology.</code><code class="descname">all_predecessors</code><span class="sig-paren">(</span><em>g</em>, <em>dist_map</em>, <em>pred_map</em>, <em>weights=None</em>, <em>epsilon=1e-08</em><span class="sig-paren">)</span><a class="reference internal" href="../static/doc/_modules/graph_tool/topology.html#all_predecessors"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="topology.html#graph_tool.topology.all_predecessors" title="Permalink to this definition">¶</a></dt>
<dd><dl class="docutils">
<dt>Return a property map with all possible predecessors in the search tree</dt>
<dd>determined by <code class="docutils literal notranslate"><span class="pre">dist_map</span></code> and <code class="docutils literal notranslate"><span class="pre">pred_map</span></code>.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>g</strong> : <a class="reference internal" href="https://graph-tool.skewed.de/static/doc/graph_tool.html#graph_tool.Graph" title="graph_tool.Graph"><code class="xref py py-class docutils literal notranslate"><span class="pre">Graph</span></code></a></p>
<blockquote>
<div><p>Graph to be used.</p>
</div></blockquote>
<p><strong>dist_map</strong> : <a class="reference internal" href="https://graph-tool.skewed.de/static/doc/graph_tool.html#graph_tool.PropertyMap" title="graph_tool.PropertyMap"><code class="xref py py-class docutils literal notranslate"><span class="pre">PropertyMap</span></code></a></p>
<blockquote>
<div><p>Vertex property map with the distances from <code class="docutils literal notranslate"><span class="pre">source</span></code> to all other
vertices.</p>
</div></blockquote>
<p><strong>pred_map</strong> : <a class="reference internal" href="https://graph-tool.skewed.de/static/doc/graph_tool.html#graph_tool.PropertyMap" title="graph_tool.PropertyMap"><code class="xref py py-class docutils literal notranslate"><span class="pre">PropertyMap</span></code></a> (optional, default: None)</p>
<blockquote>
<div><p>Vertex property map with the predecessors in the search tree.</p>
</div></blockquote>
<p><strong>weights</strong> : <a class="reference internal" href="https://graph-tool.skewed.de/static/doc/graph_tool.html#graph_tool.PropertyMap" title="graph_tool.PropertyMap"><code class="xref py py-class docutils literal notranslate"><span class="pre">PropertyMap</span></code></a> (optional, default: None)</p>
<blockquote>
<div><p>The edge weights.</p>
</div></blockquote>
<p><strong>epsilon</strong> : <cite>float</cite> (optional, default: <cite>1e-8</cite>)</p>
<blockquote>
<div><p>Maximum relative difference between distances to be considered “equal”,
in case floating-point weights are used.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>all_preds_map</strong> : <a class="reference internal" href="https://graph-tool.skewed.de/static/doc/graph_tool.html#graph_tool.PropertyMap" title="graph_tool.PropertyMap"><code class="xref py py-class docutils literal notranslate"><span class="pre">PropertyMap</span></code></a></p>
<blockquote class="last">
<div><p>Vector-valued vertex property map with all possible predecessors in the
search tree.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="graph_tool.topology.all_shortest_paths">
<code class="descclassname">graph_tool.topology.</code><code class="descname">all_shortest_paths</code><span class="sig-paren">(</span><em>g</em>, <em>source</em>, <em>target</em>, <em>weights=None</em>, <em>negative_weights=False</em>, <em>dist_map=None</em>, <em>pred_map=None</em>, <em>all_preds_map=None</em>, <em>epsilon=1e-08</em><span class="sig-paren">)</span><a class="reference internal" href="../static/doc/_modules/graph_tool/topology.html#all_shortest_paths"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="topology.html#graph_tool.topology.all_shortest_paths" title="Permalink to this definition">¶</a></dt>
<dd><p>Return an iterator over all shortest paths from <cite>source</cite> to <cite>target</cite>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>g</strong> : <a class="reference internal" href="https://graph-tool.skewed.de/static/doc/graph_tool.html#graph_tool.Graph" title="graph_tool.Graph"><code class="xref py py-class docutils literal notranslate"><span class="pre">Graph</span></code></a></p>
<blockquote>
<div><p>Graph to be used.</p>
</div></blockquote>
<p><strong>source</strong> : <a class="reference internal" href="https://graph-tool.skewed.de/static/doc/graph_tool.html#graph_tool.Vertex" title="graph_tool.Vertex"><code class="xref py py-class docutils literal notranslate"><span class="pre">Vertex</span></code></a></p>
<blockquote>
<div><p>Source vertex of the search.</p>
</div></blockquote>
<p><strong>target</strong> : <a class="reference internal" href="https://graph-tool.skewed.de/static/doc/graph_tool.html#graph_tool.Vertex" title="graph_tool.Vertex"><code class="xref py py-class docutils literal notranslate"><span class="pre">Vertex</span></code></a></p>
<blockquote>
<div><p>Target vertex of the search.</p>
</div></blockquote>
<p><strong>weights</strong> : <a class="reference internal" href="https://graph-tool.skewed.de/static/doc/graph_tool.html#graph_tool.PropertyMap" title="graph_tool.PropertyMap"><code class="xref py py-class docutils literal notranslate"><span class="pre">PropertyMap</span></code></a> (optional, default: None)</p>
<blockquote>
<div><p>The edge weights.</p>
</div></blockquote>
<p><strong>negative_weights</strong> : <code class="docutils literal notranslate"><span class="pre">bool</span></code> (optional, default: <code class="docutils literal notranslate"><span class="pre">False</span></code>)</p>
<blockquote>
<div><p>If <code class="docutils literal notranslate"><span class="pre">True</span></code>, this will trigger the use of the Bellman-Ford algorithm.</p>
</div></blockquote>
<p><strong>dist_map</strong> : <a class="reference internal" href="https://graph-tool.skewed.de/static/doc/graph_tool.html#graph_tool.PropertyMap" title="graph_tool.PropertyMap"><code class="xref py py-class docutils literal notranslate"><span class="pre">PropertyMap</span></code></a> (optional, default: None)</p>
<blockquote>
<div><p>Vertex property map with the distances from <code class="docutils literal notranslate"><span class="pre">source</span></code> to all other
vertices.</p>
</div></blockquote>
<p><strong>pred_map</strong> : <a class="reference internal" href="https://graph-tool.skewed.de/static/doc/graph_tool.html#graph_tool.PropertyMap" title="graph_tool.PropertyMap"><code class="xref py py-class docutils literal notranslate"><span class="pre">PropertyMap</span></code></a> (optional, default: None)</p>
<blockquote>
<div><p>Vertex property map with the predecessors in the search tree. If this is
provided, the shortest paths are not computed, and are obtained directly
from this map.</p>
</div></blockquote>
<p><strong>all_preds_map</strong> : <a class="reference internal" href="https://graph-tool.skewed.de/static/doc/graph_tool.html#graph_tool.PropertyMap" title="graph_tool.PropertyMap"><code class="xref py py-class docutils literal notranslate"><span class="pre">PropertyMap</span></code></a> (optional, default: None)</p>
<blockquote>
<div><p>Vector-valued vertex property map with all possible predecessors in the
search tree. If this is provided, the shortest paths are obtained
directly from this map.</p>
</div></blockquote>
<p><strong>epsilon</strong> : <cite>float</cite> (optional, default: <cite>1e-8</cite>)</p>
<blockquote>
<div><p>Maximum relative difference between distances to be considered “equal”,
in case floating-point weights are used.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>path_iterator</strong> : iterator over a sequence of integers</p>
<blockquote class="last">
<div><p>Iterator over sequences of vertices from <cite>source</cite> to <cite>target</cite> in the
shortest path.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>The paths are computed with a breadth-first search (BFS) or Dijkstra’s
algorithm <a class="reference internal" href="topology.html#dijkstra307" id="id48">[dijkstra307]</a>, if weights are given. If <code class="docutils literal notranslate"><span class="pre">negative_weights</span> <span class="pre">==</span>
<span class="pre">True</span></code>, the Bellman-Ford algorithm is used <a class="reference internal" href="topology.html#bellman-ford307" id="id49">[bellman-ford307]</a>, which accepts
negative weights, as long as there are no negative loops.</p>
<p>If both <code class="docutils literal notranslate"><span class="pre">dist_map</span></code> and <code class="docutils literal notranslate"><span class="pre">pred_map</span></code> are provided, the search is not
actually performed.</p>
<p class="rubric">References</p>
<table class="docutils citation" frame="void" id="bfs307" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="topology.html#id50">[bfs307]</a></td><td>Edward Moore, “The shortest path through a maze”, International
Symposium on the Theory of Switching (1959), Harvard University
Press</td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="bfs-boost307" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="topology.html#id51">[bfs-boost307]</a></td><td><a class="reference external" href="http://www.boost.org/libs/graph/doc/breadth_first_search.html">http://www.boost.org/libs/graph/doc/breadth_first_search.html</a></td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="dijkstra307" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[dijkstra307]</td><td><em>(<a class="fn-backref" href="topology.html#id48">1</a>, <a class="fn-backref" href="topology.html#id52">2</a>)</em> E. Dijkstra, “A note on two problems in connexion with
graphs.” Numerische Mathematik, 1:269-271, 1959.</td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="dijkstra-boost307" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="topology.html#id53">[dijkstra-boost307]</a></td><td><a class="reference external" href="http://www.boost.org/libs/graph/doc/dijkstra_shortest_paths.html">http://www.boost.org/libs/graph/doc/dijkstra_shortest_paths.html</a></td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="bellman-ford307" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[bellman-ford307]</td><td><em>(<a class="fn-backref" href="topology.html#id49">1</a>, <a class="fn-backref" href="topology.html#id54">2</a>)</em> <a class="reference external" href="http://www.boost.org/libs/graph/doc/bellman_ford_shortest.html">http://www.boost.org/libs/graph/doc/bellman_ford_shortest.html</a></td></tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">g</span> <span class="o">=</span> <span class="n">gt</span><span class="o">.</span><span class="n">collection</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;pgp-strong-2009&quot;</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">path</span> <span class="ow">in</span> <span class="n">gt</span><span class="o">.</span><span class="n">all_shortest_paths</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="mi">92</span><span class="p">,</span> <span class="mi">45</span><span class="p">):</span>
<span class="gp">... </span>    <span class="nb">print</span><span class="p">(</span><span class="n">path</span><span class="p">)</span>
<span class="go">[  92  107 2176 7027   26   21   45]</span>
<span class="go">[  92  107 2176 7033   26   21   45]</span>
<span class="go">[  92   82   94 5877 5879   34   45]</span>
<span class="go">[  92   89   94 5877 5879   34   45]</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="graph_tool.topology.all_paths">
<code class="descclassname">graph_tool.topology.</code><code class="descname">all_paths</code><span class="sig-paren">(</span><em>g</em>, <em>source</em>, <em>target</em>, <em>cutoff=None</em><span class="sig-paren">)</span><a class="reference internal" href="../static/doc/_modules/graph_tool/topology.html#all_paths"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="topology.html#graph_tool.topology.all_paths" title="Permalink to this definition">¶</a></dt>
<dd><p>Return an iterator over all paths from <cite>source</cite> to <cite>target</cite>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>g</strong> : <a class="reference internal" href="https://graph-tool.skewed.de/static/doc/graph_tool.html#graph_tool.Graph" title="graph_tool.Graph"><code class="xref py py-class docutils literal notranslate"><span class="pre">Graph</span></code></a></p>
<blockquote>
<div><p>Graph to be used.</p>
</div></blockquote>
<p><strong>source</strong> : <a class="reference internal" href="https://graph-tool.skewed.de/static/doc/graph_tool.html#graph_tool.Vertex" title="graph_tool.Vertex"><code class="xref py py-class docutils literal notranslate"><span class="pre">Vertex</span></code></a></p>
<blockquote>
<div><p>Source vertex of the search.</p>
</div></blockquote>
<p><strong>target</strong> : <a class="reference internal" href="https://graph-tool.skewed.de/static/doc/graph_tool.html#graph_tool.Vertex" title="graph_tool.Vertex"><code class="xref py py-class docutils literal notranslate"><span class="pre">Vertex</span></code></a></p>
<blockquote>
<div><p>Target vertex of the search.</p>
</div></blockquote>
<p><strong>cutoff</strong> : <cite>int</cite> (optional, default: None)</p>
<blockquote>
<div><p>Maximum path length.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>path_iterator</strong> : iterator over a sequence of integers</p>
<blockquote class="last">
<div><p>Iterator over sequences of vertices from <cite>source</cite> to <cite>target</cite> in the
path.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>The algorithm uses a depth-first search to find all the paths.</p>
<p>The total number of paths between any two vertices can be quite large,
possibly scaling as <span class="math">\(O(V!)\)</span>.</p>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">g</span> <span class="o">=</span> <span class="n">gt</span><span class="o">.</span><span class="n">collection</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;football&quot;</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">path</span> <span class="ow">in</span> <span class="n">gt</span><span class="o">.</span><span class="n">all_paths</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="mi">13</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">cutoff</span><span class="o">=</span><span class="mi">2</span><span class="p">):</span>
<span class="gp">... </span>    <span class="nb">print</span><span class="p">(</span><span class="n">path</span><span class="p">)</span>
<span class="go">[13  2]</span>
<span class="go">[13 15  2]</span>
<span class="go">[13 60  2]</span>
<span class="go">[13 64  2]</span>
<span class="go">[ 13 100   2]</span>
<span class="go">[ 13 106   2]</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="graph_tool.topology.all_circuits">
<code class="descclassname">graph_tool.topology.</code><code class="descname">all_circuits</code><span class="sig-paren">(</span><em>g</em>, <em>unique=False</em><span class="sig-paren">)</span><a class="reference internal" href="../static/doc/_modules/graph_tool/topology.html#all_circuits"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="topology.html#graph_tool.topology.all_circuits" title="Permalink to this definition">¶</a></dt>
<dd><p>Return an iterator over all the cycles in a directed graph.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>g</strong> : <a class="reference internal" href="https://graph-tool.skewed.de/static/doc/graph_tool.html#graph_tool.Graph" title="graph_tool.Graph"><code class="xref py py-class docutils literal notranslate"><span class="pre">Graph</span></code></a></p>
<blockquote>
<div><p>A directed graph to be used.</p>
</div></blockquote>
<p><strong>unique</strong> : <code class="docutils literal notranslate"><span class="pre">bool</span></code> (optional, default: None)</p>
<blockquote>
<div><p>If <code class="docutils literal notranslate"><span class="pre">True</span></code>, parallel edges and self-loops will be ignored.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>cycle_iterator</strong> : iterator over a sequence of integers</p>
<blockquote class="last">
<div><p>Iterator over sequences of vertices that form a circuit.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>This algorithm <a class="reference internal" href="topology.html#hawick-enumerating-2008312" id="id55">[hawick-enumerating-2008312]</a> runs in worse time
<span class="math">\(O[(V + E)(C + 1)]\)</span>, where <span class="math">\(C\)</span> is the number of circuits.</p>
<p class="rubric">References</p>
<table class="docutils citation" frame="void" id="hawick-enumerating-2008312" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[hawick-enumerating-2008312]</td><td><em>(<a class="fn-backref" href="topology.html#id55">1</a>, <a class="fn-backref" href="topology.html#id56">2</a>)</em> K.A. Hawick and H.A. James, “Enumerating
Circuits and Loops in Graphs with Self-Arcs and Multiple-Arcs.”,
In Proceedings of FCS. 2008, 14-20,
<a class="reference external" href="http://cssg.massey.ac.nz/cstn/013/cstn-013.html">http://cssg.massey.ac.nz/cstn/013/cstn-013.html</a></td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="hawick-bgl312" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="topology.html#id57">[hawick-bgl312]</a></td><td><a class="reference external" href="http://www.boost.org/doc/libs/graph/doc/hawick_circuits.html">http://www.boost.org/doc/libs/graph/doc/hawick_circuits.html</a></td></tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">g</span> <span class="o">=</span> <span class="n">gt</span><span class="o">.</span><span class="n">random_graph</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="k">lambda</span><span class="p">:</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">gt</span><span class="o">.</span><span class="n">all_circuits</span><span class="p">(</span><span class="n">g</span><span class="p">):</span>
<span class="gp">... </span>    <span class="nb">print</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>
<span class="go">[0 4 7 1 8 2]</span>
<span class="go">[3 9 6 5]</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="graph_tool.topology.pseudo_diameter">
<code class="descclassname">graph_tool.topology.</code><code class="descname">pseudo_diameter</code><span class="sig-paren">(</span><em>g</em>, <em>source=None</em>, <em>weights=None</em><span class="sig-paren">)</span><a class="reference internal" href="../static/doc/_modules/graph_tool/topology.html#pseudo_diameter"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="topology.html#graph_tool.topology.pseudo_diameter" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the pseudo-diameter of the graph.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>g</strong> : <a class="reference internal" href="https://graph-tool.skewed.de/static/doc/graph_tool.html#graph_tool.Graph" title="graph_tool.Graph"><code class="xref py py-class docutils literal notranslate"><span class="pre">Graph</span></code></a></p>
<blockquote>
<div><p>Graph to be used.</p>
</div></blockquote>
<p><strong>source</strong> : <a class="reference internal" href="https://graph-tool.skewed.de/static/doc/graph_tool.html#graph_tool.Vertex" title="graph_tool.Vertex"><code class="xref py py-class docutils literal notranslate"><span class="pre">Vertex</span></code></a> (optional, default: <cite>None</cite>)</p>
<blockquote>
<div><p>Source vertex of the search. If not supplied, the first vertex
in the graph will be chosen.</p>
</div></blockquote>
<p><strong>weights</strong> : <a class="reference internal" href="https://graph-tool.skewed.de/static/doc/graph_tool.html#graph_tool.PropertyMap" title="graph_tool.PropertyMap"><code class="xref py py-class docutils literal notranslate"><span class="pre">PropertyMap</span></code></a> (optional, default: <cite>None</cite>)</p>
<blockquote>
<div><p>The edge weights.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>pseudo_diameter</strong> : int</p>
<blockquote>
<div><p>The pseudo-diameter of the graph.</p>
</div></blockquote>
<p><strong>end_points</strong> : pair of <a class="reference internal" href="https://graph-tool.skewed.de/static/doc/graph_tool.html#graph_tool.Vertex" title="graph_tool.Vertex"><code class="xref py py-class docutils literal notranslate"><span class="pre">Vertex</span></code></a></p>
<blockquote class="last">
<div><p>The two vertices which correspond to the pseudo-diameter found.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>The pseudo-diameter is an approximate graph diameter. It is obtained by
starting from a vertex <cite>source</cite>, and finds a vertex <cite>target</cite> that is
farthest away from <cite>source</cite>. This process is repeated by treating
<cite>target</cite> as the new starting vertex, and ends when the graph distance no
longer increases. A vertex from the last level set that has the smallest
degree is chosen as the final starting vertex u, and a traversal is done
to see if the graph distance can be increased. This graph distance is
taken to be the pseudo-diameter.</p>
<p>The paths are computed with a breadth-first search (BFS) or Dijkstra’s
algorithm <a class="reference internal" href="topology.html#dijkstra314" id="id58">[dijkstra314]</a>, if weights are given.</p>
<p>The algorithm runs in <span class="math">\(O(V + E)\)</span> time, or <span class="math">\(O(V \log V)\)</span> if
weights are given.</p>
<p class="rubric">References</p>
<table class="docutils citation" frame="void" id="pseudo-diameter314" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="topology.html#id59">[pseudo-diameter314]</a></td><td><a class="reference external" href="http://en.wikipedia.org/wiki/Distance_%28graph_theory%29">http://en.wikipedia.org/wiki/Distance_%28graph_theory%29</a></td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="dijkstra314" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[dijkstra314]</td><td><em>(<a class="fn-backref" href="topology.html#id58">1</a>, <a class="fn-backref" href="topology.html#id60">2</a>)</em> E. Dijkstra, “A note on two problems in connexion with
graphs.” Numerische Mathematik, 1:269-271, 1959.</td></tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">numpy.random</span> <span class="k">import</span> <span class="n">poisson</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">g</span> <span class="o">=</span> <span class="n">gt</span><span class="o">.</span><span class="n">random_graph</span><span class="p">(</span><span class="mi">300</span><span class="p">,</span> <span class="k">lambda</span><span class="p">:</span> <span class="p">(</span><span class="n">poisson</span><span class="p">(</span><span class="mi">3</span><span class="p">),</span> <span class="n">poisson</span><span class="p">(</span><span class="mi">3</span><span class="p">)))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dist</span><span class="p">,</span> <span class="n">ends</span> <span class="o">=</span> <span class="n">gt</span><span class="o">.</span><span class="n">pseudo_diameter</span><span class="p">(</span><span class="n">g</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">dist</span><span class="p">)</span>
<span class="go">10.0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">ends</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="nb">int</span><span class="p">(</span><span class="n">ends</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>
<span class="go">0 11</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="graph_tool.topology.is_bipartite">
<code class="descclassname">graph_tool.topology.</code><code class="descname">is_bipartite</code><span class="sig-paren">(</span><em>g</em>, <em>partition=False</em>, <em>find_odd_cycle=False</em><span class="sig-paren">)</span><a class="reference internal" href="../static/doc/_modules/graph_tool/topology.html#is_bipartite"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="topology.html#graph_tool.topology.is_bipartite" title="Permalink to this definition">¶</a></dt>
<dd><p>Test if the graph is bipartite.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>g</strong> : <a class="reference internal" href="https://graph-tool.skewed.de/static/doc/graph_tool.html#graph_tool.Graph" title="graph_tool.Graph"><code class="xref py py-class docutils literal notranslate"><span class="pre">Graph</span></code></a></p>
<blockquote>
<div><p>Graph to be used.</p>
</div></blockquote>
<p><strong>partition</strong> : bool (optional, default: <code class="docutils literal notranslate"><span class="pre">False</span></code>)</p>
<blockquote>
<div><p>If <code class="docutils literal notranslate"><span class="pre">True</span></code>, return the two partitions in case the graph is bipartite.</p>
</div></blockquote>
<p><strong>find_odd_cycle</strong> : bool (optional, default: <code class="docutils literal notranslate"><span class="pre">False</span></code>)</p>
<blockquote>
<div><p>If <code class="docutils literal notranslate"><span class="pre">True</span></code>, return an odd cycle if the graph is not bipartite.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>is_bipartite</strong> : <code class="docutils literal notranslate"><span class="pre">bool</span></code></p>
<blockquote>
<div><p>Whether or not the graph is bipartite.</p>
</div></blockquote>
<p><strong>partition</strong> : <a class="reference internal" href="https://graph-tool.skewed.de/static/doc/graph_tool.html#graph_tool.PropertyMap" title="graph_tool.PropertyMap"><code class="xref py py-class docutils literal notranslate"><span class="pre">PropertyMap</span></code></a> (only if <code class="docutils literal notranslate"><span class="pre">partition=True</span></code>)</p>
<blockquote>
<div><p>A vertex property map with the graph partitioning (or <code class="docutils literal notranslate"><span class="pre">None</span></code>) if the
graph is not bipartite.</p>
</div></blockquote>
<p><strong>odd_cycle</strong> : list of vertices (only if <code class="docutils literal notranslate"><span class="pre">find_odd_cycle=True</span></code>)</p>
<blockquote class="last">
<div><p>A list of vertices corresponding to an odd cycle, or <code class="docutils literal notranslate"><span class="pre">None</span></code> if none is
found.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>An undirected graph is bipartite if one can partition its set of vertices
into two sets, such that all edges go from one set to the other.</p>
<p>This algorithm runs in <span class="math">\(O(V + E)\)</span> time.</p>
<p class="rubric">References</p>
<table class="docutils citation" frame="void" id="boost-bipartite316" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="topology.html#id61">[boost-bipartite316]</a></td><td><a class="reference external" href="http://www.boost.org/libs/graph/doc/is_bipartite.html">http://www.boost.org/libs/graph/doc/is_bipartite.html</a></td></tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">g</span> <span class="o">=</span> <span class="n">gt</span><span class="o">.</span><span class="n">lattice</span><span class="p">([</span><span class="mi">10</span><span class="p">,</span> <span class="mi">10</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">is_bi</span><span class="p">,</span> <span class="n">part</span> <span class="o">=</span> <span class="n">gt</span><span class="o">.</span><span class="n">is_bipartite</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">partition</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">is_bi</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">gt</span><span class="o">.</span><span class="n">graph_draw</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">vertex_fill_color</span><span class="o">=</span><span class="n">part</span><span class="p">,</span> <span class="n">output_size</span><span class="o">=</span><span class="p">(</span><span class="mi">300</span><span class="p">,</span> <span class="mi">300</span><span class="p">),</span> <span class="n">output</span><span class="o">=</span><span class="s2">&quot;bipartite.pdf&quot;</span><span class="p">)</span>
<span class="go">&lt;...&gt;</span>
</pre></div>
</div>
<div class="figure align-center" id="id85">
<img alt="_images/bipartite.png" src="../static/doc/_images/bipartite.png" />
<p class="caption"><span class="caption-text">Bipartition of a 2D lattice.</span></p>
</div>
</dd></dl>

<dl class="function">
<dt id="graph_tool.topology.is_planar">
<code class="descclassname">graph_tool.topology.</code><code class="descname">is_planar</code><span class="sig-paren">(</span><em>g</em>, <em>embedding=False</em>, <em>kuratowski=False</em><span class="sig-paren">)</span><a class="reference internal" href="../static/doc/_modules/graph_tool/topology.html#is_planar"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="topology.html#graph_tool.topology.is_planar" title="Permalink to this definition">¶</a></dt>
<dd><p>Test if the graph is planar.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>g</strong> : <a class="reference internal" href="https://graph-tool.skewed.de/static/doc/graph_tool.html#graph_tool.Graph" title="graph_tool.Graph"><code class="xref py py-class docutils literal notranslate"><span class="pre">Graph</span></code></a></p>
<blockquote>
<div><p>Graph to be used.</p>
</div></blockquote>
<p><strong>embedding</strong> : bool (optional, default: False)</p>
<blockquote>
<div><p>If true, return a mapping from vertices to the clockwise order of
out-edges in the planar embedding.</p>
</div></blockquote>
<p><strong>kuratowski</strong> : bool (optional, default: False)</p>
<blockquote>
<div><p>If true, the minimal set of edges that form the obstructing Kuratowski
subgraph will be returned as a property map, if the graph is not planar.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>is_planar</strong> : bool</p>
<blockquote>
<div><p>Whether or not the graph is planar.</p>
</div></blockquote>
<p><strong>embedding</strong> : <a class="reference internal" href="https://graph-tool.skewed.de/static/doc/graph_tool.html#graph_tool.PropertyMap" title="graph_tool.PropertyMap"><code class="xref py py-class docutils literal notranslate"><span class="pre">PropertyMap</span></code></a> (only if <cite>embedding=True</cite>)</p>
<blockquote>
<div><p>A vertex property map with the out-edges indexes in clockwise order in
the planar embedding,</p>
</div></blockquote>
<p><strong>kuratowski</strong> : <a class="reference internal" href="https://graph-tool.skewed.de/static/doc/graph_tool.html#graph_tool.PropertyMap" title="graph_tool.PropertyMap"><code class="xref py py-class docutils literal notranslate"><span class="pre">PropertyMap</span></code></a> (only if <cite>kuratowski=True</cite>)</p>
<blockquote class="last">
<div><p>An edge property map with the minimal set of edges that form the
obstructing Kuratowski subgraph (if the value of kuratowski[e] is 1,
the edge belongs to the set)</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>A graph is planar if it can be drawn in two-dimensional space without any of
its edges crossing. This algorithm performs the Boyer-Myrvold planarity
testing <a class="reference internal" href="topology.html#boyer-myrvold317" id="id62">[boyer-myrvold317]</a>. See <a class="reference internal" href="topology.html#boost-planarity317" id="id63">[boost-planarity317]</a> for more details.</p>
<p>This algorithm runs in <span class="math">\(O(V)\)</span> time.</p>
<p class="rubric">References</p>
<table class="docutils citation" frame="void" id="boyer-myrvold317" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[boyer-myrvold317]</td><td><em>(<a class="fn-backref" href="topology.html#id62">1</a>, <a class="fn-backref" href="topology.html#id64">2</a>)</em> John M. Boyer and Wendy J. Myrvold, “On the Cutting Edge:
Simplified O(n) Planarity by Edge Addition” Journal of Graph Algorithms
and Applications, 8(2): 241-273, 2004. <a class="reference external" href="http://www.emis.ams.org/journals/JGAA/accepted/2004/BoyerMyrvold2004.8.3.pdf">http://www.emis.ams.org/journals/JGAA/accepted/2004/BoyerMyrvold2004.8.3.pdf</a></td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="boost-planarity317" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[boost-planarity317]</td><td><em>(<a class="fn-backref" href="topology.html#id63">1</a>, <a class="fn-backref" href="topology.html#id65">2</a>)</em> <a class="reference external" href="http://www.boost.org/libs/graph/doc/boyer_myrvold.html">http://www.boost.org/libs/graph/doc/boyer_myrvold.html</a></td></tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">numpy.random</span> <span class="k">import</span> <span class="n">random</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">g</span> <span class="o">=</span> <span class="n">gt</span><span class="o">.</span><span class="n">triangulation</span><span class="p">(</span><span class="n">random</span><span class="p">((</span><span class="mi">100</span><span class="p">,</span><span class="mi">2</span><span class="p">)))[</span><span class="mi">0</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">p</span><span class="p">,</span> <span class="n">embed_order</span> <span class="o">=</span> <span class="n">gt</span><span class="o">.</span><span class="n">is_planar</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">embedding</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">embed_order</span><span class="p">[</span><span class="n">g</span><span class="o">.</span><span class="n">vertex</span><span class="p">(</span><span class="mi">0</span><span class="p">)]))</span>
<span class="go">[0, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 1]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">g</span> <span class="o">=</span> <span class="n">gt</span><span class="o">.</span><span class="n">random_graph</span><span class="p">(</span><span class="mi">100</span><span class="p">,</span> <span class="k">lambda</span><span class="p">:</span> <span class="mi">4</span><span class="p">,</span> <span class="n">directed</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">p</span><span class="p">,</span> <span class="n">kur</span> <span class="o">=</span> <span class="n">gt</span><span class="o">.</span><span class="n">is_planar</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">kuratowski</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
<span class="go">False</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">g</span><span class="o">.</span><span class="n">set_edge_filter</span><span class="p">(</span><span class="n">kur</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">gt</span><span class="o">.</span><span class="n">graph_draw</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">output_size</span><span class="o">=</span><span class="p">(</span><span class="mi">300</span><span class="p">,</span> <span class="mi">300</span><span class="p">),</span> <span class="n">output</span><span class="o">=</span><span class="s2">&quot;kuratowski.pdf&quot;</span><span class="p">)</span>
<span class="go">&lt;...&gt;</span>
</pre></div>
</div>
<div class="figure align-center" id="id86">
<img alt="_images/kuratowski.png" src="../static/doc/_images/kuratowski.png" />
<p class="caption"><span class="caption-text">Obstructing Kuratowski subgraph of a random graph.</span></p>
</div>
</dd></dl>

<dl class="function">
<dt id="graph_tool.topology.make_maximal_planar">
<code class="descclassname">graph_tool.topology.</code><code class="descname">make_maximal_planar</code><span class="sig-paren">(</span><em>g</em><span class="sig-paren">)</span><a class="reference internal" href="../static/doc/_modules/graph_tool/topology.html#make_maximal_planar"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="topology.html#graph_tool.topology.make_maximal_planar" title="Permalink to this definition">¶</a></dt>
<dd><p>Add edges to the graph to make it maximally planar.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>g</strong> : <a class="reference internal" href="https://graph-tool.skewed.de/static/doc/graph_tool.html#graph_tool.Graph" title="graph_tool.Graph"><code class="xref py py-class docutils literal notranslate"><span class="pre">Graph</span></code></a></p>
<blockquote class="last">
<div><p>Graph to be used. It must be a biconnected planar graph with at least 3
vertices.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>A graph is maximal planar if no additional edges can be added to it without
creating a non-planar graph. By Euler’s formula, a maximal planar graph with
V &gt; 2 vertices always has 3V - 6 edges and 2V - 4 faces.</p>
<p>The input graph to make_maximal_planar() must be a biconnected planar graph
with at least 3 vertices.</p>
<p>This algorithm runs in <span class="math">\(O(V + E)\)</span> time.</p>
<p class="rubric">References</p>
<table class="docutils citation" frame="void" id="boost-planarity319" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="topology.html#id66">[boost-planarity319]</a></td><td><a class="reference external" href="http://www.boost.org/libs/graph/doc/make_maximal_planar.html">http://www.boost.org/libs/graph/doc/make_maximal_planar.html</a></td></tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">g</span> <span class="o">=</span> <span class="n">gt</span><span class="o">.</span><span class="n">lattice</span><span class="p">([</span><span class="mi">10</span><span class="p">,</span> <span class="mi">10</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">gt</span><span class="o">.</span><span class="n">make_maximal_planar</span><span class="p">(</span><span class="n">g</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">gt</span><span class="o">.</span><span class="n">is_planar</span><span class="p">(</span><span class="n">g</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">g</span><span class="o">.</span><span class="n">num_vertices</span><span class="p">(),</span> <span class="n">g</span><span class="o">.</span><span class="n">num_edges</span><span class="p">())</span>
<span class="go">100 294</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pos</span> <span class="o">=</span> <span class="n">gt</span><span class="o">.</span><span class="n">planar_layout</span><span class="p">(</span><span class="n">g</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">gt</span><span class="o">.</span><span class="n">graph_draw</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">pos</span><span class="p">,</span> <span class="n">output_size</span><span class="o">=</span><span class="p">(</span><span class="mi">300</span><span class="p">,</span> <span class="mi">300</span><span class="p">),</span> <span class="n">output</span><span class="o">=</span><span class="s2">&quot;maximal_planar.pdf&quot;</span><span class="p">)</span>
<span class="go">&lt;...&gt;</span>
</pre></div>
</div>
<div class="figure align-center" id="id87">
<img alt="_images/maximal_planar.png" src="../static/doc/_images/maximal_planar.png" />
<p class="caption"><span class="caption-text">A maximally planar graph.</span></p>
</div>
</dd></dl>

<dl class="function">
<dt id="graph_tool.topology.is_DAG">
<code class="descclassname">graph_tool.topology.</code><code class="descname">is_DAG</code><span class="sig-paren">(</span><em>g</em><span class="sig-paren">)</span><a class="reference internal" href="../static/doc/_modules/graph_tool/topology.html#is_DAG"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="topology.html#graph_tool.topology.is_DAG" title="Permalink to this definition">¶</a></dt>
<dd><p>Return <cite>True</cite> if the graph is a directed acyclic graph (DAG).</p>
<p class="rubric">Notes</p>
<p>The time complexity is <span class="math">\(O(V + E)\)</span>.</p>
<p class="rubric">References</p>
<table class="docutils citation" frame="void" id="dag-wiki320" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="topology.html#id67">[DAG-wiki320]</a></td><td><a class="reference external" href="http://en.wikipedia.org/wiki/Directed_acyclic_graph">http://en.wikipedia.org/wiki/Directed_acyclic_graph</a></td></tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">g</span> <span class="o">=</span> <span class="n">gt</span><span class="o">.</span><span class="n">random_graph</span><span class="p">(</span><span class="mi">30</span><span class="p">,</span> <span class="k">lambda</span><span class="p">:</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">gt</span><span class="o">.</span><span class="n">is_DAG</span><span class="p">(</span><span class="n">g</span><span class="p">))</span>
<span class="go">False</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">tree</span> <span class="o">=</span> <span class="n">gt</span><span class="o">.</span><span class="n">min_spanning_tree</span><span class="p">(</span><span class="n">g</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">g</span><span class="o">.</span><span class="n">set_edge_filter</span><span class="p">(</span><span class="n">tree</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">gt</span><span class="o">.</span><span class="n">is_DAG</span><span class="p">(</span><span class="n">g</span><span class="p">))</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="graph_tool.topology.max_cardinality_matching">
<code class="descclassname">graph_tool.topology.</code><code class="descname">max_cardinality_matching</code><span class="sig-paren">(</span><em>g</em>, <em>heuristic=False</em>, <em>weight=None</em>, <em>minimize=True</em>, <em>match=None</em><span class="sig-paren">)</span><a class="reference internal" href="../static/doc/_modules/graph_tool/topology.html#max_cardinality_matching"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="topology.html#graph_tool.topology.max_cardinality_matching" title="Permalink to this definition">¶</a></dt>
<dd><p>Find a maximum cardinality matching in the graph.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>g</strong> : <a class="reference internal" href="https://graph-tool.skewed.de/static/doc/graph_tool.html#graph_tool.Graph" title="graph_tool.Graph"><code class="xref py py-class docutils literal notranslate"><span class="pre">Graph</span></code></a></p>
<blockquote>
<div><p>Graph to be used.</p>
</div></blockquote>
<p><strong>heuristic</strong> : bool (optional, default: <cite>False</cite>)</p>
<blockquote>
<div><p>If true, a random heuristic will be used, which runs in linear time.</p>
</div></blockquote>
<p><strong>weight</strong> : <a class="reference internal" href="https://graph-tool.skewed.de/static/doc/graph_tool.html#graph_tool.PropertyMap" title="graph_tool.PropertyMap"><code class="xref py py-class docutils literal notranslate"><span class="pre">PropertyMap</span></code></a> (optional, default: <cite>None</cite>)</p>
<blockquote>
<div><p>If provided, the matching will minimize the edge weights (or maximize
if <code class="docutils literal notranslate"><span class="pre">minimize</span> <span class="pre">==</span> <span class="pre">False</span></code>). This option has no effect if
<code class="docutils literal notranslate"><span class="pre">heuristic</span> <span class="pre">==</span> <span class="pre">False</span></code>.</p>
</div></blockquote>
<p><strong>minimize</strong> : bool (optional, default: <cite>True</cite>)</p>
<blockquote>
<div><p>If <cite>True</cite>, the matching will minimize the weights, otherwise they will
be maximized. This option has no effect if <code class="docutils literal notranslate"><span class="pre">heuristic</span> <span class="pre">==</span> <span class="pre">False</span></code>.</p>
</div></blockquote>
<p><strong>match</strong> : <a class="reference internal" href="https://graph-tool.skewed.de/static/doc/graph_tool.html#graph_tool.PropertyMap" title="graph_tool.PropertyMap"><code class="xref py py-class docutils literal notranslate"><span class="pre">PropertyMap</span></code></a> (optional, default: <cite>None</cite>)</p>
<blockquote>
<div><p>Edge property map where the matching will be specified.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>match</strong> : <a class="reference internal" href="https://graph-tool.skewed.de/static/doc/graph_tool.html#graph_tool.PropertyMap" title="graph_tool.PropertyMap"><code class="xref py py-class docutils literal notranslate"><span class="pre">PropertyMap</span></code></a></p>
<blockquote class="last">
<div><p>Boolean edge property map where the matching is specified.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>A <em>matching</em> is a subset of the edges of a graph such that no two edges
share a common vertex. A <em>maximum cardinality matching</em> has maximum size
over all matchings in the graph.</p>
<p>If the parameter <code class="docutils literal notranslate"><span class="pre">weight</span></code> is provided, as well as <code class="docutils literal notranslate"><span class="pre">heuristic</span> <span class="pre">==</span> <span class="pre">True</span></code> a
matching with maximum cardinality <em>and</em> maximum (or minimum) weight is
returned.</p>
<p>If <code class="docutils literal notranslate"><span class="pre">heuristic</span> <span class="pre">==</span> <span class="pre">True</span></code> the algorithm does not necessarily return the
maximum matching, instead the focus is to run on linear time.</p>
<p>This algorithm runs in time <span class="math">\(O(EV\times\alpha(E,V))\)</span>, where
<span class="math">\(\alpha(m,n)\)</span> is a slow growing function that is at most 4 for any
feasible input. If <cite>heuristic == True</cite>, the algorithm runs in time
<span class="math">\(O(V + E)\)</span>.</p>
<p>For a more detailed description, see <a class="reference internal" href="topology.html#boost-max-matching321" id="id68">[boost-max-matching321]</a>.</p>
<p class="rubric">References</p>
<table class="docutils citation" frame="void" id="boost-max-matching321" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[boost-max-matching321]</td><td><em>(<a class="fn-backref" href="topology.html#id68">1</a>, <a class="fn-backref" href="topology.html#id69">2</a>)</em> <a class="reference external" href="http://www.boost.org/libs/graph/doc/maximum_matching.html">http://www.boost.org/libs/graph/doc/maximum_matching.html</a></td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="matching-heuristic321" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="topology.html#id70">[matching-heuristic321]</a></td><td>B. Hendrickson and R. Leland. “A Multilevel Algorithm
for Partitioning Graphs.” In S. Karin, editor, Proc. Supercomputing ’95,
San Diego. ACM Press, New York, 1995, <a class="reference external" href="https://dx.doi.org/10.1145/224170.224228">DOI: 10.1145/224170.224228</a> [<a class="reference external" href="https://sci-hub.tw/10.1145/224170.224228">sci-hub</a>, <a class="reference external" href="https://scihub22266oqcxt.onion.link/10.1145/224170.224228">&#64;tor</a>]</td></tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">g</span> <span class="o">=</span> <span class="n">gt</span><span class="o">.</span><span class="n">GraphView</span><span class="p">(</span><span class="n">gt</span><span class="o">.</span><span class="n">price_network</span><span class="p">(</span><span class="mi">300</span><span class="p">),</span> <span class="n">directed</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">res</span> <span class="o">=</span> <span class="n">gt</span><span class="o">.</span><span class="n">max_cardinality_matching</span><span class="p">(</span><span class="n">g</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">res</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">w</span> <span class="o">=</span> <span class="n">res</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="s2">&quot;double&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">w</span><span class="o">.</span><span class="n">a</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">w</span><span class="o">.</span><span class="n">a</span> <span class="o">+</span> <span class="mi">2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">gt</span><span class="o">.</span><span class="n">graph_draw</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">edge_color</span><span class="o">=</span><span class="n">res</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">edge_pen_width</span><span class="o">=</span><span class="n">w</span><span class="p">,</span> <span class="n">vertex_fill_color</span><span class="o">=</span><span class="s2">&quot;grey&quot;</span><span class="p">,</span>
<span class="gp">... </span>              <span class="n">output</span><span class="o">=</span><span class="s2">&quot;max_card_match.pdf&quot;</span><span class="p">)</span>
<span class="go">&lt;...&gt;</span>
</pre></div>
</div>
<div class="figure align-center" id="id88">
<img alt="_images/max_card_match.png" src="../static/doc/_images/max_card_match.png" />
<p class="caption"><span class="caption-text">Edges belonging to the matching are in yellow.</span></p>
</div>
</dd></dl>

<dl class="function">
<dt id="graph_tool.topology.max_independent_vertex_set">
<code class="descclassname">graph_tool.topology.</code><code class="descname">max_independent_vertex_set</code><span class="sig-paren">(</span><em>g</em>, <em>high_deg=False</em>, <em>mivs=None</em><span class="sig-paren">)</span><a class="reference internal" href="../static/doc/_modules/graph_tool/topology.html#max_independent_vertex_set"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="topology.html#graph_tool.topology.max_independent_vertex_set" title="Permalink to this definition">¶</a></dt>
<dd><p>Find a maximal independent vertex set in the graph.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>g</strong> : <a class="reference internal" href="https://graph-tool.skewed.de/static/doc/graph_tool.html#graph_tool.Graph" title="graph_tool.Graph"><code class="xref py py-class docutils literal notranslate"><span class="pre">Graph</span></code></a></p>
<blockquote>
<div><p>Graph to be used.</p>
</div></blockquote>
<p><strong>high_deg</strong> : bool (optional, default: <cite>False</cite>)</p>
<blockquote>
<div><p>If <cite>True</cite>, vertices with high degree will be included first in the set,
otherwise they will be included last.</p>
</div></blockquote>
<p><strong>mivs</strong> : <a class="reference internal" href="https://graph-tool.skewed.de/static/doc/graph_tool.html#graph_tool.PropertyMap" title="graph_tool.PropertyMap"><code class="xref py py-class docutils literal notranslate"><span class="pre">PropertyMap</span></code></a> (optional, default: <cite>None</cite>)</p>
<blockquote>
<div><p>Vertex property map where the vertex set will be specified.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>mivs</strong> : <a class="reference internal" href="https://graph-tool.skewed.de/static/doc/graph_tool.html#graph_tool.PropertyMap" title="graph_tool.PropertyMap"><code class="xref py py-class docutils literal notranslate"><span class="pre">PropertyMap</span></code></a></p>
<blockquote class="last">
<div><p>Boolean vertex property map where the set is specified.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>A maximal independent vertex set is an independent set such that adding any
other vertex to the set forces the set to contain an edge between two
vertices of the set.</p>
<p>This implements the algorithm described in <a class="reference internal" href="topology.html#mivs-luby323" id="id71">[mivs-luby323]</a>, which runs in time
<span class="math">\(O(V + E)\)</span>.</p>
<p class="rubric">References</p>
<table class="docutils citation" frame="void" id="mivs-wikipedia323" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="topology.html#id72">[mivs-wikipedia323]</a></td><td><a class="reference external" href="http://en.wikipedia.org/wiki/Independent_set_%28graph_theory%29">http://en.wikipedia.org/wiki/Independent_set_%28graph_theory%29</a></td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="mivs-luby323" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[mivs-luby323]</td><td><em>(<a class="fn-backref" href="topology.html#id71">1</a>, <a class="fn-backref" href="topology.html#id73">2</a>)</em> Luby, M., “A simple parallel algorithm for the maximal independent set problem”,
Proc. 17th Symposium on Theory of Computing, Association for Computing Machinery, pp. 1-10, (1985)
<a class="reference external" href="https://dx.doi.org/10.1145/22145.22146">DOI: 10.1145/22145.22146</a> [<a class="reference external" href="https://sci-hub.tw/10.1145/22145.22146">sci-hub</a>, <a class="reference external" href="https://scihub22266oqcxt.onion.link/10.1145/22145.22146">&#64;tor</a>].</td></tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">g</span> <span class="o">=</span> <span class="n">gt</span><span class="o">.</span><span class="n">GraphView</span><span class="p">(</span><span class="n">gt</span><span class="o">.</span><span class="n">price_network</span><span class="p">(</span><span class="mi">300</span><span class="p">),</span> <span class="n">directed</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">res</span> <span class="o">=</span> <span class="n">gt</span><span class="o">.</span><span class="n">max_independent_vertex_set</span><span class="p">(</span><span class="n">g</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">gt</span><span class="o">.</span><span class="n">graph_draw</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">vertex_fill_color</span><span class="o">=</span><span class="n">res</span><span class="p">,</span> <span class="n">output</span><span class="o">=</span><span class="s2">&quot;mivs.pdf&quot;</span><span class="p">)</span>
<span class="go">&lt;...&gt;</span>
</pre></div>
</div>
<div class="figure align-center" id="id89">
<img alt="_images/mivs.png" src="../static/doc/_images/mivs.png" />
<p class="caption"><span class="caption-text">Vertices belonging to the set are in yellow.</span></p>
</div>
</dd></dl>

<dl class="function">
<dt id="graph_tool.topology.edge_reciprocity">
<code class="descclassname">graph_tool.topology.</code><code class="descname">edge_reciprocity</code><span class="sig-paren">(</span><em>g</em><span class="sig-paren">)</span><a class="reference internal" href="../static/doc/_modules/graph_tool/topology.html#edge_reciprocity"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="topology.html#graph_tool.topology.edge_reciprocity" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the edge reciprocity of the graph.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>g</strong> : <a class="reference internal" href="https://graph-tool.skewed.de/static/doc/graph_tool.html#graph_tool.Graph" title="graph_tool.Graph"><code class="xref py py-class docutils literal notranslate"><span class="pre">Graph</span></code></a></p>
<blockquote>
<div><p>Graph to be used
edges.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>reciprocity</strong> : float</p>
<blockquote class="last">
<div><p>The reciprocity value.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>The edge <a class="reference internal" href="topology.html#reciprocity325" id="id74">[reciprocity325]</a> is defined as <span class="math">\(E^\leftrightarrow/E\)</span>, where
<span class="math">\(E^\leftrightarrow\)</span> and <span class="math">\(E\)</span> are the number of bidirectional and
all edges in the graph, respectively.</p>
<p>The algorithm runs with complexity <span class="math">\(O(E + V)\)</span>.</p>
<p class="rubric">References</p>
<table class="docutils citation" frame="void" id="reciprocity325" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[reciprocity325]</td><td><em>(<a class="fn-backref" href="topology.html#id74">1</a>, <a class="fn-backref" href="topology.html#id75">2</a>)</em> S. Wasserman and K. Faust, “Social Network Analysis”.
(Cambridge University Press, Cambridge, 1994)</td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="lopez-reciprocity-2007325" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="topology.html#id76">[lopez-reciprocity-2007325]</a></td><td>Gorka Zamora-López, Vinko Zlatić, Changsong Zhou, Hrvoje Štefančić, and Jürgen Kurths
“Reciprocity of networks with degree correlations and arbitrary degree sequences”, Phys. Rev. E 77, 016106 (2008)
<a class="reference external" href="https://dx.doi.org/10.1103/PhysRevE.77.016106">DOI: 10.1103/PhysRevE.77.016106</a> [<a class="reference external" href="https://sci-hub.tw/10.1103/PhysRevE.77.016106">sci-hub</a>, <a class="reference external" href="https://scihub22266oqcxt.onion.link/10.1103/PhysRevE.77.016106">&#64;tor</a>], <a class="reference external" href="https://arxiv.org/abs/0706.3372">arXiv: 0706.3372</a></td></tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">g</span> <span class="o">=</span> <span class="n">gt</span><span class="o">.</span><span class="n">Graph</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">g</span><span class="o">.</span><span class="n">add_vertex</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="go">&lt;...&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">g</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="n">g</span><span class="o">.</span><span class="n">vertex</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="n">g</span><span class="o">.</span><span class="n">vertex</span><span class="p">(</span><span class="mi">1</span><span class="p">))</span>
<span class="go">&lt;...&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">gt</span><span class="o">.</span><span class="n">edge_reciprocity</span><span class="p">(</span><span class="n">g</span><span class="p">)</span>
<span class="go">0.0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">g</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="n">g</span><span class="o">.</span><span class="n">vertex</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span> <span class="n">g</span><span class="o">.</span><span class="n">vertex</span><span class="p">(</span><span class="mi">0</span><span class="p">))</span>
<span class="go">&lt;...&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">gt</span><span class="o">.</span><span class="n">edge_reciprocity</span><span class="p">(</span><span class="n">g</span><span class="p">)</span>
<span class="go">1.0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">g</span> <span class="o">=</span> <span class="n">gt</span><span class="o">.</span><span class="n">collection</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;pgp-strong-2009&quot;</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">gt</span><span class="o">.</span><span class="n">edge_reciprocity</span><span class="p">(</span><span class="n">g</span><span class="p">)</span>
<span class="go">0.692196963163...</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="graph_tool.topology.tsp_tour">
<code class="descclassname">graph_tool.topology.</code><code class="descname">tsp_tour</code><span class="sig-paren">(</span><em>g</em>, <em>src</em>, <em>weight=None</em><span class="sig-paren">)</span><a class="reference internal" href="../static/doc/_modules/graph_tool/topology.html#tsp_tour"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="topology.html#graph_tool.topology.tsp_tour" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a traveling salesman tour of the graph, which is guaranteed to be
twice as long as the optimal tour in the worst case.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>g</strong> : <a class="reference internal" href="https://graph-tool.skewed.de/static/doc/graph_tool.html#graph_tool.Graph" title="graph_tool.Graph"><code class="xref py py-class docutils literal notranslate"><span class="pre">Graph</span></code></a></p>
<blockquote>
<div><p>Graph to be used. The graph must be undirected.</p>
</div></blockquote>
<p><strong>src</strong> : <a class="reference internal" href="https://graph-tool.skewed.de/static/doc/graph_tool.html#graph_tool.Vertex" title="graph_tool.Vertex"><code class="xref py py-class docutils literal notranslate"><span class="pre">Vertex</span></code></a></p>
<blockquote>
<div><p>The source (and target) of the tour.</p>
</div></blockquote>
<p><strong>weight</strong> : <a class="reference internal" href="https://graph-tool.skewed.de/static/doc/graph_tool.html#graph_tool.PropertyMap" title="graph_tool.PropertyMap"><code class="xref py py-class docutils literal notranslate"><span class="pre">PropertyMap</span></code></a> (optional, default: None)</p>
<blockquote>
<div><p>Edge weights.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>tour</strong> : <a class="reference external" href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v1.14)"><code class="xref py py-class docutils literal notranslate"><span class="pre">numpy.ndarray</span></code></a></p>
<blockquote class="last">
<div><p>List of vertex indexes corresponding to the tour.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>The algorithm runs with <span class="math">\(O(E\log V)\)</span> complexity.</p>
<p class="rubric">References</p>
<table class="docutils citation" frame="void" id="tsp-bgl327" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="topology.html#id77">[tsp-bgl327]</a></td><td><a class="reference external" href="http://www.boost.org/libs/graph/doc/metric_tsp_approx.html">http://www.boost.org/libs/graph/doc/metric_tsp_approx.html</a></td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="tsp327" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="topology.html#id78">[tsp327]</a></td><td><a class="reference external" href="http://en.wikipedia.org/wiki/Travelling_salesman_problem">http://en.wikipedia.org/wiki/Travelling_salesman_problem</a></td></tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">g</span> <span class="o">=</span> <span class="n">gt</span><span class="o">.</span><span class="n">lattice</span><span class="p">([</span><span class="mi">10</span><span class="p">,</span> <span class="mi">10</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">tour</span> <span class="o">=</span> <span class="n">gt</span><span class="o">.</span><span class="n">tsp_tour</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">g</span><span class="o">.</span><span class="n">vertex</span><span class="p">(</span><span class="mi">0</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">tour</span><span class="p">)</span>
<span class="go">[ 0  1  2 11 12 21 22 31 32 41 42 51 52 61 62 71 72 81 82 83 73 63 53 43</span>
<span class="go"> 33 23 13  3  4  5  6  7  8  9 19 29 39 49 59 69 79 89 14 24 34 44 54 64</span>
<span class="go"> 74 84 91 92 93 94 95 85 75 65 55 45 35 25 15 16 17 18 27 28 37 38 47 48</span>
<span class="go"> 57 58 67 68 77 78 87 88 97 98 99 26 36 46 56 66 76 86 96 10 20 30 40 50</span>
<span class="go"> 60 70 80 90  0]</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="graph_tool.topology.sequential_vertex_coloring">
<code class="descclassname">graph_tool.topology.</code><code class="descname">sequential_vertex_coloring</code><span class="sig-paren">(</span><em>g</em>, <em>order=None</em>, <em>color=None</em><span class="sig-paren">)</span><a class="reference internal" href="../static/doc/_modules/graph_tool/topology.html#sequential_vertex_coloring"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="topology.html#graph_tool.topology.sequential_vertex_coloring" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a vertex coloring of the graph.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>g</strong> : <a class="reference internal" href="https://graph-tool.skewed.de/static/doc/graph_tool.html#graph_tool.Graph" title="graph_tool.Graph"><code class="xref py py-class docutils literal notranslate"><span class="pre">Graph</span></code></a></p>
<blockquote>
<div><p>Graph to be used.</p>
</div></blockquote>
<p><strong>order</strong> : <a class="reference internal" href="https://graph-tool.skewed.de/static/doc/graph_tool.html#graph_tool.PropertyMap" title="graph_tool.PropertyMap"><code class="xref py py-class docutils literal notranslate"><span class="pre">PropertyMap</span></code></a> (optional, default: None)</p>
<blockquote>
<div><p>Order with which the vertices will be colored.</p>
</div></blockquote>
<p><strong>color</strong> : <a class="reference internal" href="https://graph-tool.skewed.de/static/doc/graph_tool.html#graph_tool.PropertyMap" title="graph_tool.PropertyMap"><code class="xref py py-class docutils literal notranslate"><span class="pre">PropertyMap</span></code></a> (optional, default: None)</p>
<blockquote>
<div><p>Integer-valued vertex property map to store the colors.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>color</strong> : <a class="reference internal" href="https://graph-tool.skewed.de/static/doc/graph_tool.html#graph_tool.PropertyMap" title="graph_tool.PropertyMap"><code class="xref py py-class docutils literal notranslate"><span class="pre">PropertyMap</span></code></a></p>
<blockquote class="last">
<div><p>Integer-valued vertex property map with the vertex colors.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>The time complexity is <span class="math">\(O(V(d+k))\)</span>, where <span class="math">\(V\)</span> is the number of
vertices, <span class="math">\(d\)</span> is the maximum degree of the vertices in the graph, and
<span class="math">\(k\)</span> is the number of colors used.</p>
<p class="rubric">References</p>
<table class="docutils citation" frame="void" id="sgc-bgl329" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="topology.html#id79">[sgc-bgl329]</a></td><td><a class="reference external" href="http://www.boost.org/libs/graph/doc/sequential_vertex_coloring.html">http://www.boost.org/libs/graph/doc/sequential_vertex_coloring.html</a></td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="graph-coloring329" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="topology.html#id80">[graph-coloring329]</a></td><td><a class="reference external" href="http://en.wikipedia.org/wiki/Graph_coloring">http://en.wikipedia.org/wiki/Graph_coloring</a></td></tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">g</span> <span class="o">=</span> <span class="n">gt</span><span class="o">.</span><span class="n">lattice</span><span class="p">([</span><span class="mi">10</span><span class="p">,</span> <span class="mi">10</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">colors</span> <span class="o">=</span> <span class="n">gt</span><span class="o">.</span><span class="n">sequential_vertex_coloring</span><span class="p">(</span><span class="n">g</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">colors</span><span class="o">.</span><span class="n">a</span><span class="p">)</span>
<span class="go">[0 1 0 1 0 1 0 1 0 1 1 0 1 0 1 0 1 0 1 0 0 1 0 1 0 1 0 1 0 1 1 0 1 0 1 0 1</span>
<span class="go"> 0 1 0 0 1 0 1 0 1 0 1 0 1 1 0 1 0 1 0 1 0 1 0 0 1 0 1 0 1 0 1 0 1 1 0 1 0</span>
<span class="go"> 1 0 1 0 1 0 0 1 0 1 0 1 0 1 0 1 1 0 1 0 1 0 1 0 1 0]</span>
</pre></div>
</div>
</dd></dl>

</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="../doc">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="topology.html#"><code class="docutils literal notranslate"><span class="pre">graph_tool.topology</span></code> - Assessing graph topology</a><ul>
<li><a class="reference internal" href="topology.html#summary">Summary</a></li>
<li><a class="reference internal" href="topology.html#contents">Contents</a></li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="stats.html"
                        title="previous chapter"><code class="docutils literal notranslate"><span class="pre">graph_tool.stats</span></code> - Miscellaneous statistics</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="../static/doc/util.html"
                        title="next chapter"><code class="docutils literal notranslate"><span class="pre">graph_tool.util</span></code> - Graph utilities</a></p>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="../static/doc/_sources/topology.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="https://graph-tool.skewed.de/static/doc/search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    </div>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="https://graph-tool.skewed.de/static/doc/genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="https://graph-tool.skewed.de/static/doc/py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="../static/doc/util.html" title="graph_tool.util - Graph utilities"
             >next</a> |</li>
        <li class="right" >
          <a href="stats.html" title="graph_tool.stats - Miscellaneous statistics"
             >previous</a> |</li>
    <li><img src="../img/graph-icon.png" alt="logo" style="margin-right: 5px; margin-bottom:-2px;" /><a href="https://graph-tool.skewed.de/">Project Homepage</a> &raquo;</li>
    
        <li class="nav-item nav-item-0"><a href="../doc">graph-tool 2.27 documentation</a> &#187;</li>

          <li class="nav-item nav-item-1"><a href="../static/doc/modules.html" >Module documentation</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="https://graph-tool.skewed.de/static/doc/graph_tool.html" >graph_tool - efficient graph analysis and manipulation</a> &#187;</li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright 2018, Tiago de Paula Peixoto &lt;tiago@skewed.de&gt;.
      Last updated on Jun 28, 2018.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.7.5.
    </div>
  </body>
</html>